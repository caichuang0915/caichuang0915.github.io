{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/assets/default.jpg","path":"assets/default.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/tags/a.html","path":"tags/a.html","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"704ff00a214f768b76095a3230cf2143328121e4","modified":1739348896457},{"_id":"source/.DS_Store","hash":"f4f7e5dc7003f76496eec1cc628e7f505e1f0787","modified":1684462570310},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1739348896572},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1739348896572},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1739348896572},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1739348896572},{"_id":"themes/yilia/README.md","hash":"99985dc9f0f3473a26341245e436751bc42fd322","modified":1739348896572},{"_id":"themes/yilia/_config.yml","hash":"8ce164afb6e502e8eb3a13dce1e3467fd3021594","modified":1739348896572},{"_id":"themes/yilia/_config_bak.yml","hash":"c3a1694c111e2e1f05a174bd893fe951038fbda2","modified":1739348896572},{"_id":"themes/yilia/_config_bak1.yml","hash":"a5546f042098560741ed564ce48bb6641761029d","modified":1739348896572},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1739348896576},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1739348896595},{"_id":"source/_posts/mybatis_01.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1684462570337},{"_id":"source/photos/lazyload.min.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1684462570365},{"_id":"source/_posts/.DS_Store","hash":"d02ef298f82f808e4e54bf92c8eee2bdfbd6cd62","modified":1684462570311},{"_id":"source/_posts/Mysql-sql优化.md","hash":"8a202f4da058ca52828e3394354a3b4fa45926f4","modified":1739348896457},{"_id":"source/_posts/Mysql-业务设计.md","hash":"41126b66c13ab16f94fa6cb144cc6d153b9c5ab6","modified":1739348896458},{"_id":"source/_posts/Mysql-逻辑架构和存储引擎.md","hash":"6dfc0dd8b82fc8fd8f0770cb4551dede75f66235","modified":1739348896458},{"_id":"source/_posts/Mysql-慢查询和执行计划.md","hash":"673c81eccff35e9664c28082ef200a003cec7828","modified":1739348896458},{"_id":"source/_posts/Mysql-锁和事务.md","hash":"436f5848fcfc010dc3f63d0ef183dc831bd2ebf6","modified":1739348896459},{"_id":"source/_posts/Nginx-Location匹配规则.md","hash":"8fa01033e0fcd36001db508f26d40b1b387bc95d","modified":1739348896459},{"_id":"source/_posts/Nginx-location-rewrite.md","hash":"9e549e7bceb979747b2f98ddc53aebd111335d27","modified":1739348896459},{"_id":"source/_posts/Nginx简介.md","hash":"18e28b00e406b8159dd2f3940834da155440dd26","modified":1739348896463},{"_id":"source/_posts/Nginx跨域.md","hash":"67e3ade82ea7f61e2e8258e027d07590773ca9ca","modified":1739348896463},{"_id":"source/_posts/Nginx高可用keepalived.md","hash":"5ce746e5ab251ff9949a7c07a7c3325ca57c81a0","modified":1739348896463},{"_id":"source/_posts/docker-基础.md","hash":"9c095c8e70ff7b1da9c6e78ce7825b72953e0822","modified":1739348896463},{"_id":"source/_posts/dubbo-01.md","hash":"aebf703cc107bf2e7fdc1f8fea366aba758b97a4","modified":1739348896463},{"_id":"source/_posts/dubbo-02.md","hash":"2d5581d248ca601ef54c034b219c7c100750bee1","modified":1739348896463},{"_id":"source/_posts/dubbo-03.md","hash":"b1e756cdf2ca8a092a266d0c83987df4768cbb68","modified":1739348896463},{"_id":"source/_posts/dubbo-04.md","hash":"d4e92089860958ca7af72e4cdc1b01cd7890dd6e","modified":1739348896463},{"_id":"source/_posts/git使用笔记.md","hash":"71b5bc0233d83261743a6c2285ab07456b6037b1","modified":1684462570334},{"_id":"source/_posts/dubbo-05.md","hash":"f3f4c8a21060404b0bef9bc6d1b3e449d6871087","modified":1739348896464},{"_id":"source/_posts/hello-world.md","hash":"e39200763824f53a0ffe8148585aec8fb3d03a54","modified":1739348896464},{"_id":"source/_posts/jvm-垃圾回收与内存分配策略.md","hash":"e48977c914f188beaa39f4dc21d5b7fd410844ba","modified":1684462570336},{"_id":"source/_posts/jvm-java内存区域.md","hash":"34208571039a40ad91df99eae78577e1aba9c708","modified":1684462570335},{"_id":"source/_posts/kafka-01.md","hash":"bd698f6891d4405c2a1b0151af101918d0e53b1d","modified":1739348896464},{"_id":"source/_posts/jvm-执行子系统.md","hash":"2de9aa49b317e66bd0cba195ea930634d8c5f99c","modified":1684462570336},{"_id":"source/_posts/maven-01.md","hash":"a5f21a3e90dd3a596287eed7617d2bb9318345b9","modified":1739348896464},{"_id":"source/_posts/rabbitmq-02.md","hash":"f83479269edf9b44b56cad2f9a4425206ac35e20","modified":1739348896464},{"_id":"source/_posts/rabbitmq-01.md","hash":"13ae2e0e3c4b820568d1cff0fd3d7df04e6391dc","modified":1739348896464},{"_id":"source/_posts/rabbitmq-03.md","hash":"2a51b49315c11b85b51215d4b06f2ad3fe74c059","modified":1739348896465},{"_id":"source/_posts/rabbitmq-04.md","hash":"1af6181ac29fdee819b998079b70eed28a7a4712","modified":1739348896465},{"_id":"source/_posts/rabbitmq-05.md","hash":"14232b7eecb78ac92b7137471c7a97dd32268731","modified":1739348896465},{"_id":"source/_posts/rabbitmq-06.md","hash":"a190d05443bcdbbfb32a82b14385f89dfacce8be","modified":1739348896465},{"_id":"source/_posts/redis.md","hash":"942445a36327e44dab98e63e6c4852b5f9c62f76","modified":1739348896465},{"_id":"source/_posts/spring-01.md","hash":"3f47e935cf4e8cbd1b83fa19c1b83df9439049ff","modified":1739348896465},{"_id":"source/_posts/spring-02.md","hash":"4b660a815b52fcda7721607ed08b9dbce35204ef","modified":1739348896465},{"_id":"source/_posts/spring-03.md","hash":"9b49490bad9df1d6675cf16658adcc9e6db4a264","modified":1739348896465},{"_id":"source/_posts/spring-IOC.md","hash":"465f37bf57ef50598eb7721d87b5b74522956189","modified":1739348896465},{"_id":"source/_posts/spring-04.md","hash":"1e9e2af32de4b10f193065ad53c7d718600ba55f","modified":1739348896465},{"_id":"source/_posts/spring-springboot自动配置.md","hash":"0b6b0bdde51f05794378c7c3e0c51911495b3264","modified":1739348896465},{"_id":"source/_posts/spring-设计模式.md","hash":"dac21fa18c14351bc78dca18281f7ad365e9d2a3","modified":1739348896466},{"_id":"source/_posts/zookeeper应用.md","hash":"3ed2cf0cd92a16d7c0e4b5b3c076f8498cd678d5","modified":1739348896466},{"_id":"source/_posts/zookeeper特性.md","hash":"1143902002a0ec59e6c6c86a7c154adb8a3253d9","modified":1739348896466},{"_id":"source/_posts/zookeeper集成java.md","hash":"d853e1a6e52344ece4cbf4b1e2c5454bb5668536","modified":1739348896466},{"_id":"source/_posts/zookeeper集群.md","hash":"e3ce4772860fe39d864ab0140a9cc422524a31fe","modified":1739348896466},{"_id":"source/_posts/分布式事务解决方案.md","hash":"8cf83228583a1cb3f5d19ea0991e0e09625b8cd2","modified":1739348896466},{"_id":"source/_posts/分布式系统.md","hash":"b58a85cf9b29c6ce98f8da164f6956c2d5ebb82b","modified":1739348896466},{"_id":"source/_posts/单例模式.md","hash":"3d7296c60fc4372ff44a2636eec40f823360c418","modified":1739348896466},{"_id":"source/_posts/分布式锁解决方案.md","hash":"e62b77fe45a6234c26a4d305cda6d5b05dfd7ca9","modified":1739348896466},{"_id":"source/_posts/多线程-01.md","hash":"49fd4d6fd996ce0cd8a5d64b7ead92a76e62d742","modified":1739348896466},{"_id":"source/_posts/多线程-02.md","hash":"f3949163e0909ebcd363c97fc4006a6edf12fb80","modified":1739348896466},{"_id":"source/_posts/多线程-CAS.md","hash":"f65247ca43c6e4727ffde721b53ab2bf53a6e6b2","modified":1739348896472},{"_id":"source/_posts/多线程-并发工具类.md","hash":"98693c02080b4ddd34c4403275d525d667ee5cbf","modified":1739348896472},{"_id":"source/_posts/多线程-显式锁和AQS.md","hash":"187fc10d14376a43e04fa12e9e9ae961781bf9c5","modified":1739348896472},{"_id":"source/_posts/多线程-线程安全.md","hash":"3c8d08bb2e1de03f90e06183ad30e4f3cf1c0a97","modified":1739348896472},{"_id":"source/_posts/工厂模式总结.md","hash":"bc12aec6d5650882b232f33a1809925646811940","modified":1739348896472},{"_id":"source/_posts/多线程-线程池.md","hash":"1033eaa5ac5cbfda9438daa764eb084269e9c39c","modified":1739348896472},{"_id":"source/_posts/工厂方法模式.md","hash":"34274cec132fc48cc6d7dd31f86c2e48e49d6e45","modified":1739348896472},{"_id":"source/_posts/建造者模式.md","hash":"c3ba64093adab787a4d2cc2a56945c0f68a23e3a","modified":1739348896472},{"_id":"source/_posts/总结-MQ.md","hash":"bb11713a2896c7d21f9f95f853174636e6b4f0f6","modified":1739348896472},{"_id":"source/_posts/总结-多线程.md","hash":"0ff1a967f2b6ea3e3efd39c6fc3344b941703bab","modified":1739348896472},{"_id":"source/_posts/总结题-mysql.md","hash":"2334af9106be7da0d5d9f4bf1933d11ea64812f9","modified":1739348896473},{"_id":"source/_posts/总结题-分布式.md","hash":"0ec9cc0a9a231e0714d77e3a653d35d6335d8586","modified":1739348896473},{"_id":"source/_posts/总结题-多线程.md","hash":"444a926eb945a26bb2a6521b94cdd0d8465452e0","modified":1739348896473},{"_id":"source/_posts/总结题.md","hash":"3c51a3cb6ba803c6c735d9457dcfa8115b87918a","modified":1739348896473},{"_id":"source/_posts/排序.md","hash":"50c3bab629c45abcb3aee15612bd66c9751d1598","modified":1739348896473},{"_id":"source/_posts/正则表达式.md","hash":"6329317a7650b29da280aa97340b2b3697a73fbe","modified":1739348896473},{"_id":"source/_posts/接口幂等性解决方案.md","hash":"1af54fd4fa52cebb5ff3fc93fb51832a31d1f330","modified":1739348896473},{"_id":"source/_posts/简单工厂模式.md","hash":"e21ad5f69724a7e47cbb4460a37c2091c492fa9c","modified":1739348896473},{"_id":"source/_posts/设计模式-模板方法模式.md","hash":"704b2b6b9e6658e724c51adb08b90970d42a18b9","modified":1684462570359},{"_id":"source/_posts/设计模式-深拷贝浅拷贝及原型模式.md","hash":"6531c74bff55e3eb2a6b046dd0026f3bd1a87766","modified":1684462570360},{"_id":"source/_posts/设计模式原则.md","hash":"9955e2b50b89dd3c9ad409e4d5f14c61182f658f","modified":1739348896473},{"_id":"source/_posts/设计模式-适配器模式.md","hash":"ed2f7512728cfe0276b7aa959c2fd666b4641228","modified":1684462570360},{"_id":"source/_posts/适配器模式.md","hash":"577560291f45ce39aeab86141ed3c5a358e4cab5","modified":1739348896474},{"_id":"source/_posts/通讯协议.md","hash":"88c749b798d34103bf31645381b44588750d66c2","modified":1739348896474},{"_id":"source/assets/default.jpg","hash":"d1622bc20237f95b950c67b33de25051b4588c78","modified":1684462570363},{"_id":"source/photos/index.ejs","hash":"77274cc067bcb846e30b3ec183b30df5144e49db","modified":1684462570364},{"_id":"source/photos/ins.css","hash":"8c20f68a514bb8ff9a04207cf2f7d245710973c9","modified":1739348896474},{"_id":"source/photos/ins.json","hash":"21593d8197264fb79fb2063e9d84c4c37ae8bd70","modified":1739348896474},{"_id":"source/photos/ins.js","hash":"0bf98da091ff2bddbf32fccc87cff8108a1289f6","modified":1739348896474},{"_id":"source/tags/index.md","hash":"86a46f6a14a61ad2c14e3db3a1921564b7e73bcc","modified":1739348896474},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1739348896572},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1739348896572},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1739348896573},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1739348896572},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1739348896573},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1739348896573},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1739348896573},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1684462570590},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1684462570591},{"_id":"themes/yilia/layout/layout.ejs","hash":"63181d95394fd69f8993708d8eceffd360e712ba","modified":1739348896576},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1684462570590},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1684462570599},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1739348896575},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1684462570600},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1684462570651},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1739348896595},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1739348896576},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1739348896588},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1684462570589},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1739348896590},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1739348896594},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"2d7a95aa6b78d97957726e11d403849bf4f7807e","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"0cbd3b9613a52921929b780b88d9dc166bcc42af","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1684462570579},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1739348896573},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1739348896575},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1739348896575},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1684462570638},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1684462570639},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1684462570640},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1739348896589},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1684462570640},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1739348896589},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1684462570649},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1684462570650},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1684462570650},{"_id":"themes/yilia/source/tags/a.html","hash":"96caaa4874bb11a9469ce41ce6c6ae1295ba532b","modified":1739348896595},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1739348896576},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1739348896576},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1739348896576},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1739348896576},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1739348896576},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1739348896576},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1739348896576},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1739348896576},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1739348896576},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1739348896581},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1739348896582},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1684462570623},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1739348896582},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1739348896582},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1739348896583},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1739348896583},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1739348896583},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1739348896583},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1739348896583},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1739348896583},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1739348896583},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1739348896583},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1739348896583},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1739348896583},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1739348896583},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1739348896583},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1739348896584},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1739348896584},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1739348896584},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1739348896584},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1739348896584},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1739348896584},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1739348896584},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1739348896584},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1739348896588},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1739348896588},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1739348896588},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1739348896588},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1739348896588},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1739348896575},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1739348896574},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1739348896574},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1739348896581},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1739348896581},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1739348896581},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1739348896581},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1739348896581},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1684462570621},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1739348896582},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1684462570622},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1684462570622},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1684462570624},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1684462570625},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"a5e9fe67e0604c24279281d9fdd2ce1f4536d3e5","modified":1739348896583},{"_id":"public/photos/lazyload.min.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1684483611493},{"_id":"public/photos/ins.css","hash":"8c20f68a514bb8ff9a04207cf2f7d245710973c9","modified":1684483612040},{"_id":"public/photos/ins.js","hash":"0bf98da091ff2bddbf32fccc87cff8108a1289f6","modified":1684483612108},{"_id":"public/photos/ins.json","hash":"2fac5209f2a2a4b01c7149cedf62fe87d24fc016","modified":1684483612108},{"_id":"public/content.json","hash":"340b2fdef4a18a4af80366fa0da56f06586bd8e1","modified":1684483612108},{"_id":"public/photos/index.html","hash":"07f3b4cad4c7e4b40b9b79bb60b0d09eef13c792","modified":1684483825640},{"_id":"public/tags/index.html","hash":"987b41e999884ea9a76b728f391f71cbfb4dbe23","modified":1684483825640},{"_id":"public/2023/05/19/排序/index.html","hash":"158c50a48a5e53bf5324b517838fea8799473639","modified":1684483825640},{"_id":"public/2023/05/19/总结题-分布式/index.html","hash":"c62f807014cd43153378e57cfaebfc71204dc3e0","modified":1684483825640},{"_id":"public/2023/05/19/总结题-多线程/index.html","hash":"e9fa8c913fbd79e10ce781ca9d46d41d2b35afcf","modified":1684483825640},{"_id":"public/2023/05/19/总结题/index.html","hash":"c17e200f469e4cc89501262ce6bcaf6a856d87ce","modified":1684483825640},{"_id":"public/2023/05/19/总结题-mysql/index.html","hash":"96bd80e593035f657ebd2ec8e315b30d552f91b2","modified":1684483825640},{"_id":"public/2023/05/19/适配器模式/index.html","hash":"5cad2568500d171665b1d4046d2cee88642e1caa","modified":1684483825640},{"_id":"public/2023/05/19/通讯协议/index.html","hash":"f00afe3440abbc9a4d787b918f16a96217bb727e","modified":1684483825640},{"_id":"public/2023/05/19/设计模式原则/index.html","hash":"444d1c711b178843d8a3c4ec3281f2c42e9879ec","modified":1684483825640},{"_id":"public/2023/05/19/设计模式-适配器模式/index.html","hash":"8682b4b90a03976773089c07082cc83a48dc9621","modified":1684483825640},{"_id":"public/2023/05/19/简单工厂模式/index.html","hash":"f092dbf6059db897f1406118cc7eac8e0240d88a","modified":1684483825641},{"_id":"public/2023/05/19/设计模式-模板方法模式/index.html","hash":"0b48c4435f20868756ac9b185862b4d49cfe2bc9","modified":1684483825640},{"_id":"public/2023/05/19/设计模式-深拷贝浅拷贝及原型模式/index.html","hash":"4852beb2fdbc31f63ad62ab2436dbdae08991f86","modified":1684483825641},{"_id":"public/2023/05/19/正则表达式/index.html","hash":"2c281f92569dc09014ccfb290208cf1f8e374826","modified":1684483825641},{"_id":"public/2023/05/19/接口幂等性解决方案/index.html","hash":"6a81e79c280938e95bd7b188cf86f7fac852afe5","modified":1684483825641},{"_id":"public/2023/05/19/总结-MQ/index.html","hash":"fdfc3be2a8543f9a64197a3ea81e10fdc266cd19","modified":1684483825641},{"_id":"public/2023/05/19/建造者模式/index.html","hash":"26c8d6f5df238f9a536d685e7be1e86e3234b52d","modified":1684483825641},{"_id":"public/2023/05/19/总结-多线程/index.html","hash":"4ed36a2135c3ab537e26343abdd385e51d996f27","modified":1684483825641},{"_id":"public/2023/05/19/工厂模式总结/index.html","hash":"e6b27270c6089ad119266503de7abaf3325b796b","modified":1684483825641},{"_id":"public/2023/05/19/工厂方法模式/index.html","hash":"500f750fb5500233d852bf490fa98afa6b6f8243","modified":1684483825641},{"_id":"public/2023/05/19/多线程-线程安全/index.html","hash":"cd4b139d27b3bfdb3be09622ffe7ac4a5f6b2306","modified":1684483825641},{"_id":"public/2023/05/19/多线程-线程池/index.html","hash":"85401fcd8df7ea1aa4030c5cd4947ec6d90c38ed","modified":1684483825641},{"_id":"public/2023/05/19/多线程-CAS/index.html","hash":"ba5fc5ed2e642eb95158b9d2a96c9625d4825586","modified":1684483825641},{"_id":"public/2023/05/19/多线程-并发工具类/index.html","hash":"be4650f06a9d0b3f2a0c1341144e6846e1eaddfe","modified":1684483825641},{"_id":"public/2023/05/19/多线程-显式锁和AQS/index.html","hash":"498b54f169fa0e9f2d3ace366338c6439cf5c418","modified":1684483825641},{"_id":"public/2023/05/19/多线程-02/index.html","hash":"85fb7c64eb9a2eea69ef08c5d4177cb1098b3053","modified":1684483825641},{"_id":"public/2023/05/19/多线程-01/index.html","hash":"2b1645dced98ed3c3a4eee9bfa39063d812db60d","modified":1684483825641},{"_id":"public/2023/05/19/分布式系统/index.html","hash":"650ec2ad7d7c0b683d20d25814a39200907a1ae8","modified":1684483825641},{"_id":"public/2023/05/19/单例模式/index.html","hash":"2380b6f917cd58d8a7b828e9b9fd9d51c2d2936f","modified":1684483825641},{"_id":"public/2023/05/19/分布式锁解决方案/index.html","hash":"0ab8ed5f6bf6134d5636ad75a21fca70251b021a","modified":1684483825641},{"_id":"public/2023/05/19/zookeeper集成java/index.html","hash":"25b7f995d7b5beb8b7e4d23168525a3b25fe0dd5","modified":1684483825641},{"_id":"public/2023/05/19/分布式事务解决方案/index.html","hash":"e5c442dc519684586b01eb49436010b7dd62d92f","modified":1684483825642},{"_id":"public/2023/05/19/zookeeper集群/index.html","hash":"7282254752002cf2fc5a9fc046c6410f172be121","modified":1684483825641},{"_id":"public/2023/05/19/zookeeper应用/index.html","hash":"371600b3cd1bd52976b6b571c7808be109ec6b73","modified":1684483825642},{"_id":"public/2023/05/19/zookeeper特性/index.html","hash":"94c8baf780d35ce2344179aa04eb7116e0c86e9d","modified":1684483825642},{"_id":"public/2023/05/19/spring-设计模式/index.html","hash":"e14c1fa12a32416e6afdb4f473b52736869ed4e9","modified":1684483825642},{"_id":"public/2023/05/19/spring-springboot自动配置/index.html","hash":"16d58105596547cbe2bec4be1fd38e432d1d62e5","modified":1684483825642},{"_id":"public/2023/05/19/spring-IOC/index.html","hash":"d70e6d9403aa68d5873ae224f327813b7a1859a7","modified":1684483825642},{"_id":"public/2023/05/19/spring-04/index.html","hash":"db01b5ea92fc3b946df98b29aab8af8217b170ac","modified":1684483825642},{"_id":"public/2023/05/19/spring-01/index.html","hash":"ee8364014dd89a465c171d58e32b69a34c9c9aa8","modified":1684483825642},{"_id":"public/2023/05/19/spring-03/index.html","hash":"22bc443fc976ad47f4ae9038586705f4b1053d5c","modified":1684483825642},{"_id":"public/2023/05/19/spring-02/index.html","hash":"9747d54456d943c883f70fd34bcf498910c0dc8b","modified":1684483825642},{"_id":"public/2023/05/19/rabbitmq-06/index.html","hash":"94ba1fef61d83615eab91844b1f531915451b5ba","modified":1684483825642},{"_id":"public/2023/05/19/redis/index.html","hash":"15f00262221ac7e0805e35a6939d3cc7b40339f8","modified":1684483825642},{"_id":"public/2023/05/19/rabbitmq-03/index.html","hash":"ddec95fe7c3bfbaea5b933cec682fcc0a486cf9f","modified":1684483825642},{"_id":"public/2023/05/19/rabbitmq-04/index.html","hash":"03ed558bbff0f542ab74b4f04fd51690c7f9e80d","modified":1684483825642},{"_id":"public/2023/05/19/rabbitmq-05/index.html","hash":"b8af29432b6d1a2b10ddbd4c53ee62204649b952","modified":1684483825642},{"_id":"public/2023/05/19/rabbitmq-01/index.html","hash":"661de920325c7d40adbc694149e0c2e15e7de016","modified":1684483825642},{"_id":"public/2023/05/19/rabbitmq-02/index.html","hash":"dc038ddfd00a53f19a44e846f4d352fe2b786f95","modified":1684483825642},{"_id":"public/2023/05/19/mybatis_01/index.html","hash":"4b5ce8c152bd865e70fed77f2cb7bb10ce4ff7db","modified":1684483825642},{"_id":"public/2023/05/19/maven-01/index.html","hash":"d11d4153d3f66ba0fd4411be67edf3db7bee9e4f","modified":1684483825642},{"_id":"public/2023/05/19/kafka-01/index.html","hash":"d4c540de3c6fa6ccc6b7855313ecb9ccf9a8fc5a","modified":1684483825642},{"_id":"public/2023/05/19/jvm-执行子系统/index.html","hash":"2954302c282f222e126805eccd27c5a9cfdc80c9","modified":1684483825642},{"_id":"public/2023/05/19/jvm-java内存区域/index.html","hash":"dadc8a6e9d8f6fb28d05d8dee93cde62664677d6","modified":1684483825642},{"_id":"public/2023/05/19/jvm-垃圾回收与内存分配策略/index.html","hash":"2e4e322ae4555f448d403d7ef7d6388aa0c23438","modified":1684483825642},{"_id":"public/2023/05/19/git使用笔记/index.html","hash":"7e06be6780cad1ccc9f6d19ad96bb46269ff9a37","modified":1684483825642},{"_id":"public/2023/05/19/hello-world/index.html","hash":"d6d6c0a50070e350578d9729a5469faec89afd0e","modified":1684483825642},{"_id":"public/2023/05/19/dubbo-04/index.html","hash":"62035c4f00663cffdc48786a39beaecd17c9e17a","modified":1684483825642},{"_id":"public/2023/05/19/dubbo-05/index.html","hash":"05211fcf21a5af638b03cf3fcd079a6821cd135c","modified":1684483825643},{"_id":"public/2023/05/19/dubbo-02/index.html","hash":"9f1f307946b1f993bebd6e7b936aca345916d2ee","modified":1684483825643},{"_id":"public/2023/05/19/dubbo-03/index.html","hash":"422b1778e3779ffb87e590650046661f1acc853c","modified":1684483825643},{"_id":"public/2023/05/19/Nginx高可用keepalived/index.html","hash":"3aadc2c63cf5eb43a8ad02e6a39373f4aad72524","modified":1684483825643},{"_id":"public/2023/05/19/dubbo-01/index.html","hash":"549e7dbe62746ca00c435169d2f7d69748dd5287","modified":1684483825643},{"_id":"public/2023/05/19/docker-基础/index.html","hash":"090253518043bc39a58ceb7238c0bb2c13770b69","modified":1684483825643},{"_id":"public/2023/05/19/Nginx简介/index.html","hash":"ae87a4fe694383ea657b0cde5bd794bbfcf26d39","modified":1684483825643},{"_id":"public/2023/05/19/Nginx跨域/index.html","hash":"bbb033a85d38fc454789161b60da4fe4f9cc2aad","modified":1684483825643},{"_id":"public/2023/05/19/Nginx-location-rewrite/index.html","hash":"99f1c06fc901a076f64391755447adc0ff9d876f","modified":1684483825643},{"_id":"public/2023/05/19/Mysql-锁和事务/index.html","hash":"6046404d597e2c54c0a235b61635c584d369bfee","modified":1684483825643},{"_id":"public/2023/05/19/Nginx-Location匹配规则/index.html","hash":"e3644d5ec27349db1305e35867d00da0fb167ca6","modified":1684483825643},{"_id":"public/2023/05/19/Mysql-逻辑架构和存储引擎/index.html","hash":"5227e8bb624ca6cea80fbde88fef53427eac58e7","modified":1684483825643},{"_id":"public/2023/05/19/Mysql-慢查询和执行计划/index.html","hash":"c6d1392a04dbfb0431f19f065402afd71381f1f1","modified":1684483825643},{"_id":"public/2023/05/19/Mysql-sql优化/index.html","hash":"9b2fc8d7005cbaf0f6c5a98ad2fe4d5c2ba77c2b","modified":1684483825643},{"_id":"public/2023/05/19/Mysql-业务设计/index.html","hash":"7ef49b7027c115fdf669fe509f91ac400bae8c9e","modified":1684483825643},{"_id":"public/categories/hexo/index.html","hash":"fbd53fa0dafa65b6414b99e2ab4c5bca80529f0c","modified":1684483612119},{"_id":"public/archives/index.html","hash":"f23d39a5e45af92decae433dda44df855d094636","modified":1684483612119},{"_id":"public/archives/page/2/index.html","hash":"8156080008c0528c1dca4a71f2b187b22798e4e8","modified":1684483612120},{"_id":"public/archives/page/4/index.html","hash":"315ae6b435d507a9bb95b601acf825eb30d7dffe","modified":1684483612120},{"_id":"public/archives/page/3/index.html","hash":"df90f404c4f62094c4a1f5a3c5281b12d65de221","modified":1684483612120},{"_id":"public/archives/page/6/index.html","hash":"046dca209486f044cd5ac62910cb8c9bb032a441","modified":1684483612120},{"_id":"public/archives/page/5/index.html","hash":"50ee03e703cfd11efeae5f78cb2ff012898bfb3b","modified":1684483612120},{"_id":"public/archives/page/7/index.html","hash":"a039982f671538393a8ba701630544ad707203fa","modified":1684483612120},{"_id":"public/archives/page/8/index.html","hash":"8bf2c4309a84c3f940b9facd263a438443778f17","modified":1684483612120},{"_id":"public/archives/2023/index.html","hash":"a970da92a2f47e3bb052cfa1340df367a4a4fb8c","modified":1684483612120},{"_id":"public/archives/2023/page/3/index.html","hash":"ef2bc4a7533f81a5363d1d22a12943445dd38823","modified":1684483612120},{"_id":"public/archives/2023/page/2/index.html","hash":"dc9856932ce464564c1ce55f35507a64af5ce542","modified":1684483612120},{"_id":"public/archives/2023/page/4/index.html","hash":"4e786a479e1e5a136661a0aaa0c3f9976c9b45bb","modified":1684483612120},{"_id":"public/archives/2023/page/5/index.html","hash":"2525d149ff719ecaca4671fe369d5145619a1584","modified":1684483612120},{"_id":"public/archives/2023/page/6/index.html","hash":"6b4e535995c54d6e118b6402f1ccb7bcbb7365ce","modified":1684483612120},{"_id":"public/archives/2023/page/8/index.html","hash":"ea300430f6f9401838f76b1b41adb8b27c32cc84","modified":1684483612120},{"_id":"public/archives/2023/page/7/index.html","hash":"553148b9f964d46732fc8fddfd2259f648c2f244","modified":1684483612120},{"_id":"public/archives/2023/05/index.html","hash":"af934d2d46dc89ecc169f7a15a86a76d19778529","modified":1684483612120},{"_id":"public/archives/2023/05/page/2/index.html","hash":"6f9c8c89e352f22a45cfade95aabfc402df34e39","modified":1684483612120},{"_id":"public/archives/2023/05/page/3/index.html","hash":"4c88def46bb455b1e5ccc44f8ce355a83ee42eaa","modified":1684483612120},{"_id":"public/archives/2023/05/page/4/index.html","hash":"19acd3d7ddab22d726003c8875cb03a8cbec912c","modified":1684483612120},{"_id":"public/archives/2023/05/page/6/index.html","hash":"e73dfd185108f1bc8eea08a7c021e65f8ff0e20b","modified":1684483612120},{"_id":"public/archives/2023/05/page/5/index.html","hash":"8f7be29fad11ef2f94128653b9a8d1b12a0eaebf","modified":1684483612120},{"_id":"public/archives/2023/05/page/7/index.html","hash":"91b7209f6a1c542a26198ebc7fde7ef34a77fa53","modified":1684483612120},{"_id":"public/archives/2023/05/page/8/index.html","hash":"cc2555a5a022fe5ece4c805b23c89ebae29aaf44","modified":1684483612120},{"_id":"public/index.html","hash":"026a202e866ec4693d8bb1c4d2108879a3af9a67","modified":1684483825643},{"_id":"public/page/2/index.html","hash":"d3e8ec53f9c880e795720323adf322145f2da868","modified":1684483681671},{"_id":"public/page/4/index.html","hash":"ceb7a2558052934429d5c07c766d09f7ad77367b","modified":1684483681671},{"_id":"public/page/3/index.html","hash":"ba27e8281739a6e977b4dc434d452d6ba6a27301","modified":1684483681671},{"_id":"public/page/5/index.html","hash":"64d04dd1034ccb31ec5de1865533e2ea6a950406","modified":1684483681671},{"_id":"public/page/6/index.html","hash":"6049b31e9d7506d8edf9593ff7ad6ec70957cb52","modified":1684483681671},{"_id":"public/page/8/index.html","hash":"116dd2e0a123c4163d5635e3d08cf59782b460bf","modified":1684483681672},{"_id":"public/page/7/index.html","hash":"763dcaca5e572917508dfe798829080945ce72bc","modified":1684483681672},{"_id":"public/page/9/index.html","hash":"aee0602989191ae8444dbca77cb46c65a302e403","modified":1684483681672},{"_id":"public/page/10/index.html","hash":"4d5cf4af3c7ee5dbe6ec3bcb82660ae97e5a71a6","modified":1684483681672},{"_id":"public/page/12/index.html","hash":"e660ae492bf1284e2a4ae5626f1e7de076055a8c","modified":1684483681672},{"_id":"public/page/11/index.html","hash":"989464203417f9565acb6d218feaff73941ff81b","modified":1684483681672},{"_id":"public/page/13/index.html","hash":"2334a0fd7dff27b797405c1752ff454ea6bbfb38","modified":1684483681672},{"_id":"public/page/14/index.html","hash":"ca30fa0d63e288a8db9c47ec0b6ac9d16f6f7f7f","modified":1684483681672},{"_id":"public/tags/Mysql/index.html","hash":"e7b8cb5c1a4a95bd39658f46761b7b037730a84b","modified":1684483612121},{"_id":"public/page/15/index.html","hash":"c2eaafb597581e9f951783b5e8804c0c3a79872c","modified":1684483612121},{"_id":"public/tags/Nginx/index.html","hash":"c7049ce4fcdf236e7247a4eea8888b0512edca96","modified":1684483612121},{"_id":"public/tags/docker/index.html","hash":"9e805a0ce00ec2d2a620dc198c74bdb291c75e12","modified":1684483612121},{"_id":"public/tags/Git/index.html","hash":"ab57bd60ecd27f52020d738c92c14aef5a68668e","modified":1684483612121},{"_id":"public/tags/Dubbo/index.html","hash":"f41e487d2479846f816792b86482230e85492e02","modified":1684483612121},{"_id":"public/tags/hexo/index.html","hash":"d32f44e6aaf8ebceaa51b1166f87f6def5b5b1a5","modified":1684483612121},{"_id":"public/tags/JVM/index.html","hash":"d705430aead45f43a8e7e5392263481cd7dd7e7b","modified":1684483612121},{"_id":"public/tags/Zookeeper/index.html","hash":"913af739e54527f1bc3f1d519b4459e127b75292","modified":1684483612121},{"_id":"public/tags/Kafka/index.html","hash":"476d75bb07318b50cea870dc0069d1d19463b715","modified":1684483612122},{"_id":"public/tags/RabbitMq/index.html","hash":"472b55d917b540d71c082ce4912fd6d0e343874e","modified":1684483612122},{"_id":"public/tags/Java/index.html","hash":"77607f18684315642f74b66adefa583a8327579a","modified":1684483612122},{"_id":"public/tags/Maven/index.html","hash":"ef5d3457d0da712a18e67110e9df3ff682d73f32","modified":1684483612122},{"_id":"public/tags/Spring/index.html","hash":"7cf5762c71e51dbd11993687233bbf5e2806214b","modified":1684483612122},{"_id":"public/tags/redis/index.html","hash":"22ae4f9f4e49df5dc4eb99a0e2f30ea6576d74c9","modified":1684483612122},{"_id":"public/tags/SpringBoot/index.html","hash":"c6f7e49073f15bc9746c4b3cd896ca762bf8d3eb","modified":1684483612122},{"_id":"public/tags/zookeeper/index.html","hash":"7318ea77bb62cda927128b7ad8a34ccc9ce0d0e8","modified":1684483612122},{"_id":"public/tags/分布式事务/index.html","hash":"d5c372e39fc48a75eea3c5890ec1c26f8e78ba72","modified":1684483612122},{"_id":"public/tags/解决方案/index.html","hash":"94d319d89aebe3039877451fc7d7abd78de6eab7","modified":1684483612122},{"_id":"public/tags/分布式/index.html","hash":"60ed54012079793f84bc24f162c035a2e7876146","modified":1684483612122},{"_id":"public/tags/设计模式/index.html","hash":"a860bd69fbfafc239ec0a93226a2c203a12f82cd","modified":1684483612122},{"_id":"public/tags/分布式锁/index.html","hash":"fe96efbce14b84f33bae09b9ccc9f113ae129d31","modified":1684483612122},{"_id":"public/tags/并发编程/index.html","hash":"100e537597022f4dc5057d0cdd2e024698d8168f","modified":1684483612122},{"_id":"public/tags/总结/index.html","hash":"91f094a4aa113bd56334d2c42f7d7261cab910de","modified":1684483612122},{"_id":"public/tags/算法/index.html","hash":"f3e200161a158e3b8f058711daec155836738969","modified":1684483612122},{"_id":"public/tags/排序/index.html","hash":"db01159468ede066e1941d2166cab8a4f003542d","modified":1684483612122},{"_id":"public/tags/正则表达式/index.html","hash":"584fe7f1d7367da66c33afa28bde9d29fd470e55","modified":1684483612122},{"_id":"public/tags/模板方法模式/index.html","hash":"6484af6d5982cab438bf80671112a9294fbffb11","modified":1684483612122},{"_id":"public/tags/接口幂等性/index.html","hash":"336fca15497d546b4305a800d1e6df9ffb42e0fa","modified":1684483612122},{"_id":"public/tags/适配器模式/index.html","hash":"a230c7ec7fa2bfa653371f60a2aa3dc8b3c56178","modified":1684483612122},{"_id":"public/tags/java基础/index.html","hash":"656fdeb1132e81e9cb9384373304365109ee318f","modified":1684483612122},{"_id":"public/tags/通讯协议/index.html","hash":"4e651d7d31df9fa721a2767fd2b5c7c33cb8c051","modified":1684483612122},{"_id":"source/_posts/RPC.md","hash":"497f89fbd835af41e4aa1dfea167a38c42e85e15","modified":1739348896463}],"Category":[{"name":"hexo","_id":"clhua15an00199gj75zgroyn3"}],"Data":[],"Page":[{"_content":"","source":"photos/lazyload.min.js","raw":"","date":"2023-05-19T02:16:10.365Z","updated":"2023-05-19T02:16:10.365Z","path":"photos/lazyload.min.js","layout":"false","title":"","comments":1,"_id":"clhua159s00019gj7c7p4ngwr","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0;\n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 14px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}","source":"photos/ins.css","raw":"#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0;\n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 14px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}","date":"2025-02-12T08:28:16.474Z","updated":"2025-02-12T08:28:16.474Z","path":"photos/ins.css","layout":"false","_id":"clhua159v00039gj7i6be9opx","title":"","comments":1,"content":"#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0;\n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 14px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}","site":{"data":{}},"excerpt":"","more":"#post-instagram{\n\tpadding: 30px;\n}\n#post-instagram .article-entry{\n\tpadding-right: 0;\n}\n.instagram{\n\tposition: relative;\n\tmin-height: 500px;\n}\n.instagram img {\n\twidth: 100%;\n}\n.instagram .year {\n\tfont-size: 16px;\n}\n.instagram .open-ins{\n\tpadding: 10px 0;\n\tcolor: #cdcdcd;\n}\n.instagram .open-ins:hover{\n\tcolor: #657b83;\n}\n.instagram .year{\n\tdisplay: inline;\n}\n.instagram .thumb {\n\twidth: 25%;\n\theight: 0;\n\tpadding-bottom: 25%;\n\tposition: relative;\n\tdisplay: inline-block;\n\ttext-align: center;\n\tbackground: #ededed;\n}\n.instagram .thumb a {\n\tposition: relative;\n}\n.instagram .album h1 em{\n\tfont-style: normal;\n\tfont-size: 14px;\n\tmargin-left: 10px;\n}\n.instagram .album ul{\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tclear: both;\n\twidth: 100%;\n\ttext-align: left;\n}\n.instagram .album li{\n\tlist-style: none;\n\tdisplay: inline-block;\n\tbox-sizing: border-box;\n\tpadding: 0 5px;\n\tmargin-bottom: -10px;\n\theight: 0;\n\twidth: 25%;\n\tposition: relative;\n\tpadding-bottom: 25%;\n}\n.instagram .album li:before{\n\tdisplay: none;\n}\n.instagram .album div.img-box{\n\tposition: absolute;\n\twidth: 90%;\n\theight: 90%;\n\t-webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\t-moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n\tbox-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1);\n}\n.instagram .album div.img-box img{\n\twidth: 100%;\n\theight: 100%;\n    position: absolute;\n    z-index: 2;\n}\n.instagram .album div.img-box .img-bg{\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tbottom: 0px;\n\twidth: 100%;\n\tmargin: -5px;\n\tpadding: 5px;\n\t-webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\tbox-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1);\n\t-webkit-transition: all 0.15s ease-out 0.1s;\n\t-moz-transition: all 0.15s ease-out 0.1s;\n\t-o-transition: all 0.15s ease-out 0.1s;\n\ttransition: all 0.15s ease-out 0.1s;\n\topacity: 0.2;\n\tcursor: pointer;\n\tdisplay: block;\n\tz-index: 3;\n}\n.instagram .album div.img-box .icon {\n    font-size: 14px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -7px;\n    margin-top: -7px;\n    color: #999;\n    z-index: 1;\n}\n.instagram .album div.img-box .img-bg:hover{\n\topacity: 0;\n}\n.photos-btn-wrap {\n\tborder-bottom: 1px solid #e5e5e5;\n\tmargin-bottom: 20px;\n}\n.photos-btn {\n\tfont-size: 16px;\n\tcolor: #333;\n\tmargin-bottom: -4px;\n\tpadding: 5px 8px 3px;\n}\n.photos-btn.active {\n\tcolor: #08c;\n\tborder: 1px solid #e5e5e5;\n\tborder-bottom: 5px solid #fff;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}"},{"layout":"post","slug":"photos","title":"相册","noDate":"true","comments":0,"_content":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"javascript:void(0)\">photo</a>\n\t<!-- <a class=\"photos-btn\" target=\"_blank\" href=\"http://litten.me/gallery/\">摄影</a> -->\n\n\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://www.instagram.com/litten225/\" target=\"_blank\" class=\"open-ins\">Waiting…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n","source":"photos/index.ejs","raw":"---\nlayout: post\nslug: \"photos\"\ntitle: \"相册\"\nnoDate: \"true\"\ncomments: \"false\"\n---\n<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"javascript:void(0)\">photo</a>\n\t<!-- <a class=\"photos-btn\" target=\"_blank\" href=\"http://litten.me/gallery/\">摄影</a> -->\n\n\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://www.instagram.com/litten225/\" target=\"_blank\" class=\"open-ins\">Waiting…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n","date":"2023-05-19T02:16:10.364Z","updated":"2023-05-19T02:16:10.364Z","path":"photos/index.html","_id":"clhua159z00069gj7jjjitqu9","content":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"javascript:void(0)\" target=\"_blank\" rel=\"noopener\">photo</a>\n\t<!-- <a class=\"photos-btn\" target=\"_blank\" href=\"http://litten.me/gallery/\">摄影</a> -->\n\n\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://www.instagram.com/litten225/\" target=\"_blank\" class=\"open-ins\">Waiting…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n","site":{"data":{}},"excerpt":"","more":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<div class=\"photos-btn-wrap\">\n\t<a class=\"photos-btn active\" href=\"javascript:void(0)\" target=\"_blank\" rel=\"noopener\">photo</a>\n\t<!-- <a class=\"photos-btn\" target=\"_blank\" href=\"http://litten.me/gallery/\">摄影</a> -->\n\n\n</div>\n<div class=\"instagram itemscope\">\n\t<a href=\"https://www.instagram.com/litten225/\" target=\"_blank\" class=\"open-ins\">Waiting…</a>\n</div>\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n"},{"_content":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://image.tupelo.top/ins/' + data.link[i] + '.jpg';\n          var src = 'https://image.tupelo.top/ins/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '.jpg';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"640x640\" data-type=\"' + type + '\" data-target=\"' + target + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"https://image.tupelo.top/ins/default.jpg\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);","source":"photos/ins.js","raw":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://image.tupelo.top/ins/' + data.link[i] + '.jpg';\n          var src = 'https://image.tupelo.top/ins/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '.jpg';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"640x640\" data-type=\"' + type + '\" data-target=\"' + target + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"https://image.tupelo.top/ins/default.jpg\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);","date":"2025-02-12T08:28:16.474Z","updated":"2025-02-12T08:28:16.474Z","path":"photos/ins.js","layout":"false","_id":"clhua15a100089gj7597tewf3","title":"","comments":1,"content":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://image.tupelo.top/ins/' + data.link[i] + '.jpg';\n          var src = 'https://image.tupelo.top/ins/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '.jpg';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"640x640\" data-type=\"' + type + '\" data-target=\"' + target + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"https://image.tupelo.top/ins/default.jpg\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);","site":{"data":{}},"excerpt":"","more":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n    /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n        /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n/************************************************************************/\n/******/\n([\n  /* 0 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    'use strict';\n\n    __webpack_require__(1);\n\n    var _view = __webpack_require__(2);\n\n    var _view2 = _interopRequireDefault(_view);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    /**\n     * @name impush-client \n     * @description 这个项目让我发家致富…\n     * @date 2016-12-1\n     */\n\n    var _collection = [];\n    var _count = 0;\n    var searchData;\n\n    function addMask(elem) {\n      var rect = elem.getBoundingClientRect();\n      var style = getComputedStyle(elem, null);\n\n      var mask = document.createElement('i');\n      mask.className = 'icon-film';\n      mask.style.color = '#fff';\n      mask.style.fontSize = '26px';\n      mask.style.position = 'absolute';\n      mask.style.right = '10px';\n      mask.style.bottom = '10px';\n      mask.style.zIndex = 1;\n      elem.parentNode.appendChild(mask);\n    }\n\n    var createVideoIncon = function createVideoIncon() {\n      var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n      for (var i = 0, len = $videoImg.length; i < len; i++) {\n        addMask($videoImg[i]);\n      }\n    };\n    var render = function render(res) {\n      var ulTmpl = \"\";\n      for (var j = 0, len2 = res.list.length; j < len2; j++) {\n        var data = res.list[j].arr;\n        var liTmpl = \"\";\n        for (var i = 0, len = data.link.length; i < len; i++) {\n          var minSrc = 'https://image.tupelo.top/ins/' + data.link[i] + '.jpg';\n          var src = 'https://image.tupelo.top/ins/' + data.link[i];\n          var type = data.type[i];\n          var target = src + (type === 'video' ? '.mp4' : '.jpg');\n          src += '.jpg';\n\n          liTmpl += '<figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"640x640\" data-type=\"' + type + '\" data-target=\"' + target + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"https://image.tupelo.top/ins/default.jpg\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n        }\n        ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\">' + liTmpl + '</ul>\\\n        </section>';\n      }\n      document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n      createVideoIncon();\n      _view2.default.init();\n    };\n\n    var replacer = function replacer(str) {\n      var arr = str.split(\"/\");\n      return \"/assets/ins/\" + arr[arr.length - 1];\n    };\n\n    var ctrler = function ctrler(data) {\n      var imgObj = {};\n      for (var i = 0, len = data.length; i < len; i++) {\n        var y = data[i].y;\n        var m = data[i].m;\n        var src = replacer(data[i].src);\n        var text = data[i].text;\n        var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n        if (imgObj[key]) {\n          imgObj[key].srclist.push(src);\n          imgObj[key].text.push(text);\n        } else {\n          imgObj[key] = {\n            year: y,\n            month: m,\n            srclist: [src],\n            text: [text]\n          };\n        }\n      }\n      render(imgObj);\n    };\n\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n\n    Ins.init();\n\n    // export default impush;\n\n    /***/\n  },\n  /* 1 */\n  /***/\n  function(module, exports, __webpack_require__) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      'use strict';\n\n      var inViewport = __webpack_require__(3);\n      var lazyAttrs = ['data-src'];\n\n      global.lzld = lazyload();\n\n      // Provide libs using getAttribute early to get the good src\n      // and not the fake data-src\n      replaceGetAttribute('Image');\n      replaceGetAttribute('IFrame');\n\n      function registerLazyAttr(attr) {\n        if (indexOf.call(lazyAttrs, attr) === -1) {\n          lazyAttrs.push(attr);\n        }\n      }\n\n      function lazyload(opts) {\n        opts = merge({\n          'offset': 333,\n          'src': 'data-src',\n          'container': false\n        }, opts || {});\n\n        if (typeof opts.src === 'string') {\n          registerLazyAttr(opts.src);\n        }\n\n        var elts = [];\n\n        function show(elt) {\n          var src = findRealSrc(elt);\n\n          if (src) {\n            elt.src = src;\n          }\n\n          elt.setAttribute('data-lzled', true);\n          elts[indexOf.call(elts, elt)] = null;\n        }\n\n        function findRealSrc(elt) {\n          if (typeof opts.src === 'function') {\n            return opts.src(elt);\n          }\n\n          return elt.getAttribute(opts.src);\n        }\n\n        function register(elt) {\n          elt.onload = null;\n          elt.removeAttribute('onload');\n          elt.onerror = null;\n          elt.removeAttribute('onerror');\n\n          if (indexOf.call(elts, elt) === -1) {\n            inViewport(elt, opts, show);\n          }\n        }\n\n        return register;\n      }\n\n      function replaceGetAttribute(elementName) {\n        var fullname = 'HTML' + elementName + 'Element';\n        if (fullname in global === false) {\n          return;\n        }\n\n        var original = global[fullname].prototype.getAttribute;\n        global[fullname].prototype.getAttribute = function(name) {\n          if (name === 'src') {\n            var realSrc;\n            for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n              realSrc = original.call(this, lazyAttrs[i]);\n              if (realSrc) {\n                break;\n              }\n            }\n\n            return realSrc || original.call(this, name);\n          }\n\n          // our own lazyloader will go through theses lines\n          // because we use getAttribute(opts.src)\n          return original.call(this, name);\n        };\n      }\n\n      function merge(defaults, opts) {\n        for (var name in defaults) {\n          if (opts[name] === undefined) {\n            opts[name] = defaults[name];\n          }\n        }\n\n        return opts;\n      }\n\n      // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n      function indexOf(value) {\n        for (var i = this.length; i-- && this[i] !== value;) {}\n        return i;\n      }\n\n      module.exports = lazyload;\n\n      // export default impush;\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  },\n  /* 2 */\n  /***/\n  function(module, exports) {\n\n    'use strict';\n\n    var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n      // parse slide data (url, title, size ...) from DOM elements \n      // (children of gallerySelector)\n      var parseThumbnailElements = function parseThumbnailElements(el) {\n        el = el.parentNode.parentNode;\n        var thumbElements = el.getElementsByClassName('thumb'),\n          numNodes = thumbElements.length,\n          items = [],\n          figureEl,\n          linkEl,\n          size,\n          type,\n          // video or not\n          target,\n          item;\n\n        for (var i = 0; i < numNodes; i++) {\n\n          figureEl = thumbElements[i]; // \n\n          // include only element nodes \n          if (figureEl.nodeType !== 1) {\n            continue;\n          }\n\n          linkEl = figureEl.children[0]; // \n\n          size = linkEl.getAttribute('data-size').split('x');\n          type = linkEl.getAttribute('data-type');\n          target = linkEl.getAttribute('data-target');\n          // create slide object\n          item = {\n            src: linkEl.getAttribute('href'),\n            w: parseInt(size[0], 10),\n            h: parseInt(size[1], 10)\n          };\n\n          if (figureEl.children.length > 1) {\n            item.title = figureEl.children[1].innerHTML;\n          }\n\n          if (linkEl.children.length > 0) {\n            item.msrc = linkEl.children[0].getAttribute('src');\n            item.type = type;\n            item.target = target;\n            item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n            if (type === 'video') {\n              //item.src = null;\n            }\n          }\n\n          item.el = figureEl; // save link to element for getThumbBoundsFn\n          items.push(item);\n        }\n\n        return items;\n      };\n\n      // find nearest parent element\n      var closest = function closest(el, fn) {\n        return el && (fn(el) ? el : closest(el.parentNode, fn));\n      };\n\n      // triggers when user clicks on thumbnail\n      var onThumbnailsClick = function onThumbnailsClick(e) {\n        e = e || window.event;\n        e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n        var eTarget = e.target || e.srcElement;\n\n        // find root element of slide\n        var clickedListItem = closest(eTarget, function(el) {\n          return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n        });\n\n        if (!clickedListItem) {\n          return;\n        }\n\n        // find index of clicked item by looping through all child nodes\n        // alternatively, you may define index via data- attribute\n        var clickedGallery = clickedListItem.parentNode,\n\n          // childNodes = clickedListItem.parentNode.childNodes,\n          // numChildNodes = childNodes.length,\n          childNodes = document.getElementsByClassName('thumb'),\n          numChildNodes = childNodes.length,\n          nodeIndex = 0,\n          index;\n\n        for (var i = 0; i < numChildNodes; i++) {\n          if (childNodes[i].nodeType !== 1) {\n            continue;\n          }\n\n          if (childNodes[i] === clickedListItem) {\n            index = nodeIndex;\n            break;\n          }\n          nodeIndex++;\n        }\n\n        if (index >= 0) {\n          // open PhotoSwipe if valid index found\n          openPhotoSwipe(index, clickedGallery);\n        }\n        return false;\n      };\n\n      // parse picture index and gallery index from URL (#&pid=1&gid=2)\n      var photoswipeParseHash = function photoswipeParseHash() {\n        var hash = window.location.hash.substring(1),\n          params = {};\n\n        if (hash.length < 5) {\n          return params;\n        }\n\n        var vars = hash.split('&');\n        for (var i = 0; i < vars.length; i++) {\n          if (!vars[i]) {\n            continue;\n          }\n          var pair = vars[i].split('=');\n          if (pair.length < 2) {\n            continue;\n          }\n          params[pair[0]] = pair[1];\n        }\n\n        if (params.gid) {\n          params.gid = parseInt(params.gid, 10);\n        }\n\n        return params;\n      };\n\n      var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n        var pswpElement = document.querySelectorAll('.pswp')[0],\n          gallery,\n          options,\n          items;\n\n        items = parseThumbnailElements(galleryElement);\n        // define options (if needed)\n        options = {\n\n          // define gallery index (for URL)\n          galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n          getThumbBoundsFn: function getThumbBoundsFn(index) {\n            // See Options -> getThumbBoundsFn section of documentation for more info\n            var thumbnail = items[index].el.getElementsByTagName('img')[0],\n              // find thumbnail\n              pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n              rect = thumbnail.getBoundingClientRect();\n\n            return {\n              x: rect.left,\n              y: rect.top + pageYScroll,\n              w: rect.width\n            };\n          }\n\n        };\n\n        // PhotoSwipe opened from URL\n        if (fromURL) {\n          if (options.galleryPIDs) {\n            // parse real index when custom PIDs are used \n            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n            for (var j = 0; j < items.length; j++) {\n              if (items[j].pid == index) {\n                options.index = j;\n                break;\n              }\n            }\n          } else {\n            // in URL indexes start from 1\n            options.index = parseInt(index, 10) - 1;\n          }\n        } else {\n          options.index = parseInt(index, 10);\n        }\n\n        // exit if index not found\n        if (isNaN(options.index)) {\n          return;\n        }\n\n        if (disableAnimation) {\n          options.showAnimationDuration = 0;\n        }\n\n        // Pass data to PhotoSwipe and initialize it\n        gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n        gallery.init();\n\n        var $tempVideo;\n        var stopVideoHandle = function stopVideoHandle() {\n          if ($tempVideo) {\n            $tempVideo.remove();\n            $tempVideo = null;\n          }\n        };\n        var changeHandle = function changeHandle() {\n          var item = gallery.currItem;\n          stopVideoHandle();\n          if (item.type === 'video') {\n            var $ctn = item.container;\n            var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n            var $video = document.createElement('video');\n            $video.setAttribute('autoplay', 'autoplay');\n            $video.setAttribute('controls', 'controls');\n            $video.setAttribute('src', item.target);\n            $video.style.width = style.width;\n            $video.style.height = style.height;\n            $video.style.position = 'absolute';\n            $video.style.zIndex = 2;\n            $tempVideo = $video;\n            $ctn.appendChild($video);\n          }\n        };\n        gallery.listen('initialZoomIn', changeHandle);\n        gallery.listen('afterChange', changeHandle);\n        gallery.listen('initialZoomOut', stopVideoHandle);\n      };\n\n      // loop through all gallery elements and bind events\n      var galleryElements = document.querySelectorAll(gallerySelector);\n      for (var i = 0, l = galleryElements.length; i < l; i++) {\n        galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n        galleryElements[i].onclick = onThumbnailsClick;\n      }\n\n      // Parse URL and open gallery if it contains #&pid=3&gid=1\n      var hashData = photoswipeParseHash();\n      if (hashData.pid && hashData.gid) {\n        openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n      }\n    };\n\n    var Viewer = function() {\n      function init() {\n        initPhotoSwipeFromDOM('.photos');\n      }\n      return {\n        init: init\n      };\n    }();\n\n    module.exports = Viewer;\n\n    /***/\n  },\n  /* 3 */\n  /***/\n  function(module, exports) {\n\n    /* WEBPACK VAR INJECTION */\n    (function(global) {\n      module.exports = inViewport;\n\n      var instances = [];\n      var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n      function inViewport(elt, params, cb) {\n        var opts = {\n          container: global.document.body,\n          offset: 0\n        };\n\n        if (params === undefined || typeof params === 'function') {\n          cb = params;\n          params = {};\n        }\n\n        var container = opts.container = params.container || opts.container;\n        var offset = opts.offset = params.offset || opts.offset;\n\n        for (var i = 0; i < instances.length; i++) {\n          if (instances[i].container === container) {\n            return instances[i].isInViewport(elt, offset, cb);\n          }\n        }\n\n        return instances[\n          instances.push(createInViewport(container)) - 1\n        ].isInViewport(elt, offset, cb);\n      }\n\n      function addEvent(el, type, fn) {\n        if (el.attachEvent) {\n          el.attachEvent('on' + type, fn);\n        } else {\n          el.addEventListener(type, fn, false);\n        }\n      }\n\n      function debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this,\n            args = arguments;\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n          if (callNow) func.apply(context, args);\n\n          function later() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          }\n        };\n      }\n\n      // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n      var contains = function() {\n        if (!global.document) {\n          return true;\n        }\n        return global.document.documentElement.compareDocumentPosition ?\n          function(a, b) {\n            return !!(a.compareDocumentPosition(b) & 16);\n          } :\n          global.document.documentElement.contains ?\n          function(a, b) {\n            return a !== b && (a.contains ? a.contains(b) : false);\n          } :\n          function(a, b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n      }\n\n      function createInViewport(container) {\n        var watches = createWatches();\n\n        var scrollContainer = container === global.document.body ? global : container;\n        var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n        addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n        if (scrollContainer === global) {\n          addEvent(global, 'resize', debouncedCheck);\n        }\n\n        if (supportsMutationObserver) {\n          observeDOM(watches, container, debouncedCheck);\n        }\n\n        // failsafe check, every 200ms we check for visible images\n        // usecase: a hidden parent containing eleements\n        // when the parent becomes visible, we have no event that the children\n        // became visible\n        setInterval(debouncedCheck, 150);\n\n        function isInViewport(elt, offset, cb) {\n          if (!cb) {\n            return isVisible(elt, offset);\n          }\n\n          var remote = createRemote(elt, offset, cb);\n          remote.watch();\n          return remote;\n        }\n\n        function createRemote(elt, offset, cb) {\n          function watch() {\n            watches.add(elt, offset, cb);\n          }\n\n          function dispose() {\n            watches.remove(elt);\n          }\n\n          return {\n            watch: watch,\n            dispose: dispose\n          };\n        }\n\n        function watchInViewport(elt, offset, cb) {\n          if (isVisible(elt, offset)) {\n            watches.remove(elt);\n            cb(elt);\n          }\n        }\n\n        function isVisible(elt, offset) {\n          if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n            return false;\n          }\n\n          // Check if the element is visible\n          // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n          if (!elt.offsetWidth || !elt.offsetHeight) {\n            return false;\n          }\n\n          var eltRect = elt.getBoundingClientRect();\n          var viewport = {};\n\n          if (container === global.document.body) {\n            viewport = {\n              top: -offset,\n              left: -offset,\n              right: global.document.documentElement.clientWidth + offset,\n              bottom: global.document.documentElement.clientHeight + offset\n            };\n          } else {\n            var containerRect = container.getBoundingClientRect();\n            viewport = {\n              top: containerRect.top - offset,\n              left: containerRect.left - offset,\n              right: containerRect.right + offset,\n              bottom: containerRect.bottom + offset\n            };\n          }\n\n          // The element must overlap with the visible part of the viewport\n          var visible =\n            (\n              (eltRect.right > viewport.left) &&\n              (eltRect.left < viewport.right) &&\n              (eltRect.bottom > viewport.top) &&\n              (eltRect.top < viewport.bottom)\n            );\n\n          return visible;\n        }\n\n        return {\n          container: container,\n          isInViewport: isInViewport\n        };\n      }\n\n      function createWatches() {\n        var watches = [];\n\n        function add(elt, offset, cb) {\n          if (!isWatched(elt)) {\n            watches.push([elt, offset, cb]);\n          }\n        }\n\n        function remove(elt) {\n          var pos = indexOf(elt);\n          if (pos !== -1) {\n            watches.splice(pos, 1);\n          }\n        }\n\n        function indexOf(elt) {\n          for (var i = watches.length - 1; i >= 0; i--) {\n            if (watches[i][0] === elt) {\n              return i;\n            }\n          }\n          return -1;\n        }\n\n        function isWatched(elt) {\n          return indexOf(elt) !== -1;\n        }\n\n        function checkAll(cb) {\n          return function() {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              cb.apply(this, watches[i]);\n            }\n          };\n        }\n\n        return {\n          add: add,\n          remove: remove,\n          isWatched: isWatched,\n          checkAll: checkAll\n        };\n      }\n\n      function observeDOM(watches, container, cb) {\n        var observer = new MutationObserver(watch);\n        var filter = Array.prototype.filter;\n        var concat = Array.prototype.concat;\n\n        observer.observe(container, {\n          childList: true,\n          subtree: true,\n          // changes like style/width/height/display will be catched\n          attributes: true\n        });\n\n        function watch(mutations) {\n          // some new DOM nodes where previously watched\n          // we should check their positions\n          if (mutations.some(knownNodes) === true) {\n            setTimeout(cb, 0);\n          }\n        }\n\n        function knownNodes(mutation) {\n          var nodes = concat.call([],\n            Array.prototype.slice.call(mutation.addedNodes),\n            mutation.target\n          );\n          return filter.call(nodes, watches.isWatched).length > 0;\n        }\n      }\n\n      /* WEBPACK VAR INJECTION */\n    }.call(exports, (function() {\n      return this;\n    }())))\n\n    /***/\n  }\n  /******/\n]);"},{"title":"tags","date":"2018-10-09T14:22:22.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-10-09 22:22:22\ntype: \"tags\"\n---\n","updated":"2025-02-12T08:28:16.474Z","path":"tags/index.html","_id":"clhua15a3000a9gj784msfszg","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"{\n\t\"list\": [{\n\t\t\"date\": \"2018-10\",\n\t\t\"arr\": {\n\t\t\t\"year\": 2018,\n\t\t\t\"month\": 10,\n\t\t\t\"src\": [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t\t\t\"link\": [\"image1\",\"image2\", \"image3\", \"image7\", \"image9\"],\n\t\t\t\"text\": [\"长城\", \"长城\", \"长城\", \"上海\", \"lol总决赛\"],\n\t\t\t\"type\": [\"image\", \"image\", \"image\",  \"image\", \"image\"]\n\t\t}\n\t}]\n}","source":"photos/ins.json","raw":"{\n\t\"list\": [{\n\t\t\"date\": \"2018-10\",\n\t\t\"arr\": {\n\t\t\t\"year\": 2018,\n\t\t\t\"month\": 10,\n\t\t\t\"src\": [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t\t\t\"link\": [\"image1\",\"image2\", \"image3\", \"image7\", \"image9\"],\n\t\t\t\"text\": [\"长城\", \"长城\", \"长城\", \"上海\", \"lol总决赛\"],\n\t\t\t\"type\": [\"image\", \"image\", \"image\",  \"image\", \"image\"]\n\t\t}\n\t}]\n}","date":"2025-02-12T08:28:16.474Z","updated":"2025-02-12T08:28:16.474Z","path":"photos/ins.json","layout":"false","_id":"clhua15a6000e9gj7zp7ukmy4","title":"","comments":1,"content":"{\"list\":[{\"date\":\"2018-10\",\"arr\":{\"year\":2018,\"month\":10,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"image1\",\"image2\",\"image3\",\"image7\",\"image9\"],\"text\":[\"长城\",\"长城\",\"长城\",\"上海\",\"lol总决赛\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\"]}}]}","site":{"data":{}},"excerpt":"","more":"{\"list\":[{\"date\":\"2018-10\",\"arr\":{\"year\":2018,\"month\":10,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"image1\",\"image2\",\"image3\",\"image7\",\"image9\"],\"text\":[\"长城\",\"长城\",\"长城\",\"上海\",\"lol总决赛\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\"]}}]}"}],"Post":[{"_content":"","source":"_posts/mybatis_01.md","raw":"","slug":"mybatis_01","published":1,"date":"2023-05-19T02:16:10.337Z","updated":"2023-05-19T02:16:10.337Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua159400009gj7im9rtydi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Mysql - sql优化","_content":"\nsql优化\n\n#### sql优化\n\n1. 尽量全值匹配,有联合索引的话key_len会保持在合适的大小\n2. 最佳左前缀法则\n3. 不在索引列上做任何操作\n4. 范围条件放最后\n5. 覆盖索引尽量用 不要select *\n6. 不等于要慎用 mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描\n7. Null/Not Null 有影响 当字段可为空时，is null会使用索引，is not null会导致索引失效。当字段不为空是，两者都不会使用索引。\n8. Like查询要当心\n9. 字符类型加引号\n10. OR改UNION效率高,用union更快\n\n#### sql快速导入导出\n\n```sql\n# 导出\nselect * into OUTFILE 'D:\\\\product.txt' from product_info\n# 导入\nload data INFILE 'D:\\\\product.txt' into table product_info\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mysql-sql优化.md","raw":"---\ntitle: Mysql - sql优化\ntags:\n  - Mysql\n---\n\nsql优化\n\n#### sql优化\n\n1. 尽量全值匹配,有联合索引的话key_len会保持在合适的大小\n2. 最佳左前缀法则\n3. 不在索引列上做任何操作\n4. 范围条件放最后\n5. 覆盖索引尽量用 不要select *\n6. 不等于要慎用 mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描\n7. Null/Not Null 有影响 当字段可为空时，is null会使用索引，is not null会导致索引失效。当字段不为空是，两者都不会使用索引。\n8. Like查询要当心\n9. 字符类型加引号\n10. OR改UNION效率高,用union更快\n\n#### sql快速导入导出\n\n```sql\n# 导出\nselect * into OUTFILE 'D:\\\\product.txt' from product_info\n# 导入\nload data INFILE 'D:\\\\product.txt' into table product_info\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mysql-sql优化","published":1,"date":"2025-02-12T08:28:16.457Z","updated":"2025-02-12T08:28:16.457Z","_id":"clhua159t00029gj7k1b2egzd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>sql优化</p>\n<h4 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h4><ol>\n<li>尽量全值匹配,有联合索引的话key_len会保持在合适的大小</li>\n<li>最佳左前缀法则</li>\n<li>不在索引列上做任何操作</li>\n<li>范围条件放最后</li>\n<li>覆盖索引尽量用 不要select *</li>\n<li>不等于要慎用 mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li>\n<li>Null/Not Null 有影响 当字段可为空时，is null会使用索引，is not null会导致索引失效。当字段不为空是，两者都不会使用索引。</li>\n<li>Like查询要当心</li>\n<li>字符类型加引号</li>\n<li>OR改UNION效率高,用union更快</li>\n</ol>\n<h4 id=\"sql快速导入导出\"><a href=\"#sql快速导入导出\" class=\"headerlink\" title=\"sql快速导入导出\"></a>sql快速导入导出</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 导出</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">into</span> <span class=\"keyword\">OUTFILE</span> <span class=\"string\">'D:\\\\product.txt'</span> <span class=\"keyword\">from</span> product_info</span><br><span class=\"line\"># 导入</span><br><span class=\"line\"><span class=\"keyword\">load</span> <span class=\"keyword\">data</span> <span class=\"keyword\">INFILE</span> <span class=\"string\">'D:\\\\product.txt'</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> product_info</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>sql优化</p>\n<h4 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h4><ol>\n<li>尽量全值匹配,有联合索引的话key_len会保持在合适的大小</li>\n<li>最佳左前缀法则</li>\n<li>不在索引列上做任何操作</li>\n<li>范围条件放最后</li>\n<li>覆盖索引尽量用 不要select *</li>\n<li>不等于要慎用 mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li>\n<li>Null/Not Null 有影响 当字段可为空时，is null会使用索引，is not null会导致索引失效。当字段不为空是，两者都不会使用索引。</li>\n<li>Like查询要当心</li>\n<li>字符类型加引号</li>\n<li>OR改UNION效率高,用union更快</li>\n</ol>\n<h4 id=\"sql快速导入导出\"><a href=\"#sql快速导入导出\" class=\"headerlink\" title=\"sql快速导入导出\"></a>sql快速导入导出</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 导出</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">into</span> <span class=\"keyword\">OUTFILE</span> <span class=\"string\">'D:\\\\product.txt'</span> <span class=\"keyword\">from</span> product_info</span><br><span class=\"line\"># 导入</span><br><span class=\"line\"><span class=\"keyword\">load</span> <span class=\"keyword\">data</span> <span class=\"keyword\">INFILE</span> <span class=\"string\">'D:\\\\product.txt'</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> product_info</span><br></pre></td></tr></table></figure>\n"},{"title":"Mysql - MySql业务设计","_content":"\nMySql业务设计\n\n#### MySql业务设计\n\n\n##### 范式设计\n\n- 第一大范式 数据库表中的所有字段都只具有单一属性\n- 第二大范式 要求表中只具有一个业务主键\n- 第三大范式 指每一个非主属性之间不能有互相依赖关系\n\n问题：完全符合范式化的设计有时并不能得到良好得SQL查询性能\ntimestamp 和时区有关，而datetime无关\n\n\n##### 反范式化设计\n\n\n为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反，允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间，不能完全按照范式得要求进行设计。\n\n||优点|缺点|\n|-|-|-|\n|范式化|可以尽量得减少数据冗余<br/>范式化的更新操作比反范式化更快\t<br/>\t范式化的表通常比反范式化的表更小|对于查询需要对多个表进行关联<br/>\t更难进行索引优化 |\n|反范式|可以减少表的关联<br/>可以更好的进行索引优化|存在数据冗余及数据维护异常<br/>对数据的修改需要更多的成本|\n\n\n#### 物理设计\n\n\n- 定义数据库、表及字段的命名规范\n\n\t可读性原则、表意性原则(意思清晰)、长名原则(不使用缩写)\n\n- 选择合适的存储引擎\n- 为表中的字段选择合适的数据类型\n\n\t- 优先考虑数字类型\n\t- 其次是日期、时间类型\n\t- 最后是字符类型\n\t- 对于相同级别的数据类型，应该优先选择占用空间小的数据类型。金额类除外，建议使用DECIMAL类型。(其它:timestamp和时区有关，而datetime无关)\n\n- 建立数据库结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mysql-业务设计.md","raw":"---\ntitle: Mysql - MySql业务设计\ntags:\n  - Mysql\n---\n\nMySql业务设计\n\n#### MySql业务设计\n\n\n##### 范式设计\n\n- 第一大范式 数据库表中的所有字段都只具有单一属性\n- 第二大范式 要求表中只具有一个业务主键\n- 第三大范式 指每一个非主属性之间不能有互相依赖关系\n\n问题：完全符合范式化的设计有时并不能得到良好得SQL查询性能\ntimestamp 和时区有关，而datetime无关\n\n\n##### 反范式化设计\n\n\n为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反，允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间，不能完全按照范式得要求进行设计。\n\n||优点|缺点|\n|-|-|-|\n|范式化|可以尽量得减少数据冗余<br/>范式化的更新操作比反范式化更快\t<br/>\t范式化的表通常比反范式化的表更小|对于查询需要对多个表进行关联<br/>\t更难进行索引优化 |\n|反范式|可以减少表的关联<br/>可以更好的进行索引优化|存在数据冗余及数据维护异常<br/>对数据的修改需要更多的成本|\n\n\n#### 物理设计\n\n\n- 定义数据库、表及字段的命名规范\n\n\t可读性原则、表意性原则(意思清晰)、长名原则(不使用缩写)\n\n- 选择合适的存储引擎\n- 为表中的字段选择合适的数据类型\n\n\t- 优先考虑数字类型\n\t- 其次是日期、时间类型\n\t- 最后是字符类型\n\t- 对于相同级别的数据类型，应该优先选择占用空间小的数据类型。金额类除外，建议使用DECIMAL类型。(其它:timestamp和时区有关，而datetime无关)\n\n- 建立数据库结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mysql-业务设计","published":1,"date":"2025-02-12T08:28:16.458Z","updated":"2025-02-12T08:28:16.458Z","_id":"clhua159w00049gj7n85qonmv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>MySql业务设计</p>\n<h4 id=\"MySql业务设计\"><a href=\"#MySql业务设计\" class=\"headerlink\" title=\"MySql业务设计\"></a>MySql业务设计</h4><h5 id=\"范式设计\"><a href=\"#范式设计\" class=\"headerlink\" title=\"范式设计\"></a>范式设计</h5><ul>\n<li>第一大范式 数据库表中的所有字段都只具有单一属性</li>\n<li>第二大范式 要求表中只具有一个业务主键</li>\n<li>第三大范式 指每一个非主属性之间不能有互相依赖关系</li>\n</ul>\n<p>问题：完全符合范式化的设计有时并不能得到良好得SQL查询性能<br>timestamp 和时区有关，而datetime无关</p>\n<h5 id=\"反范式化设计\"><a href=\"#反范式化设计\" class=\"headerlink\" title=\"反范式化设计\"></a>反范式化设计</h5><p>为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反，允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间，不能完全按照范式得要求进行设计。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>范式化</td>\n<td>可以尽量得减少数据冗余<br>范式化的更新操作比反范式化更快    <br>    范式化的表通常比反范式化的表更小</td>\n<td>对于查询需要对多个表进行关联<br>    更难进行索引优化</td>\n</tr>\n<tr>\n<td>反范式</td>\n<td>可以减少表的关联<br>可以更好的进行索引优化</td>\n<td>存在数据冗余及数据维护异常<br>对数据的修改需要更多的成本</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"物理设计\"><a href=\"#物理设计\" class=\"headerlink\" title=\"物理设计\"></a>物理设计</h4><ul>\n<li><p>定义数据库、表及字段的命名规范</p>\n<p>  可读性原则、表意性原则(意思清晰)、长名原则(不使用缩写)</p>\n</li>\n<li><p>选择合适的存储引擎</p>\n</li>\n<li><p>为表中的字段选择合适的数据类型</p>\n<ul>\n<li>优先考虑数字类型</li>\n<li>其次是日期、时间类型</li>\n<li>最后是字符类型</li>\n<li>对于相同级别的数据类型，应该优先选择占用空间小的数据类型。金额类除外，建议使用DECIMAL类型。(其它:timestamp和时区有关，而datetime无关)</li>\n</ul>\n</li>\n<li><p>建立数据库结构</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>MySql业务设计</p>\n<h4 id=\"MySql业务设计\"><a href=\"#MySql业务设计\" class=\"headerlink\" title=\"MySql业务设计\"></a>MySql业务设计</h4><h5 id=\"范式设计\"><a href=\"#范式设计\" class=\"headerlink\" title=\"范式设计\"></a>范式设计</h5><ul>\n<li>第一大范式 数据库表中的所有字段都只具有单一属性</li>\n<li>第二大范式 要求表中只具有一个业务主键</li>\n<li>第三大范式 指每一个非主属性之间不能有互相依赖关系</li>\n</ul>\n<p>问题：完全符合范式化的设计有时并不能得到良好得SQL查询性能<br>timestamp 和时区有关，而datetime无关</p>\n<h5 id=\"反范式化设计\"><a href=\"#反范式化设计\" class=\"headerlink\" title=\"反范式化设计\"></a>反范式化设计</h5><p>为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反，允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间，不能完全按照范式得要求进行设计。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>范式化</td>\n<td>可以尽量得减少数据冗余<br>范式化的更新操作比反范式化更快    <br>    范式化的表通常比反范式化的表更小</td>\n<td>对于查询需要对多个表进行关联<br>    更难进行索引优化</td>\n</tr>\n<tr>\n<td>反范式</td>\n<td>可以减少表的关联<br>可以更好的进行索引优化</td>\n<td>存在数据冗余及数据维护异常<br>对数据的修改需要更多的成本</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"物理设计\"><a href=\"#物理设计\" class=\"headerlink\" title=\"物理设计\"></a>物理设计</h4><ul>\n<li><p>定义数据库、表及字段的命名规范</p>\n<p>  可读性原则、表意性原则(意思清晰)、长名原则(不使用缩写)</p>\n</li>\n<li><p>选择合适的存储引擎</p>\n</li>\n<li><p>为表中的字段选择合适的数据类型</p>\n<ul>\n<li>优先考虑数字类型</li>\n<li>其次是日期、时间类型</li>\n<li>最后是字符类型</li>\n<li>对于相同级别的数据类型，应该优先选择占用空间小的数据类型。金额类除外，建议使用DECIMAL类型。(其它:timestamp和时区有关，而datetime无关)</li>\n</ul>\n</li>\n<li><p>建立数据库结构</p>\n</li>\n</ul>\n"},{"title":"Mysql - Mysql逻辑架构和存储引擎","_content":"\nMysql逻辑架构和存储引擎\n\n#### Mysql逻辑架构\n\n\n##### 衡量指标\n\n- TPS：Transactions Per Second（每秒传输的事物处理个数），这是指服务器每秒处理的事务数，支持事务的存储引擎如InnoDB等特有的一个性能指标。 \n\n- QPS：Queries Per Second（每秒查询处理量）同时适用与InnoDB和MyISAM 引擎\n\n- 等待时间：执行Sql等待返回结果之间的等待时间\n\n<!-- more -->\n\n##### MySqlSlap\n\n官方提供的压力测试工具，部分参数如下：\n\n参数 | 作用  \n-|-\n--create-schema=name | 指定测试的数据库名，默认是mysqlslap |\n--engine=name |创建测试表所使用的存储引擎，可指定多个|\n--concurrency=N|模拟N个客户端并发执行。可指定多个值，以逗号或者|\n--number-of-queries=N | 总的测试查询次数(并发客户数×每客户查询次数)，比如并发是10，总次数是100，那么10个客户端各执行10个 |\n--iterations=N  | 迭代执行的次数，即重复的次数（相同的测试进行N次，求一个平均值），指的是整个步骤的重复次数，包括准备数据、测试load、清理 |\n--commit=N | 执行N条DML后提交一次 |\n--auto-generate-sql, -a |自动生成测试表和数据，表示用mysqlslap工具自己生成的SQL脚本来测试并发压力。|\n--auto-generate-sql-load-type=name|# 测试语句的类型。代表要测试的环境是读操作还是写操作还是两者混合的。# 取值包括：read (scan tables), write (insert into tables), key (read primary keys), update (update primary keys), or mixed (half inserts, half scanning selects). 默认值是：mixed.|\n--auto-generate-sql-add-auto-increment|对生成的表自动添加auto_increment列|\n--number-char-cols=name |自动生成的测试表中包含N个字符类型的列，默认1|\n--number-int-cols=name|自动生成的测试表中包含N个数字类型的列，默认1|\n--debug-info |打印内存和CPU的信息|\n\n\n例：    \n\n```sh\n./mysqlslap -uroot -proot1234% --concurrency=1000  --iterations 10 -a  --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=1000\n\n./mysqlslap -uroot -proot1234%  --concurrency=1,50,100,200 --iterations=3 --number-char-cols=5 --number-int-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement  --engine=myisam,innodb  --create-schema='enjoytest1' --debug-info \n\n```\n\n#### Mysql逻辑架构\n\n![逻辑架构](http://image.tupelo.top/mysql%E9%80%BB%E8%BE%91.png)\n\n- 连接层\n\n  每一个客户端连接请求，服务器都会新建一个线程处理（如果是线程池的话，则是分配一个空的线程），每个线程独立，拥有各自的内存处理空间，会引发数据同步问题。\n\n- 服务层\n\n  - SQL处理层\n\n    SQL语句的解析、优化，缓存的查询，MySQL内置函数的实现\n\n  - 缓存\n\n    默认不开启。若手动开启还要手动设置缓存大小\n\n    ```sql\n    show variables like  '%query_cache_type%'\n\n    #开启缓存需要在配置文件中开启\n    show variables like  '%basedir%'\n\n    SET GLOBAL query_cache_size = 4000;\n    ```\n\n- 引擎层\n- 存储层\n\n#### Mysql存储引擎\n\n```sql\n#看你的mysql现在已提供什么存储引擎:\nshow engines;\n  \n#看你的mysql当前默认的存储引擎:\nshow variables like '%storage_engine%';\n```\n\n##### MyISAM\n  \n文件存储为：frm、MYD、MYI。特点：\n\n- 不支持事务\n- 表级锁     \n- 支持全文检索    \n- 支持数据压缩 压缩MYI文件，会生成一个.old的文件，删除后会导致历史数据只能查询，不能删除和修改\n\n```sql\nmyisampack -b -f testmysam.MYI\n```\n\n适用场景：\n\n- 非事务型应用（数据仓库，报表，日志数据）\n- 只读类应用 查询速度快\n- 空间类应用（空间函数，坐标）\n           \n\n##### Innodb\n\n- 系统表空间\n  \n  数据全部存在一个文件 ibdataX\n\n\n- 独立表空间\n\n  每个表数据单独存储为：tablename.ibd\n\n二者差别：\n\n- 系统表空间无法简单的收缩文件大小，删除数据后ibdataX文件大小不变\n- 独立表空间可以通过optimize table 收缩系统文件，删除数据后可刷新tablename.ibd文件大小\n- 系统表空间会产生IO瓶颈，多个表写一个文件\n- 独立表空间可以同时向多个文件刷新数据，多个表写多个文件\n\n\n特点：\n\n- Innodb是一种事务性存储引擎\n- 完全支持事务得ACID特性\n- Redo Log 和 Undo Log\n- Innodb支持行级锁（并发程度更高）\n\n适用场景：大多数OLTP应用\n\n对比项 | MyISAM | InnoDB  \n-|-|-\n主外键|不支持|支持|\n事务|不支持|支持|\n行表锁|表锁，即使操作一条记录也会锁住整个表\n不适合高并发的操作|行锁,操作时只锁某一行，不对其它行有影响\n适合高并发的操作|\n缓存|只缓存索引，不缓存真实数据|不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响|\n表空间|小|大|\n关注点|性能|事务|\n默认安装|Y|YY|\n\n##### CSV\n\n组成:\n\n- csv文件存储内容\n- csm文件存储表得元数据如表状态和数据量\n- frm 表结构\n\n特点:\n\n- 以csv格式进行数据存储\n- 所有列都不能为null的\n- 不支持索引（不适合大表，不适合在线处理）\n- 可以对数据文件直接编辑（保存文本文件内容）\n\n适用场景：财务\n\n##### Archive\n\n组成:\n  \n- frm 表结构\n- arz 以zlib对表数据进行压缩，磁盘I/O更少 数据存储在ARZ为后缀的文件中\n\n特点:\n\n- 只支持insert和select操作\n- 只允许在自增ID列上加索引\n\n适用场景：日志收集\n\n##### Memory\n\n文件系统存储特点：\n\n- 也称HEAP存储引擎，所以数据保存在内存中\n- 支持HASH索引和BTree索引\n- 所有字段都是固定长度 varchar(10) = char(10)\n- 不支持Blog和Text等大字段\n- Memory存储引擎使用表级锁\n- 最大大小由max_heap_table_size参数决定\n\n临时表：也存在内存中，但是只限于当前会话\n\nmemory数据易丢失，所以要求数据可再生\n\n适用场景:\n\n- hash索引用于查找或者是映射表（邮编和地区的对应表）\n- 用于保存数据分析中产生的中间表\n- 用于缓存周期性聚合数据的结果表\n\n\n##### Federated\n\n特点:\n\n- 提供了访问远程MySQL服务器上表的方法\n- 本地不存储数据，数据全部放到远程服务器上\n- 本地需要保存表结构和远程服务器的连接信息\n\n默认禁止，启用需要再启动时增加federated参数\n\n创建表时添加connect=mysql://user_name[:password]@hostname[:port_num]/db_name/table_name\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mysql-逻辑架构和存储引擎.md","raw":"---\ntitle: Mysql - Mysql逻辑架构和存储引擎\ntags:\n  - Mysql\n---\n\nMysql逻辑架构和存储引擎\n\n#### Mysql逻辑架构\n\n\n##### 衡量指标\n\n- TPS：Transactions Per Second（每秒传输的事物处理个数），这是指服务器每秒处理的事务数，支持事务的存储引擎如InnoDB等特有的一个性能指标。 \n\n- QPS：Queries Per Second（每秒查询处理量）同时适用与InnoDB和MyISAM 引擎\n\n- 等待时间：执行Sql等待返回结果之间的等待时间\n\n<!-- more -->\n\n##### MySqlSlap\n\n官方提供的压力测试工具，部分参数如下：\n\n参数 | 作用  \n-|-\n--create-schema=name | 指定测试的数据库名，默认是mysqlslap |\n--engine=name |创建测试表所使用的存储引擎，可指定多个|\n--concurrency=N|模拟N个客户端并发执行。可指定多个值，以逗号或者|\n--number-of-queries=N | 总的测试查询次数(并发客户数×每客户查询次数)，比如并发是10，总次数是100，那么10个客户端各执行10个 |\n--iterations=N  | 迭代执行的次数，即重复的次数（相同的测试进行N次，求一个平均值），指的是整个步骤的重复次数，包括准备数据、测试load、清理 |\n--commit=N | 执行N条DML后提交一次 |\n--auto-generate-sql, -a |自动生成测试表和数据，表示用mysqlslap工具自己生成的SQL脚本来测试并发压力。|\n--auto-generate-sql-load-type=name|# 测试语句的类型。代表要测试的环境是读操作还是写操作还是两者混合的。# 取值包括：read (scan tables), write (insert into tables), key (read primary keys), update (update primary keys), or mixed (half inserts, half scanning selects). 默认值是：mixed.|\n--auto-generate-sql-add-auto-increment|对生成的表自动添加auto_increment列|\n--number-char-cols=name |自动生成的测试表中包含N个字符类型的列，默认1|\n--number-int-cols=name|自动生成的测试表中包含N个数字类型的列，默认1|\n--debug-info |打印内存和CPU的信息|\n\n\n例：    \n\n```sh\n./mysqlslap -uroot -proot1234% --concurrency=1000  --iterations 10 -a  --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=1000\n\n./mysqlslap -uroot -proot1234%  --concurrency=1,50,100,200 --iterations=3 --number-char-cols=5 --number-int-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement  --engine=myisam,innodb  --create-schema='enjoytest1' --debug-info \n\n```\n\n#### Mysql逻辑架构\n\n![逻辑架构](http://image.tupelo.top/mysql%E9%80%BB%E8%BE%91.png)\n\n- 连接层\n\n  每一个客户端连接请求，服务器都会新建一个线程处理（如果是线程池的话，则是分配一个空的线程），每个线程独立，拥有各自的内存处理空间，会引发数据同步问题。\n\n- 服务层\n\n  - SQL处理层\n\n    SQL语句的解析、优化，缓存的查询，MySQL内置函数的实现\n\n  - 缓存\n\n    默认不开启。若手动开启还要手动设置缓存大小\n\n    ```sql\n    show variables like  '%query_cache_type%'\n\n    #开启缓存需要在配置文件中开启\n    show variables like  '%basedir%'\n\n    SET GLOBAL query_cache_size = 4000;\n    ```\n\n- 引擎层\n- 存储层\n\n#### Mysql存储引擎\n\n```sql\n#看你的mysql现在已提供什么存储引擎:\nshow engines;\n  \n#看你的mysql当前默认的存储引擎:\nshow variables like '%storage_engine%';\n```\n\n##### MyISAM\n  \n文件存储为：frm、MYD、MYI。特点：\n\n- 不支持事务\n- 表级锁     \n- 支持全文检索    \n- 支持数据压缩 压缩MYI文件，会生成一个.old的文件，删除后会导致历史数据只能查询，不能删除和修改\n\n```sql\nmyisampack -b -f testmysam.MYI\n```\n\n适用场景：\n\n- 非事务型应用（数据仓库，报表，日志数据）\n- 只读类应用 查询速度快\n- 空间类应用（空间函数，坐标）\n           \n\n##### Innodb\n\n- 系统表空间\n  \n  数据全部存在一个文件 ibdataX\n\n\n- 独立表空间\n\n  每个表数据单独存储为：tablename.ibd\n\n二者差别：\n\n- 系统表空间无法简单的收缩文件大小，删除数据后ibdataX文件大小不变\n- 独立表空间可以通过optimize table 收缩系统文件，删除数据后可刷新tablename.ibd文件大小\n- 系统表空间会产生IO瓶颈，多个表写一个文件\n- 独立表空间可以同时向多个文件刷新数据，多个表写多个文件\n\n\n特点：\n\n- Innodb是一种事务性存储引擎\n- 完全支持事务得ACID特性\n- Redo Log 和 Undo Log\n- Innodb支持行级锁（并发程度更高）\n\n适用场景：大多数OLTP应用\n\n对比项 | MyISAM | InnoDB  \n-|-|-\n主外键|不支持|支持|\n事务|不支持|支持|\n行表锁|表锁，即使操作一条记录也会锁住整个表\n不适合高并发的操作|行锁,操作时只锁某一行，不对其它行有影响\n适合高并发的操作|\n缓存|只缓存索引，不缓存真实数据|不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响|\n表空间|小|大|\n关注点|性能|事务|\n默认安装|Y|YY|\n\n##### CSV\n\n组成:\n\n- csv文件存储内容\n- csm文件存储表得元数据如表状态和数据量\n- frm 表结构\n\n特点:\n\n- 以csv格式进行数据存储\n- 所有列都不能为null的\n- 不支持索引（不适合大表，不适合在线处理）\n- 可以对数据文件直接编辑（保存文本文件内容）\n\n适用场景：财务\n\n##### Archive\n\n组成:\n  \n- frm 表结构\n- arz 以zlib对表数据进行压缩，磁盘I/O更少 数据存储在ARZ为后缀的文件中\n\n特点:\n\n- 只支持insert和select操作\n- 只允许在自增ID列上加索引\n\n适用场景：日志收集\n\n##### Memory\n\n文件系统存储特点：\n\n- 也称HEAP存储引擎，所以数据保存在内存中\n- 支持HASH索引和BTree索引\n- 所有字段都是固定长度 varchar(10) = char(10)\n- 不支持Blog和Text等大字段\n- Memory存储引擎使用表级锁\n- 最大大小由max_heap_table_size参数决定\n\n临时表：也存在内存中，但是只限于当前会话\n\nmemory数据易丢失，所以要求数据可再生\n\n适用场景:\n\n- hash索引用于查找或者是映射表（邮编和地区的对应表）\n- 用于保存数据分析中产生的中间表\n- 用于缓存周期性聚合数据的结果表\n\n\n##### Federated\n\n特点:\n\n- 提供了访问远程MySQL服务器上表的方法\n- 本地不存储数据，数据全部放到远程服务器上\n- 本地需要保存表结构和远程服务器的连接信息\n\n默认禁止，启用需要再启动时增加federated参数\n\n创建表时添加connect=mysql://user_name[:password]@hostname[:port_num]/db_name/table_name\n\n\n\n\n\n\n\n\n\n\n","slug":"Mysql-逻辑架构和存储引擎","published":1,"date":"2025-02-12T08:28:16.458Z","updated":"2025-02-12T08:28:16.458Z","_id":"clhua159z00079gj74817ite0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Mysql逻辑架构和存储引擎</p>\n<h4 id=\"Mysql逻辑架构\"><a href=\"#Mysql逻辑架构\" class=\"headerlink\" title=\"Mysql逻辑架构\"></a>Mysql逻辑架构</h4><h5 id=\"衡量指标\"><a href=\"#衡量指标\" class=\"headerlink\" title=\"衡量指标\"></a>衡量指标</h5><ul>\n<li><p>TPS：Transactions Per Second（每秒传输的事物处理个数），这是指服务器每秒处理的事务数，支持事务的存储引擎如InnoDB等特有的一个性能指标。 </p>\n</li>\n<li><p>QPS：Queries Per Second（每秒查询处理量）同时适用与InnoDB和MyISAM 引擎</p>\n</li>\n<li><p>等待时间：执行Sql等待返回结果之间的等待时间</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"MySqlSlap\"><a href=\"#MySqlSlap\" class=\"headerlink\" title=\"MySqlSlap\"></a>MySqlSlap</h5><p>官方提供的压力测试工具，部分参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–create-schema=name</td>\n<td>指定测试的数据库名，默认是mysqlslap</td>\n<td></td>\n</tr>\n<tr>\n<td>–engine=name</td>\n<td>创建测试表所使用的存储引擎，可指定多个</td>\n<td></td>\n</tr>\n<tr>\n<td>–concurrency=N</td>\n<td>模拟N个客户端并发执行。可指定多个值，以逗号或者</td>\n<td></td>\n</tr>\n<tr>\n<td>–number-of-queries=N</td>\n<td>总的测试查询次数(并发客户数×每客户查询次数)，比如并发是10，总次数是100，那么10个客户端各执行10个</td>\n<td></td>\n</tr>\n<tr>\n<td>–iterations=N</td>\n<td>迭代执行的次数，即重复的次数（相同的测试进行N次，求一个平均值），指的是整个步骤的重复次数，包括准备数据、测试load、清理</td>\n<td></td>\n</tr>\n<tr>\n<td>–commit=N</td>\n<td>执行N条DML后提交一次</td>\n<td></td>\n</tr>\n<tr>\n<td>–auto-generate-sql, -a</td>\n<td>自动生成测试表和数据，表示用mysqlslap工具自己生成的SQL脚本来测试并发压力。</td>\n<td></td>\n</tr>\n<tr>\n<td>–auto-generate-sql-load-type=name</td>\n<td># 测试语句的类型。代表要测试的环境是读操作还是写操作还是两者混合的。# 取值包括：read (scan tables), write (insert into tables), key (read primary keys), update (update primary keys), or mixed (half inserts, half scanning selects). 默认值是：mixed.</td>\n<td></td>\n</tr>\n<tr>\n<td>–auto-generate-sql-add-auto-increment</td>\n<td>对生成的表自动添加auto_increment列</td>\n<td></td>\n</tr>\n<tr>\n<td>–number-char-cols=name</td>\n<td>自动生成的测试表中包含N个字符类型的列，默认1</td>\n<td></td>\n</tr>\n<tr>\n<td>–number-int-cols=name</td>\n<td>自动生成的测试表中包含N个数字类型的列，默认1</td>\n<td></td>\n</tr>\n<tr>\n<td>–debug-info</td>\n<td>打印内存和CPU的信息</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>例：    </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mysqlslap -uroot -proot1234% --concurrency=1000  --iterations 10 -a  --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=1000</span><br><span class=\"line\"></span><br><span class=\"line\">./mysqlslap -uroot -proot1234%  --concurrency=1,50,100,200 --iterations=3 --number-char-cols=5 --number-int-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement  --engine=myisam,innodb  --create-schema=<span class=\"string\">'enjoytest1'</span> --debug-info</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mysql逻辑架构-1\"><a href=\"#Mysql逻辑架构-1\" class=\"headerlink\" title=\"Mysql逻辑架构\"></a>Mysql逻辑架构</h4><p><img src=\"http://image.tupelo.top/mysql%E9%80%BB%E8%BE%91.png\" alt=\"逻辑架构\"></p>\n<ul>\n<li><p>连接层</p>\n<p>每一个客户端连接请求，服务器都会新建一个线程处理（如果是线程池的话，则是分配一个空的线程），每个线程独立，拥有各自的内存处理空间，会引发数据同步问题。</p>\n</li>\n<li><p>服务层</p>\n<ul>\n<li><p>SQL处理层</p>\n<p>SQL语句的解析、优化，缓存的查询，MySQL内置函数的实现</p>\n</li>\n<li><p>缓存</p>\n<p>默认不开启。若手动开启还要手动设置缓存大小</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span>  <span class=\"string\">'%query_cache_type%'</span></span><br><span class=\"line\"></span><br><span class=\"line\">#开启缓存需要在配置文件中开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span>  <span class=\"string\">'%basedir%'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> query_cache_size = <span class=\"number\">4000</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>引擎层</p>\n</li>\n<li>存储层</li>\n</ul>\n<h4 id=\"Mysql存储引擎\"><a href=\"#Mysql存储引擎\" class=\"headerlink\" title=\"Mysql存储引擎\"></a>Mysql存储引擎</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#看你的mysql现在已提供什么存储引擎:</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">#看你的mysql当前默认的存储引擎:</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h5><p>文件存储为：frm、MYD、MYI。特点：</p>\n<ul>\n<li>不支持事务</li>\n<li>表级锁     </li>\n<li>支持全文检索    </li>\n<li>支持数据压缩 压缩MYI文件，会生成一个.old的文件，删除后会导致历史数据只能查询，不能删除和修改</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myisampack -b -f testmysam.MYI</span><br></pre></td></tr></table></figure>\n<p>适用场景：</p>\n<ul>\n<li>非事务型应用（数据仓库，报表，日志数据）</li>\n<li>只读类应用 查询速度快</li>\n<li>空间类应用（空间函数，坐标）</li>\n</ul>\n<h5 id=\"Innodb\"><a href=\"#Innodb\" class=\"headerlink\" title=\"Innodb\"></a>Innodb</h5><ul>\n<li><p>系统表空间</p>\n<p>数据全部存在一个文件 ibdataX</p>\n</li>\n</ul>\n<ul>\n<li><p>独立表空间</p>\n<p>每个表数据单独存储为：tablename.ibd</p>\n</li>\n</ul>\n<p>二者差别：</p>\n<ul>\n<li>系统表空间无法简单的收缩文件大小，删除数据后ibdataX文件大小不变</li>\n<li>独立表空间可以通过optimize table 收缩系统文件，删除数据后可刷新tablename.ibd文件大小</li>\n<li>系统表空间会产生IO瓶颈，多个表写一个文件</li>\n<li>独立表空间可以同时向多个文件刷新数据，多个表写多个文件</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>Innodb是一种事务性存储引擎</li>\n<li>完全支持事务得ACID特性</li>\n<li>Redo Log 和 Undo Log</li>\n<li>Innodb支持行级锁（并发程度更高）</li>\n</ul>\n<p>适用场景：大多数OLTP应用</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>MyISAM</th>\n<th>InnoDB  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主外键</td>\n<td>不支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>事务</td>\n<td>不支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>行表锁</td>\n<td>表锁，即使操作一条记录也会锁住整个表</td>\n</tr>\n<tr>\n<td>不适合高并发的操作</td>\n<td>行锁,操作时只锁某一行，不对其它行有影响</td>\n</tr>\n<tr>\n<td>适合高并发的操作</td>\n<td></td>\n</tr>\n<tr>\n<td>缓存</td>\n<td>只缓存索引，不缓存真实数据</td>\n<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>\n<td></td>\n</tr>\n<tr>\n<td>表空间</td>\n<td>小</td>\n<td>大</td>\n<td></td>\n</tr>\n<tr>\n<td>关注点</td>\n<td>性能</td>\n<td>事务</td>\n<td></td>\n</tr>\n<tr>\n<td>默认安装</td>\n<td>Y</td>\n<td>YY</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"CSV\"><a href=\"#CSV\" class=\"headerlink\" title=\"CSV\"></a>CSV</h5><p>组成:</p>\n<ul>\n<li>csv文件存储内容</li>\n<li>csm文件存储表得元数据如表状态和数据量</li>\n<li>frm 表结构</li>\n</ul>\n<p>特点:</p>\n<ul>\n<li>以csv格式进行数据存储</li>\n<li>所有列都不能为null的</li>\n<li>不支持索引（不适合大表，不适合在线处理）</li>\n<li>可以对数据文件直接编辑（保存文本文件内容）</li>\n</ul>\n<p>适用场景：财务</p>\n<h5 id=\"Archive\"><a href=\"#Archive\" class=\"headerlink\" title=\"Archive\"></a>Archive</h5><p>组成:</p>\n<ul>\n<li>frm 表结构</li>\n<li>arz 以zlib对表数据进行压缩，磁盘I/O更少 数据存储在ARZ为后缀的文件中</li>\n</ul>\n<p>特点:</p>\n<ul>\n<li>只支持insert和select操作</li>\n<li>只允许在自增ID列上加索引</li>\n</ul>\n<p>适用场景：日志收集</p>\n<h5 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h5><p>文件系统存储特点：</p>\n<ul>\n<li>也称HEAP存储引擎，所以数据保存在内存中</li>\n<li>支持HASH索引和BTree索引</li>\n<li>所有字段都是固定长度 varchar(10) = char(10)</li>\n<li>不支持Blog和Text等大字段</li>\n<li>Memory存储引擎使用表级锁</li>\n<li>最大大小由max_heap_table_size参数决定</li>\n</ul>\n<p>临时表：也存在内存中，但是只限于当前会话</p>\n<p>memory数据易丢失，所以要求数据可再生</p>\n<p>适用场景:</p>\n<ul>\n<li>hash索引用于查找或者是映射表（邮编和地区的对应表）</li>\n<li>用于保存数据分析中产生的中间表</li>\n<li>用于缓存周期性聚合数据的结果表</li>\n</ul>\n<h5 id=\"Federated\"><a href=\"#Federated\" class=\"headerlink\" title=\"Federated\"></a>Federated</h5><p>特点:</p>\n<ul>\n<li>提供了访问远程MySQL服务器上表的方法</li>\n<li>本地不存储数据，数据全部放到远程服务器上</li>\n<li>本地需要保存表结构和远程服务器的连接信息</li>\n</ul>\n<p>默认禁止，启用需要再启动时增加federated参数</p>\n<p>创建表时添加connect=mysql://user_name[:password]@hostname[:port_num]/db_name/table_name</p>\n","site":{"data":{}},"excerpt":"<p>Mysql逻辑架构和存储引擎</p>\n<h4 id=\"Mysql逻辑架构\"><a href=\"#Mysql逻辑架构\" class=\"headerlink\" title=\"Mysql逻辑架构\"></a>Mysql逻辑架构</h4><h5 id=\"衡量指标\"><a href=\"#衡量指标\" class=\"headerlink\" title=\"衡量指标\"></a>衡量指标</h5><ul>\n<li><p>TPS：Transactions Per Second（每秒传输的事物处理个数），这是指服务器每秒处理的事务数，支持事务的存储引擎如InnoDB等特有的一个性能指标。 </p>\n</li>\n<li><p>QPS：Queries Per Second（每秒查询处理量）同时适用与InnoDB和MyISAM 引擎</p>\n</li>\n<li><p>等待时间：执行Sql等待返回结果之间的等待时间</p>\n</li>\n</ul>","more":"<h5 id=\"MySqlSlap\"><a href=\"#MySqlSlap\" class=\"headerlink\" title=\"MySqlSlap\"></a>MySqlSlap</h5><p>官方提供的压力测试工具，部分参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–create-schema=name</td>\n<td>指定测试的数据库名，默认是mysqlslap</td>\n<td></td>\n</tr>\n<tr>\n<td>–engine=name</td>\n<td>创建测试表所使用的存储引擎，可指定多个</td>\n<td></td>\n</tr>\n<tr>\n<td>–concurrency=N</td>\n<td>模拟N个客户端并发执行。可指定多个值，以逗号或者</td>\n<td></td>\n</tr>\n<tr>\n<td>–number-of-queries=N</td>\n<td>总的测试查询次数(并发客户数×每客户查询次数)，比如并发是10，总次数是100，那么10个客户端各执行10个</td>\n<td></td>\n</tr>\n<tr>\n<td>–iterations=N</td>\n<td>迭代执行的次数，即重复的次数（相同的测试进行N次，求一个平均值），指的是整个步骤的重复次数，包括准备数据、测试load、清理</td>\n<td></td>\n</tr>\n<tr>\n<td>–commit=N</td>\n<td>执行N条DML后提交一次</td>\n<td></td>\n</tr>\n<tr>\n<td>–auto-generate-sql, -a</td>\n<td>自动生成测试表和数据，表示用mysqlslap工具自己生成的SQL脚本来测试并发压力。</td>\n<td></td>\n</tr>\n<tr>\n<td>–auto-generate-sql-load-type=name</td>\n<td># 测试语句的类型。代表要测试的环境是读操作还是写操作还是两者混合的。# 取值包括：read (scan tables), write (insert into tables), key (read primary keys), update (update primary keys), or mixed (half inserts, half scanning selects). 默认值是：mixed.</td>\n<td></td>\n</tr>\n<tr>\n<td>–auto-generate-sql-add-auto-increment</td>\n<td>对生成的表自动添加auto_increment列</td>\n<td></td>\n</tr>\n<tr>\n<td>–number-char-cols=name</td>\n<td>自动生成的测试表中包含N个字符类型的列，默认1</td>\n<td></td>\n</tr>\n<tr>\n<td>–number-int-cols=name</td>\n<td>自动生成的测试表中包含N个数字类型的列，默认1</td>\n<td></td>\n</tr>\n<tr>\n<td>–debug-info</td>\n<td>打印内存和CPU的信息</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>例：    </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mysqlslap -uroot -proot1234% --concurrency=1000  --iterations 10 -a  --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=1000</span><br><span class=\"line\"></span><br><span class=\"line\">./mysqlslap -uroot -proot1234%  --concurrency=1,50,100,200 --iterations=3 --number-char-cols=5 --number-int-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement  --engine=myisam,innodb  --create-schema=<span class=\"string\">'enjoytest1'</span> --debug-info</span><br></pre></td></tr></table></figure>\n<h4 id=\"Mysql逻辑架构-1\"><a href=\"#Mysql逻辑架构-1\" class=\"headerlink\" title=\"Mysql逻辑架构\"></a>Mysql逻辑架构</h4><p><img src=\"http://image.tupelo.top/mysql%E9%80%BB%E8%BE%91.png\" alt=\"逻辑架构\"></p>\n<ul>\n<li><p>连接层</p>\n<p>每一个客户端连接请求，服务器都会新建一个线程处理（如果是线程池的话，则是分配一个空的线程），每个线程独立，拥有各自的内存处理空间，会引发数据同步问题。</p>\n</li>\n<li><p>服务层</p>\n<ul>\n<li><p>SQL处理层</p>\n<p>SQL语句的解析、优化，缓存的查询，MySQL内置函数的实现</p>\n</li>\n<li><p>缓存</p>\n<p>默认不开启。若手动开启还要手动设置缓存大小</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span>  <span class=\"string\">'%query_cache_type%'</span></span><br><span class=\"line\"></span><br><span class=\"line\">#开启缓存需要在配置文件中开启</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span>  <span class=\"string\">'%basedir%'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> query_cache_size = <span class=\"number\">4000</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>引擎层</p>\n</li>\n<li>存储层</li>\n</ul>\n<h4 id=\"Mysql存储引擎\"><a href=\"#Mysql存储引擎\" class=\"headerlink\" title=\"Mysql存储引擎\"></a>Mysql存储引擎</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#看你的mysql现在已提供什么存储引擎:</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">#看你的mysql当前默认的存储引擎:</span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h5><p>文件存储为：frm、MYD、MYI。特点：</p>\n<ul>\n<li>不支持事务</li>\n<li>表级锁     </li>\n<li>支持全文检索    </li>\n<li>支持数据压缩 压缩MYI文件，会生成一个.old的文件，删除后会导致历史数据只能查询，不能删除和修改</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myisampack -b -f testmysam.MYI</span><br></pre></td></tr></table></figure>\n<p>适用场景：</p>\n<ul>\n<li>非事务型应用（数据仓库，报表，日志数据）</li>\n<li>只读类应用 查询速度快</li>\n<li>空间类应用（空间函数，坐标）</li>\n</ul>\n<h5 id=\"Innodb\"><a href=\"#Innodb\" class=\"headerlink\" title=\"Innodb\"></a>Innodb</h5><ul>\n<li><p>系统表空间</p>\n<p>数据全部存在一个文件 ibdataX</p>\n</li>\n</ul>\n<ul>\n<li><p>独立表空间</p>\n<p>每个表数据单独存储为：tablename.ibd</p>\n</li>\n</ul>\n<p>二者差别：</p>\n<ul>\n<li>系统表空间无法简单的收缩文件大小，删除数据后ibdataX文件大小不变</li>\n<li>独立表空间可以通过optimize table 收缩系统文件，删除数据后可刷新tablename.ibd文件大小</li>\n<li>系统表空间会产生IO瓶颈，多个表写一个文件</li>\n<li>独立表空间可以同时向多个文件刷新数据，多个表写多个文件</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>Innodb是一种事务性存储引擎</li>\n<li>完全支持事务得ACID特性</li>\n<li>Redo Log 和 Undo Log</li>\n<li>Innodb支持行级锁（并发程度更高）</li>\n</ul>\n<p>适用场景：大多数OLTP应用</p>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>MyISAM</th>\n<th>InnoDB  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主外键</td>\n<td>不支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>事务</td>\n<td>不支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>行表锁</td>\n<td>表锁，即使操作一条记录也会锁住整个表</td>\n</tr>\n<tr>\n<td>不适合高并发的操作</td>\n<td>行锁,操作时只锁某一行，不对其它行有影响</td>\n</tr>\n<tr>\n<td>适合高并发的操作</td>\n<td></td>\n</tr>\n<tr>\n<td>缓存</td>\n<td>只缓存索引，不缓存真实数据</td>\n<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>\n<td></td>\n</tr>\n<tr>\n<td>表空间</td>\n<td>小</td>\n<td>大</td>\n<td></td>\n</tr>\n<tr>\n<td>关注点</td>\n<td>性能</td>\n<td>事务</td>\n<td></td>\n</tr>\n<tr>\n<td>默认安装</td>\n<td>Y</td>\n<td>YY</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"CSV\"><a href=\"#CSV\" class=\"headerlink\" title=\"CSV\"></a>CSV</h5><p>组成:</p>\n<ul>\n<li>csv文件存储内容</li>\n<li>csm文件存储表得元数据如表状态和数据量</li>\n<li>frm 表结构</li>\n</ul>\n<p>特点:</p>\n<ul>\n<li>以csv格式进行数据存储</li>\n<li>所有列都不能为null的</li>\n<li>不支持索引（不适合大表，不适合在线处理）</li>\n<li>可以对数据文件直接编辑（保存文本文件内容）</li>\n</ul>\n<p>适用场景：财务</p>\n<h5 id=\"Archive\"><a href=\"#Archive\" class=\"headerlink\" title=\"Archive\"></a>Archive</h5><p>组成:</p>\n<ul>\n<li>frm 表结构</li>\n<li>arz 以zlib对表数据进行压缩，磁盘I/O更少 数据存储在ARZ为后缀的文件中</li>\n</ul>\n<p>特点:</p>\n<ul>\n<li>只支持insert和select操作</li>\n<li>只允许在自增ID列上加索引</li>\n</ul>\n<p>适用场景：日志收集</p>\n<h5 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h5><p>文件系统存储特点：</p>\n<ul>\n<li>也称HEAP存储引擎，所以数据保存在内存中</li>\n<li>支持HASH索引和BTree索引</li>\n<li>所有字段都是固定长度 varchar(10) = char(10)</li>\n<li>不支持Blog和Text等大字段</li>\n<li>Memory存储引擎使用表级锁</li>\n<li>最大大小由max_heap_table_size参数决定</li>\n</ul>\n<p>临时表：也存在内存中，但是只限于当前会话</p>\n<p>memory数据易丢失，所以要求数据可再生</p>\n<p>适用场景:</p>\n<ul>\n<li>hash索引用于查找或者是映射表（邮编和地区的对应表）</li>\n<li>用于保存数据分析中产生的中间表</li>\n<li>用于缓存周期性聚合数据的结果表</li>\n</ul>\n<h5 id=\"Federated\"><a href=\"#Federated\" class=\"headerlink\" title=\"Federated\"></a>Federated</h5><p>特点:</p>\n<ul>\n<li>提供了访问远程MySQL服务器上表的方法</li>\n<li>本地不存储数据，数据全部放到远程服务器上</li>\n<li>本地需要保存表结构和远程服务器的连接信息</li>\n</ul>\n<p>默认禁止，启用需要再启动时增加federated参数</p>\n<p>创建表时添加connect=mysql://user_name[:password]@hostname[:port_num]/db_name/table_name</p>"},{"title":"Mysql - Mysql锁和事务","_content":"\nMysql锁和事务\n\n#### Mysql锁\n\n不同的存储引擎支持不同的锁机制,MyISAM和MEMORY存储引擎采用的是表级锁InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。\n\n\n- 表级锁:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。\n- 行级锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。\n- 页面锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n\n表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如OLAP系统   \n\n行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用    \n\n\n<!-- more -->\n\n##### MyISAM的表锁\n\n语法：\n\n```sql\n-- 读锁\nlock table table_name read\n\n-- 写锁\nlock table table_name write\n\n--释放锁\nunlock tables\n```\n\n特点：\n\n读锁：会阻塞其他用户对该表的写请求，当前session访问其他表也会报错。\n写锁：阻塞其他表的读和写，当前session curd都可以，访问其他表也会报错。\n\n##### InnoDb行锁\n\n语法：\n\n```sql\nbegin\n-- 读锁\nselect  *  from table_name where  条件  lock in share mode\n\n-- 写锁\nselect *  from table_name  where 条件 for update\n\n--释放锁\ncommit/rollback\n```\n\n1. 两个事务不能锁同一个索引。开启一个新事务的时候会解锁表。\n2. insert ，delete ， update在事务中都会自动默认加上排它锁。\n3. 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。\n\n\n\n问：    \n系统运行一段时间，数据量已经很大，这时候系统升级，有张表A需要增加个字段，并发量白天晚上都很大，请问怎么修改表结构   \n\n答：    \n\n1. 首先创建一个和你要执行的alter操作的表一样的空的表结构。\n2. 执行我们赋予的表结构的修改，然后copy原表中的数据到新表里面。\n3. 在原表上创建一个触发器在数据copy的过程中，将原表的更新数据的操作全部更新到新的表中来。 \n4. copy完成之后，用rename table 新表代替原表，默认删除原表。\n\n可使用操作工具完成操作工具(需安装)：pt-online-schema-change\n\n```sh\n# 下载安装perl环境  http://www.perl.org/get.html \n# 下载percona-toolkit工具集合  https://www.percona.com/doc/percona-toolkit\n# 安装环境\nppm install DBI \n\nppm install DBD::mysql \n\n# 执行\npt-online-schema-change h=127.0.0.1,u=root,D=mysqldemo,t=product_info --alter \"modify product_name varchar(150) not null default '' \" --execute\n```\n\n\n#### MySql事务\n\n语法：\n\n```sql\n\n--开启事务\nbegin \n\nSTART TRANSACTION（推荐）\n\nbegin work \n\n-- 事务回滚 可配合还原点使用savepoint\nrollback\n\n-- 事务提交  \ncommit \n\n-- 查看数据库下面是否支持事务（InnoDB支持）？\nshow engines;\n\n-- 查看mysql当前默认的存储引擎？\nshow variables like '%storage_engine%';\n\n-- 查看某张表的存储引擎？\nshow create table 表名 ;\n\n-- 对于表的存储结构的修改？\nCreate table .... type=InnoDB \nAlter table table_name type=InnoDB;\n\n```\n\n##### 事务的特性ACID\n\n- 原子性 全部成功或者全部失败\n- 一致性 数据的完整行没有被破坏\n- 隔离性 各个事务间不能相互影响\n- 持久性 已提交的数据就会永久保存在数据库\n\n##### 事务的隔离级别\n\n\n\n事务并发问题\n\n1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。\n3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n\n语法：\n\n```sql\nset SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED\n```\n\n- 未提交读（READ UNCOMMITED）存在脏读\n\n\t级别最低，效率最快。事务A在修改数据时，未提交事务B也能看见修改后的数据。存在脏读、不可重复读、幻读。\n\n- 已提交读 （READ COMMITED）存在不可重复读\n\n\t事务A在修改数据时，未提交事务B不能看见修改后的数据，事务A提交后事务B能看见。存在不可重复读、幻读。\n\n- 可重复读（REPEATABLE READ）存在幻读\n\n\t事务B刚开始查询到的数据不会修改，不管数据有没有被其他数据修改。存在幻读。如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。\n\n\n- 可串行化（SERIALIZABLE）\n\n\t级别最高，效率最低。会锁表。\n\n隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。mysql默认的事务隔离级别为repeatable-read。\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mysql-锁和事务.md","raw":"---\ntitle: Mysql - Mysql锁和事务\ntags:\n  - Mysql\n---\n\nMysql锁和事务\n\n#### Mysql锁\n\n不同的存储引擎支持不同的锁机制,MyISAM和MEMORY存储引擎采用的是表级锁InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。\n\n\n- 表级锁:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。\n- 行级锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。\n- 页面锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n\n表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如OLAP系统   \n\n行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用    \n\n\n<!-- more -->\n\n##### MyISAM的表锁\n\n语法：\n\n```sql\n-- 读锁\nlock table table_name read\n\n-- 写锁\nlock table table_name write\n\n--释放锁\nunlock tables\n```\n\n特点：\n\n读锁：会阻塞其他用户对该表的写请求，当前session访问其他表也会报错。\n写锁：阻塞其他表的读和写，当前session curd都可以，访问其他表也会报错。\n\n##### InnoDb行锁\n\n语法：\n\n```sql\nbegin\n-- 读锁\nselect  *  from table_name where  条件  lock in share mode\n\n-- 写锁\nselect *  from table_name  where 条件 for update\n\n--释放锁\ncommit/rollback\n```\n\n1. 两个事务不能锁同一个索引。开启一个新事务的时候会解锁表。\n2. insert ，delete ， update在事务中都会自动默认加上排它锁。\n3. 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。\n\n\n\n问：    \n系统运行一段时间，数据量已经很大，这时候系统升级，有张表A需要增加个字段，并发量白天晚上都很大，请问怎么修改表结构   \n\n答：    \n\n1. 首先创建一个和你要执行的alter操作的表一样的空的表结构。\n2. 执行我们赋予的表结构的修改，然后copy原表中的数据到新表里面。\n3. 在原表上创建一个触发器在数据copy的过程中，将原表的更新数据的操作全部更新到新的表中来。 \n4. copy完成之后，用rename table 新表代替原表，默认删除原表。\n\n可使用操作工具完成操作工具(需安装)：pt-online-schema-change\n\n```sh\n# 下载安装perl环境  http://www.perl.org/get.html \n# 下载percona-toolkit工具集合  https://www.percona.com/doc/percona-toolkit\n# 安装环境\nppm install DBI \n\nppm install DBD::mysql \n\n# 执行\npt-online-schema-change h=127.0.0.1,u=root,D=mysqldemo,t=product_info --alter \"modify product_name varchar(150) not null default '' \" --execute\n```\n\n\n#### MySql事务\n\n语法：\n\n```sql\n\n--开启事务\nbegin \n\nSTART TRANSACTION（推荐）\n\nbegin work \n\n-- 事务回滚 可配合还原点使用savepoint\nrollback\n\n-- 事务提交  \ncommit \n\n-- 查看数据库下面是否支持事务（InnoDB支持）？\nshow engines;\n\n-- 查看mysql当前默认的存储引擎？\nshow variables like '%storage_engine%';\n\n-- 查看某张表的存储引擎？\nshow create table 表名 ;\n\n-- 对于表的存储结构的修改？\nCreate table .... type=InnoDB \nAlter table table_name type=InnoDB;\n\n```\n\n##### 事务的特性ACID\n\n- 原子性 全部成功或者全部失败\n- 一致性 数据的完整行没有被破坏\n- 隔离性 各个事务间不能相互影响\n- 持久性 已提交的数据就会永久保存在数据库\n\n##### 事务的隔离级别\n\n\n\n事务并发问题\n\n1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。\n3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n\n语法：\n\n```sql\nset SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED\n```\n\n- 未提交读（READ UNCOMMITED）存在脏读\n\n\t级别最低，效率最快。事务A在修改数据时，未提交事务B也能看见修改后的数据。存在脏读、不可重复读、幻读。\n\n- 已提交读 （READ COMMITED）存在不可重复读\n\n\t事务A在修改数据时，未提交事务B不能看见修改后的数据，事务A提交后事务B能看见。存在不可重复读、幻读。\n\n- 可重复读（REPEATABLE READ）存在幻读\n\n\t事务B刚开始查询到的数据不会修改，不管数据有没有被其他数据修改。存在幻读。如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。\n\n\n- 可串行化（SERIALIZABLE）\n\n\t级别最高，效率最低。会锁表。\n\n隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。mysql默认的事务隔离级别为repeatable-read。\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mysql-锁和事务","published":1,"date":"2025-02-12T08:28:16.459Z","updated":"2025-02-12T08:28:16.459Z","_id":"clhua15a100099gj7e3r214qi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Mysql锁和事务</p>\n<h4 id=\"Mysql锁\"><a href=\"#Mysql锁\" class=\"headerlink\" title=\"Mysql锁\"></a>Mysql锁</h4><p>不同的存储引擎支持不同的锁机制,MyISAM和MEMORY存储引擎采用的是表级锁InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。</p>\n<ul>\n<li>表级锁:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>\n<li>行级锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>\n<li>页面锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>\n</ul>\n<p>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如OLAP系统   </p>\n<p>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用    </p>\n<a id=\"more\"></a>\n<h5 id=\"MyISAM的表锁\"><a href=\"#MyISAM的表锁\" class=\"headerlink\" title=\"MyISAM的表锁\"></a>MyISAM的表锁</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 读锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">read</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 写锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span> <span class=\"keyword\">table</span> table_name write</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--释放锁</span></span><br><span class=\"line\"><span class=\"keyword\">unlock</span> <span class=\"keyword\">tables</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<p>读锁：会阻塞其他用户对该表的写请求，当前session访问其他表也会报错。<br>写锁：阻塞其他表的读和写，当前session curd都可以，访问其他表也会报错。</p>\n<h5 id=\"InnoDb行锁\"><a href=\"#InnoDb行锁\" class=\"headerlink\" title=\"InnoDb行锁\"></a>InnoDb行锁</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"><span class=\"comment\">-- 读锁</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>  *  <span class=\"keyword\">from</span> table_name <span class=\"keyword\">where</span>  条件  <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 写锁</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> *  <span class=\"keyword\">from</span> table_name  <span class=\"keyword\">where</span> 条件 <span class=\"keyword\">for</span> <span class=\"keyword\">update</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--释放锁</span></span><br><span class=\"line\"><span class=\"keyword\">commit</span>/<span class=\"keyword\">rollback</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>两个事务不能锁同一个索引。开启一个新事务的时候会解锁表。</li>\n<li>insert ，delete ， update在事务中都会自动默认加上排它锁。</li>\n<li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</li>\n</ol>\n<p>问：<br>系统运行一段时间，数据量已经很大，这时候系统升级，有张表A需要增加个字段，并发量白天晚上都很大，请问怎么修改表结构   </p>\n<p>答：    </p>\n<ol>\n<li>首先创建一个和你要执行的alter操作的表一样的空的表结构。</li>\n<li>执行我们赋予的表结构的修改，然后copy原表中的数据到新表里面。</li>\n<li>在原表上创建一个触发器在数据copy的过程中，将原表的更新数据的操作全部更新到新的表中来。 </li>\n<li>copy完成之后，用rename table 新表代替原表，默认删除原表。</li>\n</ol>\n<p>可使用操作工具完成操作工具(需安装)：pt-online-schema-change</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载安装perl环境  http://www.perl.org/get.html </span></span><br><span class=\"line\"><span class=\"comment\"># 下载percona-toolkit工具集合  https://www.percona.com/doc/percona-toolkit</span></span><br><span class=\"line\"><span class=\"comment\"># 安装环境</span></span><br><span class=\"line\">ppm install DBI </span><br><span class=\"line\"></span><br><span class=\"line\">ppm install DBD::mysql </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行</span></span><br><span class=\"line\">pt-online-schema-change h=127.0.0.1,u=root,D=mysqldemo,t=product_info --alter <span class=\"string\">\"modify product_name varchar(150) not null default '' \"</span> --execute</span><br></pre></td></tr></table></figure>\n<h4 id=\"MySql事务\"><a href=\"#MySql事务\" class=\"headerlink\" title=\"MySql事务\"></a>MySql事务</h4><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--开启事务</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">START</span> <span class=\"keyword\">TRANSACTION</span>（推荐）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span> <span class=\"keyword\">work</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务回滚 可配合还原点使用savepoint</span></span><br><span class=\"line\"><span class=\"keyword\">rollback</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务提交  </span></span><br><span class=\"line\"><span class=\"keyword\">commit</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看数据库下面是否支持事务（InnoDB支持）？</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看mysql当前默认的存储引擎？</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'%storage_engine%'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看某张表的存储引擎？</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> 表名 ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 对于表的存储结构的修改？</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> .... <span class=\"keyword\">type</span>=<span class=\"keyword\">InnoDB</span> </span><br><span class=\"line\"><span class=\"keyword\">Alter</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">type</span>=<span class=\"keyword\">InnoDB</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"事务的特性ACID\"><a href=\"#事务的特性ACID\" class=\"headerlink\" title=\"事务的特性ACID\"></a>事务的特性ACID</h5><ul>\n<li>原子性 全部成功或者全部失败</li>\n<li>一致性 数据的完整行没有被破坏</li>\n<li>隔离性 各个事务间不能相互影响</li>\n<li>持久性 已提交的数据就会永久保存在数据库</li>\n</ul>\n<h5 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h5><p>事务并发问题</p>\n<ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">SESSION</span> <span class=\"keyword\">TRANSACTION</span> <span class=\"keyword\">ISOLATION</span> <span class=\"keyword\">LEVEL</span> <span class=\"keyword\">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>未提交读（READ UNCOMMITED）存在脏读</p>\n<p>  级别最低，效率最快。事务A在修改数据时，未提交事务B也能看见修改后的数据。存在脏读、不可重复读、幻读。</p>\n</li>\n<li><p>已提交读 （READ COMMITED）存在不可重复读</p>\n<p>  事务A在修改数据时，未提交事务B不能看见修改后的数据，事务A提交后事务B能看见。存在不可重复读、幻读。</p>\n</li>\n<li><p>可重复读（REPEATABLE READ）存在幻读</p>\n<p>  事务B刚开始查询到的数据不会修改，不管数据有没有被其他数据修改。存在幻读。如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。</p>\n</li>\n</ul>\n<ul>\n<li><p>可串行化（SERIALIZABLE）</p>\n<p>  级别最高，效率最低。会锁表。</p>\n</li>\n</ul>\n<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。mysql默认的事务隔离级别为repeatable-read。</p>\n","site":{"data":{}},"excerpt":"<p>Mysql锁和事务</p>\n<h4 id=\"Mysql锁\"><a href=\"#Mysql锁\" class=\"headerlink\" title=\"Mysql锁\"></a>Mysql锁</h4><p>不同的存储引擎支持不同的锁机制,MyISAM和MEMORY存储引擎采用的是表级锁InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。</p>\n<ul>\n<li>表级锁:开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>\n<li>行级锁:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>\n<li>页面锁:开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>\n</ul>\n<p>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如OLAP系统   </p>\n<p>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用    </p>","more":"<h5 id=\"MyISAM的表锁\"><a href=\"#MyISAM的表锁\" class=\"headerlink\" title=\"MyISAM的表锁\"></a>MyISAM的表锁</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 读锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">read</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 写锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span> <span class=\"keyword\">table</span> table_name write</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--释放锁</span></span><br><span class=\"line\"><span class=\"keyword\">unlock</span> <span class=\"keyword\">tables</span></span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<p>读锁：会阻塞其他用户对该表的写请求，当前session访问其他表也会报错。<br>写锁：阻塞其他表的读和写，当前session curd都可以，访问其他表也会报错。</p>\n<h5 id=\"InnoDb行锁\"><a href=\"#InnoDb行锁\" class=\"headerlink\" title=\"InnoDb行锁\"></a>InnoDb行锁</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"><span class=\"comment\">-- 读锁</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>  *  <span class=\"keyword\">from</span> table_name <span class=\"keyword\">where</span>  条件  <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 写锁</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> *  <span class=\"keyword\">from</span> table_name  <span class=\"keyword\">where</span> 条件 <span class=\"keyword\">for</span> <span class=\"keyword\">update</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--释放锁</span></span><br><span class=\"line\"><span class=\"keyword\">commit</span>/<span class=\"keyword\">rollback</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>两个事务不能锁同一个索引。开启一个新事务的时候会解锁表。</li>\n<li>insert ，delete ， update在事务中都会自动默认加上排它锁。</li>\n<li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</li>\n</ol>\n<p>问：<br>系统运行一段时间，数据量已经很大，这时候系统升级，有张表A需要增加个字段，并发量白天晚上都很大，请问怎么修改表结构   </p>\n<p>答：    </p>\n<ol>\n<li>首先创建一个和你要执行的alter操作的表一样的空的表结构。</li>\n<li>执行我们赋予的表结构的修改，然后copy原表中的数据到新表里面。</li>\n<li>在原表上创建一个触发器在数据copy的过程中，将原表的更新数据的操作全部更新到新的表中来。 </li>\n<li>copy完成之后，用rename table 新表代替原表，默认删除原表。</li>\n</ol>\n<p>可使用操作工具完成操作工具(需安装)：pt-online-schema-change</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载安装perl环境  http://www.perl.org/get.html </span></span><br><span class=\"line\"><span class=\"comment\"># 下载percona-toolkit工具集合  https://www.percona.com/doc/percona-toolkit</span></span><br><span class=\"line\"><span class=\"comment\"># 安装环境</span></span><br><span class=\"line\">ppm install DBI </span><br><span class=\"line\"></span><br><span class=\"line\">ppm install DBD::mysql </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行</span></span><br><span class=\"line\">pt-online-schema-change h=127.0.0.1,u=root,D=mysqldemo,t=product_info --alter <span class=\"string\">\"modify product_name varchar(150) not null default '' \"</span> --execute</span><br></pre></td></tr></table></figure>\n<h4 id=\"MySql事务\"><a href=\"#MySql事务\" class=\"headerlink\" title=\"MySql事务\"></a>MySql事务</h4><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--开启事务</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">START</span> <span class=\"keyword\">TRANSACTION</span>（推荐）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">begin</span> <span class=\"keyword\">work</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务回滚 可配合还原点使用savepoint</span></span><br><span class=\"line\"><span class=\"keyword\">rollback</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务提交  </span></span><br><span class=\"line\"><span class=\"keyword\">commit</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看数据库下面是否支持事务（InnoDB支持）？</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看mysql当前默认的存储引擎？</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'%storage_engine%'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看某张表的存储引擎？</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> 表名 ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 对于表的存储结构的修改？</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">table</span> .... <span class=\"keyword\">type</span>=<span class=\"keyword\">InnoDB</span> </span><br><span class=\"line\"><span class=\"keyword\">Alter</span> <span class=\"keyword\">table</span> table_name <span class=\"keyword\">type</span>=<span class=\"keyword\">InnoDB</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"事务的特性ACID\"><a href=\"#事务的特性ACID\" class=\"headerlink\" title=\"事务的特性ACID\"></a>事务的特性ACID</h5><ul>\n<li>原子性 全部成功或者全部失败</li>\n<li>一致性 数据的完整行没有被破坏</li>\n<li>隔离性 各个事务间不能相互影响</li>\n<li>持久性 已提交的数据就会永久保存在数据库</li>\n</ul>\n<h5 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h5><p>事务并发问题</p>\n<ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">SESSION</span> <span class=\"keyword\">TRANSACTION</span> <span class=\"keyword\">ISOLATION</span> <span class=\"keyword\">LEVEL</span> <span class=\"keyword\">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>未提交读（READ UNCOMMITED）存在脏读</p>\n<p>  级别最低，效率最快。事务A在修改数据时，未提交事务B也能看见修改后的数据。存在脏读、不可重复读、幻读。</p>\n</li>\n<li><p>已提交读 （READ COMMITED）存在不可重复读</p>\n<p>  事务A在修改数据时，未提交事务B不能看见修改后的数据，事务A提交后事务B能看见。存在不可重复读、幻读。</p>\n</li>\n<li><p>可重复读（REPEATABLE READ）存在幻读</p>\n<p>  事务B刚开始查询到的数据不会修改，不管数据有没有被其他数据修改。存在幻读。如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。</p>\n</li>\n</ul>\n<ul>\n<li><p>可串行化（SERIALIZABLE）</p>\n<p>  级别最高，效率最低。会锁表。</p>\n</li>\n</ul>\n<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。mysql默认的事务隔离级别为repeatable-read。</p>"},{"title":"Nginx - Location匹配规则 和 负载均衡","_content":"\nLocation匹配规则 和 负载均衡\n\n#### Location规则\n\n\n- 语法规则： location [=|~|~*|^~] /uri/ {… }\n\n\n```sh\nlocation / {\n         proxy_set_header Referer \"\";\n         proxy_pass http://manage/;\n       }\n```\n\n<!-- more -->\n\n- 首先匹配 =，其次匹配^~,其次是按文件中顺序的正则匹配，最后是交给通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n\n\n| 符号 | 含义 |\n|----|----|\n|=|开头表示精确匹配|\n|^~|^~开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）|\n|~|~开头表示区分大小写的正则匹配|\n|~*|~* 开头表示不区分大小写的正则匹配|\n|!~和!~*|!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则|\n|/|用户所使用的代理（一般为浏览器）|\n\n#### Nginx 负载均衡\n\n```sh\n# http模块\nupstream backend {\n      server localhost:3456 ;\n      server localhost:4567 ;\n      server localhost:5678 ;\n      server localhost:6789 ;\n    }\n\n# server模块\nlocation /api {\n         proxy_set_header Referer \"\";\n         proxy_pass http://backend/api;\n         client_max_body_size    30m;\n       }\n```\n\n负载均衡规则：\n\n- 轮询(默认)\n- weight\n\n```sh\nupstream nginx {\nserver 172.17.0.4:8081 weight=2;\nserver 172.17.0.5:8081 weight=1;\n}\n```\n\n- ip_hash 同一客户端的请求总是发往同一个后端服务器，可以解决session的问题。\n\n```sh\nupstream nginx {\nip_hash;\nserver 172.17.0.4:8081;\nserver 172.17.0.5:8081;\n}\n```\n\n#### location和rewrite进阶\n\n- nginx运行阶段：  rewrite 阶段、access 阶段以及 content 阶段\n- 不按代码顺序执行，是按阶段执行，顺序如下：\n\n例 先执行命中的所有rewrite层指令（下面的set），再执行access，再执行content（下面的echo）\n：\n\n```sh\nlocation  = / {\n        set $a 32;\n        echo $a;\n\n        set $a 64;\n        echo $a;\n}\n```\n\n输出两个64\n\n\n\n\n\n\n\n\n","source":"_posts/Nginx-Location匹配规则.md","raw":"---\ntitle: Nginx - Location匹配规则 和 负载均衡\ntags:\n  - Nginx\n---\n\nLocation匹配规则 和 负载均衡\n\n#### Location规则\n\n\n- 语法规则： location [=|~|~*|^~] /uri/ {… }\n\n\n```sh\nlocation / {\n         proxy_set_header Referer \"\";\n         proxy_pass http://manage/;\n       }\n```\n\n<!-- more -->\n\n- 首先匹配 =，其次匹配^~,其次是按文件中顺序的正则匹配，最后是交给通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n\n\n| 符号 | 含义 |\n|----|----|\n|=|开头表示精确匹配|\n|^~|^~开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）|\n|~|~开头表示区分大小写的正则匹配|\n|~*|~* 开头表示不区分大小写的正则匹配|\n|!~和!~*|!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则|\n|/|用户所使用的代理（一般为浏览器）|\n\n#### Nginx 负载均衡\n\n```sh\n# http模块\nupstream backend {\n      server localhost:3456 ;\n      server localhost:4567 ;\n      server localhost:5678 ;\n      server localhost:6789 ;\n    }\n\n# server模块\nlocation /api {\n         proxy_set_header Referer \"\";\n         proxy_pass http://backend/api;\n         client_max_body_size    30m;\n       }\n```\n\n负载均衡规则：\n\n- 轮询(默认)\n- weight\n\n```sh\nupstream nginx {\nserver 172.17.0.4:8081 weight=2;\nserver 172.17.0.5:8081 weight=1;\n}\n```\n\n- ip_hash 同一客户端的请求总是发往同一个后端服务器，可以解决session的问题。\n\n```sh\nupstream nginx {\nip_hash;\nserver 172.17.0.4:8081;\nserver 172.17.0.5:8081;\n}\n```\n\n#### location和rewrite进阶\n\n- nginx运行阶段：  rewrite 阶段、access 阶段以及 content 阶段\n- 不按代码顺序执行，是按阶段执行，顺序如下：\n\n例 先执行命中的所有rewrite层指令（下面的set），再执行access，再执行content（下面的echo）\n：\n\n```sh\nlocation  = / {\n        set $a 32;\n        echo $a;\n\n        set $a 64;\n        echo $a;\n}\n```\n\n输出两个64\n\n\n\n\n\n\n\n\n","slug":"Nginx-Location匹配规则","published":1,"date":"2025-02-12T08:28:16.459Z","updated":"2025-02-12T08:28:16.459Z","_id":"clhua15a4000b9gj7flwk208t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Location匹配规则 和 负载均衡</p>\n<h4 id=\"Location规则\"><a href=\"#Location规则\" class=\"headerlink\" title=\"Location规则\"></a>Location规则</h4><ul>\n<li>语法规则： location [=|~|~*|^~] /uri/ {… }</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://manage/;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>首先匹配 =，其次匹配^~,其次是按文件中顺序的正则匹配，最后是交给通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>开头表示精确匹配</td>\n</tr>\n<tr>\n<td>^~</td>\n<td>^~开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）</td>\n</tr>\n<tr>\n<td>~</td>\n<td>~开头表示区分大小写的正则匹配</td>\n</tr>\n<tr>\n<td>~*</td>\n<td>~* 开头表示不区分大小写的正则匹配</td>\n</tr>\n<tr>\n<td>!~和!~*</td>\n<td>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则</td>\n</tr>\n<tr>\n<td>/</td>\n<td>用户所使用的代理（一般为浏览器）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Nginx-负载均衡\"><a href=\"#Nginx-负载均衡\" class=\"headerlink\" title=\"Nginx 负载均衡\"></a>Nginx 负载均衡</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># http模块</span></span><br><span class=\"line\">upstream backend &#123;</span><br><span class=\"line\">      server localhost:3456 ;</span><br><span class=\"line\">      server localhost:4567 ;</span><br><span class=\"line\">      server localhost:5678 ;</span><br><span class=\"line\">      server localhost:6789 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># server模块</span></span><br><span class=\"line\">location /api &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://backend/api;</span><br><span class=\"line\">         client_max_body_size    30m;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>负载均衡规则：</p>\n<ul>\n<li>轮询(默认)</li>\n<li>weight</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream nginx &#123;</span><br><span class=\"line\">server 172.17.0.4:8081 weight=2;</span><br><span class=\"line\">server 172.17.0.5:8081 weight=1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ip_hash 同一客户端的请求总是发往同一个后端服务器，可以解决session的问题。</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream nginx &#123;</span><br><span class=\"line\">ip_hash;</span><br><span class=\"line\">server 172.17.0.4:8081;</span><br><span class=\"line\">server 172.17.0.5:8081;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"location和rewrite进阶\"><a href=\"#location和rewrite进阶\" class=\"headerlink\" title=\"location和rewrite进阶\"></a>location和rewrite进阶</h4><ul>\n<li>nginx运行阶段：  rewrite 阶段、access 阶段以及 content 阶段</li>\n<li>不按代码顺序执行，是按阶段执行，顺序如下：</li>\n</ul>\n<p>例 先执行命中的所有rewrite层指令（下面的set），再执行access，再执行content（下面的echo）<br>：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location  = / &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span> <span class=\"variable\">$a</span> 32;</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">set</span> <span class=\"variable\">$a</span> 64;</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出两个64</p>\n","site":{"data":{}},"excerpt":"<p>Location匹配规则 和 负载均衡</p>\n<h4 id=\"Location规则\"><a href=\"#Location规则\" class=\"headerlink\" title=\"Location规则\"></a>Location规则</h4><ul>\n<li>语法规则： location [=|~|~*|^~] /uri/ {… }</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://manage/;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>","more":"<ul>\n<li>首先匹配 =，其次匹配^~,其次是按文件中顺序的正则匹配，最后是交给通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>开头表示精确匹配</td>\n</tr>\n<tr>\n<td>^~</td>\n<td>^~开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）</td>\n</tr>\n<tr>\n<td>~</td>\n<td>~开头表示区分大小写的正则匹配</td>\n</tr>\n<tr>\n<td>~*</td>\n<td>~* 开头表示不区分大小写的正则匹配</td>\n</tr>\n<tr>\n<td>!~和!~*</td>\n<td>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则</td>\n</tr>\n<tr>\n<td>/</td>\n<td>用户所使用的代理（一般为浏览器）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Nginx-负载均衡\"><a href=\"#Nginx-负载均衡\" class=\"headerlink\" title=\"Nginx 负载均衡\"></a>Nginx 负载均衡</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># http模块</span></span><br><span class=\"line\">upstream backend &#123;</span><br><span class=\"line\">      server localhost:3456 ;</span><br><span class=\"line\">      server localhost:4567 ;</span><br><span class=\"line\">      server localhost:5678 ;</span><br><span class=\"line\">      server localhost:6789 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># server模块</span></span><br><span class=\"line\">location /api &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://backend/api;</span><br><span class=\"line\">         client_max_body_size    30m;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>负载均衡规则：</p>\n<ul>\n<li>轮询(默认)</li>\n<li>weight</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream nginx &#123;</span><br><span class=\"line\">server 172.17.0.4:8081 weight=2;</span><br><span class=\"line\">server 172.17.0.5:8081 weight=1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ip_hash 同一客户端的请求总是发往同一个后端服务器，可以解决session的问题。</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream nginx &#123;</span><br><span class=\"line\">ip_hash;</span><br><span class=\"line\">server 172.17.0.4:8081;</span><br><span class=\"line\">server 172.17.0.5:8081;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"location和rewrite进阶\"><a href=\"#location和rewrite进阶\" class=\"headerlink\" title=\"location和rewrite进阶\"></a>location和rewrite进阶</h4><ul>\n<li>nginx运行阶段：  rewrite 阶段、access 阶段以及 content 阶段</li>\n<li>不按代码顺序执行，是按阶段执行，顺序如下：</li>\n</ul>\n<p>例 先执行命中的所有rewrite层指令（下面的set），再执行access，再执行content（下面的echo）<br>：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location  = / &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span> <span class=\"variable\">$a</span> 32;</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">set</span> <span class=\"variable\">$a</span> 64;</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"variable\">$a</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出两个64</p>"},{"title":"Mysql - MySql慢查询和执行计划(重点)","_content":"\nMySql慢查询和执行计划\n\n#### MySql慢查询\n\n相关配置：\n\n```sql\nSHOW VARIABLES LIKE '%slow%'\n\n-- 开启或者关闭\nSET GLOBAL slow_query_log = 1\n\n-- 设置时间\nSET GLOBAL long_query_time = 10\n```\n\n- slow_query_log 启动停止技术慢查询日志\n- slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）\n- long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）\n- log_queries_not_using_indexes  是否记录未使用索引的SQL\n- log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】\n\n\t使用TABLE时慢sql会存在mysql.slow_log 不建议使用。\n\n<!-- more -->\n\n##### MySql慢查询分析工具\n\nmysqldumpslow:汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。\n\n语法：\n\n```sh\n#\n#\n# -s order (c,t,l,r,at,al,ar) \n#    c:总次数\n#    t:总时间\n#    l:锁的时间\n#    r:总数据行\n#    at,al,ar  :t,l,r平均数  【例如：at = 总时间/总次数】\n#    -t  top   指定取前面几天作为结果输出\n\nmysqldumpslow -s r -t 10 slow-mysql.log\n```\n\n其它工具(需要安装)：pt_query_digest\n\n语法：\n\n```sh\npt-query-digest  --explain h=127.0.0.1, u=root,p=password slow-mysql.log\n\n```\n\n#### MySql执行计划\n\n\n##### 索引\n\n语法：\n\n```sql\n--查看索引\nSHOW INDEX FROM table_name\n\n--创建索引\nCREATE  [UNIQUE ] INDEX indexName ON mytable(columnname(length));\nALTER TABLE 表名 ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) \n\n--删除索引\nDROP INDEX [indexName] ON mytable;\n\n```\n\n分类：\n\n- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引\n- 唯一索引：索引列的值必须唯一，但允许有空值\n- 复合索引：即一个索引包含多个列\n- 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。\n- 非聚簇索引：不是聚簇索引，就是非聚簇索引\n\n\n##### 执行计划\n\n语法：\n\n```sql\nExplain + SQL语句\n```\n\n<font color=red>执行计划包含的信息(重点)</font>:\n\n- id 查询顺序\n\n\tselect查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序。id相同，执行顺序由上至下。id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。\n\n- select_type 查询类型\n\n\t- SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION\n\t- PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为\n\t- SUBQUERY：在SELECT或WHERE列表中包含了子查询\n\t- DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。\n\t- UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED\n\t- UNION RESULT：从UNION表获取结果的SELECT\n\n- table\n- type(重要)\n\n\tsystem>const>eq_ref>ref>range>index>ALL\t\t\n\tsystem：表只有一行记录\t\t\n\tconst：表示通过索引一次就找到了\t\t\n\teq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描\t\t\n\tref：非唯一性索引扫描，返回匹配某个单独值的所有行.\t\t\n\trange：范围查询\t\t\n\tindex：查询索引列\t\t\n\tall：全表扫描\t\t\n\n- possible_keys 可能用到的索引\n- key 实际用到的索引\n- key_len 索引中使用的字节数\n\t\n\tkey_len显示的值为索引字段的最大可能长度，并非实际使用长度。在不损失精确性的情况下，长度越短越好。如果是联合索引，索引的大小代表使用索引的程度，如果太小了就代表了部分字段没有使用到索引。\t\t\n\tlatin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）\t\t\n\t字段可为空，长度+1，varchar类型+2\t\t\n\tdatetime类型在5.6中字段长度是5个字节，datetime类型在5.5中字段长度是8个字节 \t\t\n\tNULL都需要1个字节的额外空间,所以索引字段最好不要为NULL，因为NULL让统计更加复杂并且需要额外的存储空间。\t\t\t\n\n- ref 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值\n- rows 扫描的行数，越小越好\n- Extra(重要) 额外信息\n\n\t- Using filesort  使用一个外部的索引排序，需要优化\n\t- Using temporary 使用了临时表\n\t- USING index 使用了覆盖索引，避免访问了表的数据行，效率不错！\n\t- Using where 使用了where条件\n\t- Using join buffer 使用联合查询\n\t- Impossible where where后面的条件一定是false\n\n \n\n\n\n\n\n\n\n\n\n","source":"_posts/Mysql-慢查询和执行计划.md","raw":"---\ntitle: Mysql - MySql慢查询和执行计划(重点)\ntags:\n  - Mysql\n---\n\nMySql慢查询和执行计划\n\n#### MySql慢查询\n\n相关配置：\n\n```sql\nSHOW VARIABLES LIKE '%slow%'\n\n-- 开启或者关闭\nSET GLOBAL slow_query_log = 1\n\n-- 设置时间\nSET GLOBAL long_query_time = 10\n```\n\n- slow_query_log 启动停止技术慢查询日志\n- slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）\n- long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）\n- log_queries_not_using_indexes  是否记录未使用索引的SQL\n- log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】\n\n\t使用TABLE时慢sql会存在mysql.slow_log 不建议使用。\n\n<!-- more -->\n\n##### MySql慢查询分析工具\n\nmysqldumpslow:汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。\n\n语法：\n\n```sh\n#\n#\n# -s order (c,t,l,r,at,al,ar) \n#    c:总次数\n#    t:总时间\n#    l:锁的时间\n#    r:总数据行\n#    at,al,ar  :t,l,r平均数  【例如：at = 总时间/总次数】\n#    -t  top   指定取前面几天作为结果输出\n\nmysqldumpslow -s r -t 10 slow-mysql.log\n```\n\n其它工具(需要安装)：pt_query_digest\n\n语法：\n\n```sh\npt-query-digest  --explain h=127.0.0.1, u=root,p=password slow-mysql.log\n\n```\n\n#### MySql执行计划\n\n\n##### 索引\n\n语法：\n\n```sql\n--查看索引\nSHOW INDEX FROM table_name\n\n--创建索引\nCREATE  [UNIQUE ] INDEX indexName ON mytable(columnname(length));\nALTER TABLE 表名 ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) \n\n--删除索引\nDROP INDEX [indexName] ON mytable;\n\n```\n\n分类：\n\n- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引\n- 唯一索引：索引列的值必须唯一，但允许有空值\n- 复合索引：即一个索引包含多个列\n- 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。\n- 非聚簇索引：不是聚簇索引，就是非聚簇索引\n\n\n##### 执行计划\n\n语法：\n\n```sql\nExplain + SQL语句\n```\n\n<font color=red>执行计划包含的信息(重点)</font>:\n\n- id 查询顺序\n\n\tselect查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序。id相同，执行顺序由上至下。id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。\n\n- select_type 查询类型\n\n\t- SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION\n\t- PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为\n\t- SUBQUERY：在SELECT或WHERE列表中包含了子查询\n\t- DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。\n\t- UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED\n\t- UNION RESULT：从UNION表获取结果的SELECT\n\n- table\n- type(重要)\n\n\tsystem>const>eq_ref>ref>range>index>ALL\t\t\n\tsystem：表只有一行记录\t\t\n\tconst：表示通过索引一次就找到了\t\t\n\teq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描\t\t\n\tref：非唯一性索引扫描，返回匹配某个单独值的所有行.\t\t\n\trange：范围查询\t\t\n\tindex：查询索引列\t\t\n\tall：全表扫描\t\t\n\n- possible_keys 可能用到的索引\n- key 实际用到的索引\n- key_len 索引中使用的字节数\n\t\n\tkey_len显示的值为索引字段的最大可能长度，并非实际使用长度。在不损失精确性的情况下，长度越短越好。如果是联合索引，索引的大小代表使用索引的程度，如果太小了就代表了部分字段没有使用到索引。\t\t\n\tlatin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）\t\t\n\t字段可为空，长度+1，varchar类型+2\t\t\n\tdatetime类型在5.6中字段长度是5个字节，datetime类型在5.5中字段长度是8个字节 \t\t\n\tNULL都需要1个字节的额外空间,所以索引字段最好不要为NULL，因为NULL让统计更加复杂并且需要额外的存储空间。\t\t\t\n\n- ref 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值\n- rows 扫描的行数，越小越好\n- Extra(重要) 额外信息\n\n\t- Using filesort  使用一个外部的索引排序，需要优化\n\t- Using temporary 使用了临时表\n\t- USING index 使用了覆盖索引，避免访问了表的数据行，效率不错！\n\t- Using where 使用了where条件\n\t- Using join buffer 使用联合查询\n\t- Impossible where where后面的条件一定是false\n\n \n\n\n\n\n\n\n\n\n\n","slug":"Mysql-慢查询和执行计划","published":1,"date":"2025-02-12T08:28:16.458Z","updated":"2025-02-12T08:28:16.458Z","_id":"clhua15a7000f9gj7kcahn1nb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>MySql慢查询和执行计划</p>\n<h4 id=\"MySql慢查询\"><a href=\"#MySql慢查询\" class=\"headerlink\" title=\"MySql慢查询\"></a>MySql慢查询</h4><p>相关配置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">VARIABLES</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">'%slow%'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 开启或者关闭</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> slow_query_log = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 设置时间</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> long_query_time = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>slow_query_log 启动停止技术慢查询日志</li>\n<li>slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</li>\n<li>long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）</li>\n<li>log_queries_not_using_indexes  是否记录未使用索引的SQL</li>\n<li><p>log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】</p>\n<p>  使用TABLE时慢sql会存在mysql.slow_log 不建议使用。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"MySql慢查询分析工具\"><a href=\"#MySql慢查询分析工具\" class=\"headerlink\" title=\"MySql慢查询分析工具\"></a>MySql慢查询分析工具</h5><p>mysqldumpslow:汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。</p>\n<p>语法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># -s order (c,t,l,r,at,al,ar) </span></span><br><span class=\"line\"><span class=\"comment\">#    c:总次数</span></span><br><span class=\"line\"><span class=\"comment\">#    t:总时间</span></span><br><span class=\"line\"><span class=\"comment\">#    l:锁的时间</span></span><br><span class=\"line\"><span class=\"comment\">#    r:总数据行</span></span><br><span class=\"line\"><span class=\"comment\">#    at,al,ar  :t,l,r平均数  【例如：at = 总时间/总次数】</span></span><br><span class=\"line\"><span class=\"comment\">#    -t  top   指定取前面几天作为结果输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">mysqldumpslow -s r -t 10 slow-mysql.log</span><br></pre></td></tr></table></figure>\n<p>其它工具(需要安装)：pt_query_digest</p>\n<p>语法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pt-query-digest  --explain h=127.0.0.1, u=root,p=password slow-mysql.log</span><br></pre></td></tr></table></figure>\n<h4 id=\"MySql执行计划\"><a href=\"#MySql执行计划\" class=\"headerlink\" title=\"MySql执行计划\"></a>MySql执行计划</h4><h5 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--查看索引</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span>  [<span class=\"keyword\">UNIQUE</span> ] <span class=\"keyword\">INDEX</span> indexName <span class=\"keyword\">ON</span> mytable(columnname(<span class=\"keyword\">length</span>));</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span>  [<span class=\"keyword\">UNIQUE</span> ]  <span class=\"keyword\">INDEX</span> [indexName] <span class=\"keyword\">ON</span> (columnname(<span class=\"keyword\">length</span>)) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--删除索引</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> [indexName] <span class=\"keyword\">ON</span> mytable;</span><br></pre></td></tr></table></figure>\n<p>分类：</p>\n<ul>\n<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值</li>\n<li>复合索引：即一个索引包含多个列</li>\n<li>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</li>\n<li>非聚簇索引：不是聚簇索引，就是非聚簇索引</li>\n</ul>\n<h5 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Explain</span> + <span class=\"keyword\">SQL</span>语句</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">执行计划包含的信息(重点)</font>:</p>\n<ul>\n<li><p>id 查询顺序</p>\n<p>  select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序。id相同，执行顺序由上至下。id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。</p>\n</li>\n<li><p>select_type 查询类型</p>\n<ul>\n<li>SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION</li>\n<li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为</li>\n<li>SUBQUERY：在SELECT或WHERE列表中包含了子查询</li>\n<li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。</li>\n<li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li>\n<li>UNION RESULT：从UNION表获取结果的SELECT</li>\n</ul>\n</li>\n<li><p>table</p>\n</li>\n<li><p>type(重要)</p>\n<p>  system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL<br>  system：表只有一行记录<br>  const：表示通过索引一次就找到了<br>  eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描<br>  ref：非唯一性索引扫描，返回匹配某个单独值的所有行.<br>  range：范围查询<br>  index：查询索引列<br>  all：全表扫描        </p>\n</li>\n<li><p>possible_keys 可能用到的索引</p>\n</li>\n<li>key 实际用到的索引</li>\n<li><p>key_len 索引中使用的字节数</p>\n<p>  key_len显示的值为索引字段的最大可能长度，并非实际使用长度。在不损失精确性的情况下，长度越短越好。如果是联合索引，索引的大小代表使用索引的程度，如果太小了就代表了部分字段没有使用到索引。<br>  latin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）<br>  字段可为空，长度+1，varchar类型+2<br>  datetime类型在5.6中字段长度是5个字节，datetime类型在5.5中字段长度是8个字节<br>  NULL都需要1个字节的额外空间,所以索引字段最好不要为NULL，因为NULL让统计更加复杂并且需要额外的存储空间。            </p>\n</li>\n<li><p>ref 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>\n</li>\n<li>rows 扫描的行数，越小越好</li>\n<li><p>Extra(重要) 额外信息</p>\n<ul>\n<li>Using filesort  使用一个外部的索引排序，需要优化</li>\n<li>Using temporary 使用了临时表</li>\n<li>USING index 使用了覆盖索引，避免访问了表的数据行，效率不错！</li>\n<li>Using where 使用了where条件</li>\n<li>Using join buffer 使用联合查询</li>\n<li>Impossible where where后面的条件一定是false</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>MySql慢查询和执行计划</p>\n<h4 id=\"MySql慢查询\"><a href=\"#MySql慢查询\" class=\"headerlink\" title=\"MySql慢查询\"></a>MySql慢查询</h4><p>相关配置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">VARIABLES</span> <span class=\"keyword\">LIKE</span> <span class=\"string\">'%slow%'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 开启或者关闭</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> slow_query_log = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 设置时间</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> <span class=\"keyword\">GLOBAL</span> long_query_time = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>slow_query_log 启动停止技术慢查询日志</li>\n<li>slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</li>\n<li>long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）</li>\n<li>log_queries_not_using_indexes  是否记录未使用索引的SQL</li>\n<li><p>log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】</p>\n<p>  使用TABLE时慢sql会存在mysql.slow_log 不建议使用。</p>\n</li>\n</ul>","more":"<h5 id=\"MySql慢查询分析工具\"><a href=\"#MySql慢查询分析工具\" class=\"headerlink\" title=\"MySql慢查询分析工具\"></a>MySql慢查询分析工具</h5><p>mysqldumpslow:汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。</p>\n<p>语法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># -s order (c,t,l,r,at,al,ar) </span></span><br><span class=\"line\"><span class=\"comment\">#    c:总次数</span></span><br><span class=\"line\"><span class=\"comment\">#    t:总时间</span></span><br><span class=\"line\"><span class=\"comment\">#    l:锁的时间</span></span><br><span class=\"line\"><span class=\"comment\">#    r:总数据行</span></span><br><span class=\"line\"><span class=\"comment\">#    at,al,ar  :t,l,r平均数  【例如：at = 总时间/总次数】</span></span><br><span class=\"line\"><span class=\"comment\">#    -t  top   指定取前面几天作为结果输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">mysqldumpslow -s r -t 10 slow-mysql.log</span><br></pre></td></tr></table></figure>\n<p>其它工具(需要安装)：pt_query_digest</p>\n<p>语法：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pt-query-digest  --explain h=127.0.0.1, u=root,p=password slow-mysql.log</span><br></pre></td></tr></table></figure>\n<h4 id=\"MySql执行计划\"><a href=\"#MySql执行计划\" class=\"headerlink\" title=\"MySql执行计划\"></a>MySql执行计划</h4><h5 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--查看索引</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">INDEX</span> <span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--创建索引</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span>  [<span class=\"keyword\">UNIQUE</span> ] <span class=\"keyword\">INDEX</span> indexName <span class=\"keyword\">ON</span> mytable(columnname(<span class=\"keyword\">length</span>));</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span>  [<span class=\"keyword\">UNIQUE</span> ]  <span class=\"keyword\">INDEX</span> [indexName] <span class=\"keyword\">ON</span> (columnname(<span class=\"keyword\">length</span>)) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--删除索引</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> [indexName] <span class=\"keyword\">ON</span> mytable;</span><br></pre></td></tr></table></figure>\n<p>分类：</p>\n<ul>\n<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值</li>\n<li>复合索引：即一个索引包含多个列</li>\n<li>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</li>\n<li>非聚簇索引：不是聚簇索引，就是非聚簇索引</li>\n</ul>\n<h5 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h5><p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Explain</span> + <span class=\"keyword\">SQL</span>语句</span><br></pre></td></tr></table></figure>\n<p><font color=\"red\">执行计划包含的信息(重点)</font>:</p>\n<ul>\n<li><p>id 查询顺序</p>\n<p>  select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序。id相同，执行顺序由上至下。id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。</p>\n</li>\n<li><p>select_type 查询类型</p>\n<ul>\n<li>SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION</li>\n<li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为</li>\n<li>SUBQUERY：在SELECT或WHERE列表中包含了子查询</li>\n<li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。</li>\n<li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li>\n<li>UNION RESULT：从UNION表获取结果的SELECT</li>\n</ul>\n</li>\n<li><p>table</p>\n</li>\n<li><p>type(重要)</p>\n<p>  system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL<br>  system：表只有一行记录<br>  const：表示通过索引一次就找到了<br>  eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描<br>  ref：非唯一性索引扫描，返回匹配某个单独值的所有行.<br>  range：范围查询<br>  index：查询索引列<br>  all：全表扫描        </p>\n</li>\n<li><p>possible_keys 可能用到的索引</p>\n</li>\n<li>key 实际用到的索引</li>\n<li><p>key_len 索引中使用的字节数</p>\n<p>  key_len显示的值为索引字段的最大可能长度，并非实际使用长度。在不损失精确性的情况下，长度越短越好。如果是联合索引，索引的大小代表使用索引的程度，如果太小了就代表了部分字段没有使用到索引。<br>  latin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）<br>  字段可为空，长度+1，varchar类型+2<br>  datetime类型在5.6中字段长度是5个字节，datetime类型在5.5中字段长度是8个字节<br>  NULL都需要1个字节的额外空间,所以索引字段最好不要为NULL，因为NULL让统计更加复杂并且需要额外的存储空间。            </p>\n</li>\n<li><p>ref 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>\n</li>\n<li>rows 扫描的行数，越小越好</li>\n<li><p>Extra(重要) 额外信息</p>\n<ul>\n<li>Using filesort  使用一个外部的索引排序，需要优化</li>\n<li>Using temporary 使用了临时表</li>\n<li>USING index 使用了覆盖索引，避免访问了表的数据行，效率不错！</li>\n<li>Using where 使用了where条件</li>\n<li>Using join buffer 使用联合查询</li>\n<li>Impossible where where后面的条件一定是false</li>\n</ul>\n</li>\n</ul>"},{"title":"Nginx - location流程 和 rewirte","_content":"\nLocation路径传递\n\n#### rewrite使用\n\n语法:rewrite regex replacement [flag];  flag=【break/last/redirect/permanent】 \n\n- regex 是正则表达式\n- replacement 是替换值，新值\n- flag -- 是处理标志\n\nbreak/last 内部重定向，换path值     \nbreak标记，停止执行后续命令。for（）{break}     \nlast标记，会引发location重新匹配。for（）{continue;} 不要轻易使用last标签    \n当有flag值的时候，rewrite层面的命令会中断。last会引发location重匹配   \n当没有flag值的时候，rewrite还会往下走，最后一个rewrite覆盖前面的。再引发location重匹配    \n\n<!-- more -->\n\n#### proxy_pass 路径传递\n\n- 通过url中【ip/域名+port】匹配server之后，携带后面path?params进入location逻辑\n- location匹配后，path = 匹配中的path1 + 剩余path2\n\n![路径传递](http://image.tupelo.top/root-alias.png)\n\n\n\n\n\n\n\n\n","source":"_posts/Nginx-location-rewrite.md","raw":"---\ntitle: Nginx - location流程 和 rewirte\ntags:\n  - Nginx\n---\n\nLocation路径传递\n\n#### rewrite使用\n\n语法:rewrite regex replacement [flag];  flag=【break/last/redirect/permanent】 \n\n- regex 是正则表达式\n- replacement 是替换值，新值\n- flag -- 是处理标志\n\nbreak/last 内部重定向，换path值     \nbreak标记，停止执行后续命令。for（）{break}     \nlast标记，会引发location重新匹配。for（）{continue;} 不要轻易使用last标签    \n当有flag值的时候，rewrite层面的命令会中断。last会引发location重匹配   \n当没有flag值的时候，rewrite还会往下走，最后一个rewrite覆盖前面的。再引发location重匹配    \n\n<!-- more -->\n\n#### proxy_pass 路径传递\n\n- 通过url中【ip/域名+port】匹配server之后，携带后面path?params进入location逻辑\n- location匹配后，path = 匹配中的path1 + 剩余path2\n\n![路径传递](http://image.tupelo.top/root-alias.png)\n\n\n\n\n\n\n\n\n","slug":"Nginx-location-rewrite","published":1,"date":"2025-02-12T08:28:16.459Z","updated":"2025-02-12T08:28:16.459Z","_id":"clhua15a8000h9gj7oognj8oq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Location路径传递</p>\n<h4 id=\"rewrite使用\"><a href=\"#rewrite使用\" class=\"headerlink\" title=\"rewrite使用\"></a>rewrite使用</h4><p>语法:rewrite regex replacement [flag];  flag=【break/last/redirect/permanent】 </p>\n<ul>\n<li>regex 是正则表达式</li>\n<li>replacement 是替换值，新值</li>\n<li>flag – 是处理标志</li>\n</ul>\n<p>break/last 内部重定向，换path值<br>break标记，停止执行后续命令。for（）{break}<br>last标记，会引发location重新匹配。for（）{continue;} 不要轻易使用last标签<br>当有flag值的时候，rewrite层面的命令会中断。last会引发location重匹配<br>当没有flag值的时候，rewrite还会往下走，最后一个rewrite覆盖前面的。再引发location重匹配    </p>\n<a id=\"more\"></a>\n<h4 id=\"proxy-pass-路径传递\"><a href=\"#proxy-pass-路径传递\" class=\"headerlink\" title=\"proxy_pass 路径传递\"></a>proxy_pass 路径传递</h4><ul>\n<li>通过url中【ip/域名+port】匹配server之后，携带后面path?params进入location逻辑</li>\n<li>location匹配后，path = 匹配中的path1 + 剩余path2</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/root-alias.png\" alt=\"路径传递\"></p>\n","site":{"data":{}},"excerpt":"<p>Location路径传递</p>\n<h4 id=\"rewrite使用\"><a href=\"#rewrite使用\" class=\"headerlink\" title=\"rewrite使用\"></a>rewrite使用</h4><p>语法:rewrite regex replacement [flag];  flag=【break/last/redirect/permanent】 </p>\n<ul>\n<li>regex 是正则表达式</li>\n<li>replacement 是替换值，新值</li>\n<li>flag – 是处理标志</li>\n</ul>\n<p>break/last 内部重定向，换path值<br>break标记，停止执行后续命令。for（）{break}<br>last标记，会引发location重新匹配。for（）{continue;} 不要轻易使用last标签<br>当有flag值的时候，rewrite层面的命令会中断。last会引发location重匹配<br>当没有flag值的时候，rewrite还会往下走，最后一个rewrite覆盖前面的。再引发location重匹配    </p>","more":"<h4 id=\"proxy-pass-路径传递\"><a href=\"#proxy-pass-路径传递\" class=\"headerlink\" title=\"proxy_pass 路径传递\"></a>proxy_pass 路径传递</h4><ul>\n<li>通过url中【ip/域名+port】匹配server之后，携带后面path?params进入location逻辑</li>\n<li>location匹配后，path = 匹配中的path1 + 剩余path2</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/root-alias.png\" alt=\"路径传递\"></p>"},{"title":"Nginx简介","_content":"\nNginx简介\n\n#### Nginx作用\n\n- 路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器\n- 负载功能（与高并发高可用对应）：对后台服务器集群进行负载\n- 静态服务器（比tomcat性能高很多）：在mvvm模式中，充当文件读取职责\n\n> 总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器\n\n\n#### Nginx安装\n\n源码编译方式：\n\n```sh\n\n#一般系统中已经装了了make和g++，无须再装\nyum -y install autoconf automake make\nyum -y install gcc gcc-c++ \n\n#安装nginx依赖的库\nyum -y install pcre pcre-devel    \nyum -y install zlib zlib-devel\nyum install -y openssl openssl-devel\n\n# 下载 安装\nwget  http://nginx.org/download/nginx-1.9.15.tar.gz\ntar -zxvf nginx-1.9.0.tar.gz\ncd nginx-1.9.0\n\n# 后面的模块需要一起安装\n./configure   --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module \n\n# 启动\nnginx\n\n# 停止 \nnginx -s stop\n\n#重启\nnginx -s reload\n```\n\n<!-- more -->\n\n#### nginx模型概念\n\nNginx会按需同时运行多个进程：\n\n- 一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。 \n- 所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。 \n- 主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份（user配置项）运行。\n \n\n主进程主要完成如下工作：\n\n1. 读取并验正配置信息；\n2. 创建、绑定及关闭套接字；\n3. 启动、终止及维护worker进程的个数；\n4. 无须中止服务而重新配置工作特性；\n5. 重新打开日志文件；\n\nworker进程主要完成的任务包括：\n\n1. 接收、传入并处理来自客户端的连接；\n2. 提供反向代理及过滤功能；\n3. nginx任何能完成的其它任务；\n\n#### nginx配置文件\n\n例:\n\n```sh\n#user www-data;\nworker_processes  4;\n\nerror_log  /var/log/nginx/error.log;\npid        /var/run/nginx.pid;\n\nevents {\n\tuse epoll;\n    worker_connections 2048;\n    # multi_accept on;\n}\n\nhttp {\n#    include       /etc/nginx/mime.types;\n\n    types_hash_max_size 2048;\n    server_names_hash_bucket_size 64;\n\n    log_format custom '$remote_addr - $remote_user [$time_local] '\n                      '\"$request\" $status $request_time $body_bytes_sent '\n                      '\"$http_referer\" \"$http_user_agent\" \"$request_body\"';\n\n    access_log  /var/log/nginx/access.log custom;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  120;\n    tcp_nodelay        on;\n\n    proxy_connect_timeout 120;\n    proxy_send_timeout 120;\n    proxy_read_timeout 120;\n    send_timeout       120;\n\n    gzip  on;\n    gzip_disable \"MSIE [1-6]\\.(?!.*SV1)\";\n\n    upstream backend {\n      server localhost:3456 ;\n      server localhost:4567 ;\n      server localhost:5678 ;\n      server localhost:6789 ;\n    }\n\n    upstream manage {\n      server 127.0.0.1:8080 ;\n    }\n\n    upstream web {\n      server localhost:1603 ;\n    }\n\n    server {\n       listen 80;\n       location / {\n         proxy_set_header Referer \"\";\n         proxy_pass http://manage/;\n       }\n       location /api {\n         proxy_set_header Referer \"\";\n         proxy_pass http://backend/api;\n         client_max_body_size    30m;\n       }\n       location /trig {\n         proxy_set_header Referer \"\";\n         proxy_pass http://backend/trig;\n       }\n    }\n\n    server {\n       listen 1604;\n       location / {\n         proxy_set_header Referer \"\";\n         proxy_pass http://web/;\n       }\n    }\n}\n```\n\n全局属性配置：\n\n- user :主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。       \n- worker_processes: 指定Nginx要开启的进程数。\n- error log:用来定义全局错设日志文件的路径和日志名称。日志输出级别有debug，info，notice，warn，error，crit可供选择，其中debug输出日志最为详细，面crit（严重）输出日志最少。默认是error\n\n- pid: 用来指定进程id的存储文件位置。\n- event：设定nginx的工作模式及连接数上限，其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O Multiplexing)中的一种方式）,nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。worker_connection是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。\n\nhttp服务器相关属性的设置：\n\n- http \n\nserver段虚拟主机的配置:\n\n- server \n\n#### Nginx日志 - log_format\n\n```sh\nlog_format custom '$remote_addr - $remote_user [$time_local] '\n                      '\"$request\" $status $request_time $body_bytes_sent '\n                      '\"$http_referer\" \"$http_user_agent\" \"$request_body\"';\n\naccess_log  /var/log/nginx/access.log custom;\n```\n\naccess_log: 配置日志位置 和 输出格式\n\n格式设置:\n\n| 配置 | 作用 |\n| ------ | ------ |\n| $remote_addr | 客户端的ip地址(代理服务器，显示代理服务ip) |\n| $remote_user | 用于记录远程客户端的用户名称（一般为“-”） |\n| $time_local | 用于记录访问时间和时区 |\n| $request | 用于记录请求的url以及请求方法 |\n| $status | 响应状态码，例如：200成功、404页面找不到等。 |\n| $body_bytes_sent | 给客户端发送的文件主体内容字节数 |\n| $http_user_agent | 用户所使用的代理（一般为浏览器） |\n| $http_x_forwarded_for | 可以记录客户端IP，通过代理服务器来记录客户端的ip地址 |\n| $http_referer | 可以记录用户是从哪个链接访问过来的 |\n\n\n#### 日志配置和及切割\n\n```sh\n/etc/init.d/rsyslog start  #系统日志，如不开启，看不到定时任务日志\n/etc/rc.d/init.d/crond start\t#定时任务开启\n```\n编写sh：\n\n```sh\n#!/bin/bash\n#设置日志文件存放目录\nLOG_HOME=\"/usr/local/nginx/logs/\"\n#备分文件名称\nLOG_PATH_BAK=\"$(date -d yesterday +%Y%m%d%H%M)\"\n#重命名日志文件\nmv ${LOG_HOME}/access.log ${LOG_HOME}/access.${LOG_PATH_BAK}.log\nmv ${LOG_HOME}/error.log ${LOG_HOME}/error.${LOG_PATH_BAK}.log\n#向nginx主进程发信号重新打开日志\nkill -USR1 `cat ${LOG_HOME}/nginx.pid`\n```\n配置cron：\n\n```sh\n*/1 * * * * /usr/local/nginx/sbin/logcut.sh\n```\n\n> 可写脚本将日志存入mongo\n\n\n\n\n\n\n\n\n","source":"_posts/Nginx简介.md","raw":"---\ntitle: Nginx简介\ntags:\n  - Nginx\n---\n\nNginx简介\n\n#### Nginx作用\n\n- 路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器\n- 负载功能（与高并发高可用对应）：对后台服务器集群进行负载\n- 静态服务器（比tomcat性能高很多）：在mvvm模式中，充当文件读取职责\n\n> 总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器\n\n\n#### Nginx安装\n\n源码编译方式：\n\n```sh\n\n#一般系统中已经装了了make和g++，无须再装\nyum -y install autoconf automake make\nyum -y install gcc gcc-c++ \n\n#安装nginx依赖的库\nyum -y install pcre pcre-devel    \nyum -y install zlib zlib-devel\nyum install -y openssl openssl-devel\n\n# 下载 安装\nwget  http://nginx.org/download/nginx-1.9.15.tar.gz\ntar -zxvf nginx-1.9.0.tar.gz\ncd nginx-1.9.0\n\n# 后面的模块需要一起安装\n./configure   --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module \n\n# 启动\nnginx\n\n# 停止 \nnginx -s stop\n\n#重启\nnginx -s reload\n```\n\n<!-- more -->\n\n#### nginx模型概念\n\nNginx会按需同时运行多个进程：\n\n- 一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。 \n- 所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。 \n- 主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份（user配置项）运行。\n \n\n主进程主要完成如下工作：\n\n1. 读取并验正配置信息；\n2. 创建、绑定及关闭套接字；\n3. 启动、终止及维护worker进程的个数；\n4. 无须中止服务而重新配置工作特性；\n5. 重新打开日志文件；\n\nworker进程主要完成的任务包括：\n\n1. 接收、传入并处理来自客户端的连接；\n2. 提供反向代理及过滤功能；\n3. nginx任何能完成的其它任务；\n\n#### nginx配置文件\n\n例:\n\n```sh\n#user www-data;\nworker_processes  4;\n\nerror_log  /var/log/nginx/error.log;\npid        /var/run/nginx.pid;\n\nevents {\n\tuse epoll;\n    worker_connections 2048;\n    # multi_accept on;\n}\n\nhttp {\n#    include       /etc/nginx/mime.types;\n\n    types_hash_max_size 2048;\n    server_names_hash_bucket_size 64;\n\n    log_format custom '$remote_addr - $remote_user [$time_local] '\n                      '\"$request\" $status $request_time $body_bytes_sent '\n                      '\"$http_referer\" \"$http_user_agent\" \"$request_body\"';\n\n    access_log  /var/log/nginx/access.log custom;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  120;\n    tcp_nodelay        on;\n\n    proxy_connect_timeout 120;\n    proxy_send_timeout 120;\n    proxy_read_timeout 120;\n    send_timeout       120;\n\n    gzip  on;\n    gzip_disable \"MSIE [1-6]\\.(?!.*SV1)\";\n\n    upstream backend {\n      server localhost:3456 ;\n      server localhost:4567 ;\n      server localhost:5678 ;\n      server localhost:6789 ;\n    }\n\n    upstream manage {\n      server 127.0.0.1:8080 ;\n    }\n\n    upstream web {\n      server localhost:1603 ;\n    }\n\n    server {\n       listen 80;\n       location / {\n         proxy_set_header Referer \"\";\n         proxy_pass http://manage/;\n       }\n       location /api {\n         proxy_set_header Referer \"\";\n         proxy_pass http://backend/api;\n         client_max_body_size    30m;\n       }\n       location /trig {\n         proxy_set_header Referer \"\";\n         proxy_pass http://backend/trig;\n       }\n    }\n\n    server {\n       listen 1604;\n       location / {\n         proxy_set_header Referer \"\";\n         proxy_pass http://web/;\n       }\n    }\n}\n```\n\n全局属性配置：\n\n- user :主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。       \n- worker_processes: 指定Nginx要开启的进程数。\n- error log:用来定义全局错设日志文件的路径和日志名称。日志输出级别有debug，info，notice，warn，error，crit可供选择，其中debug输出日志最为详细，面crit（严重）输出日志最少。默认是error\n\n- pid: 用来指定进程id的存储文件位置。\n- event：设定nginx的工作模式及连接数上限，其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O Multiplexing)中的一种方式）,nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。worker_connection是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。\n\nhttp服务器相关属性的设置：\n\n- http \n\nserver段虚拟主机的配置:\n\n- server \n\n#### Nginx日志 - log_format\n\n```sh\nlog_format custom '$remote_addr - $remote_user [$time_local] '\n                      '\"$request\" $status $request_time $body_bytes_sent '\n                      '\"$http_referer\" \"$http_user_agent\" \"$request_body\"';\n\naccess_log  /var/log/nginx/access.log custom;\n```\n\naccess_log: 配置日志位置 和 输出格式\n\n格式设置:\n\n| 配置 | 作用 |\n| ------ | ------ |\n| $remote_addr | 客户端的ip地址(代理服务器，显示代理服务ip) |\n| $remote_user | 用于记录远程客户端的用户名称（一般为“-”） |\n| $time_local | 用于记录访问时间和时区 |\n| $request | 用于记录请求的url以及请求方法 |\n| $status | 响应状态码，例如：200成功、404页面找不到等。 |\n| $body_bytes_sent | 给客户端发送的文件主体内容字节数 |\n| $http_user_agent | 用户所使用的代理（一般为浏览器） |\n| $http_x_forwarded_for | 可以记录客户端IP，通过代理服务器来记录客户端的ip地址 |\n| $http_referer | 可以记录用户是从哪个链接访问过来的 |\n\n\n#### 日志配置和及切割\n\n```sh\n/etc/init.d/rsyslog start  #系统日志，如不开启，看不到定时任务日志\n/etc/rc.d/init.d/crond start\t#定时任务开启\n```\n编写sh：\n\n```sh\n#!/bin/bash\n#设置日志文件存放目录\nLOG_HOME=\"/usr/local/nginx/logs/\"\n#备分文件名称\nLOG_PATH_BAK=\"$(date -d yesterday +%Y%m%d%H%M)\"\n#重命名日志文件\nmv ${LOG_HOME}/access.log ${LOG_HOME}/access.${LOG_PATH_BAK}.log\nmv ${LOG_HOME}/error.log ${LOG_HOME}/error.${LOG_PATH_BAK}.log\n#向nginx主进程发信号重新打开日志\nkill -USR1 `cat ${LOG_HOME}/nginx.pid`\n```\n配置cron：\n\n```sh\n*/1 * * * * /usr/local/nginx/sbin/logcut.sh\n```\n\n> 可写脚本将日志存入mongo\n\n\n\n\n\n\n\n\n","slug":"Nginx简介","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15a9000k9gj7z4fbhhab","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Nginx简介</p>\n<h4 id=\"Nginx作用\"><a href=\"#Nginx作用\" class=\"headerlink\" title=\"Nginx作用\"></a>Nginx作用</h4><ul>\n<li>路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器</li>\n<li>负载功能（与高并发高可用对应）：对后台服务器集群进行负载</li>\n<li>静态服务器（比tomcat性能高很多）：在mvvm模式中，充当文件读取职责</li>\n</ul>\n<blockquote>\n<p>总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器</p>\n</blockquote>\n<h4 id=\"Nginx安装\"><a href=\"#Nginx安装\" class=\"headerlink\" title=\"Nginx安装\"></a>Nginx安装</h4><p>源码编译方式：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#一般系统中已经装了了make和g++，无须再装</span></span><br><span class=\"line\">yum -y install autoconf automake make</span><br><span class=\"line\">yum -y install gcc gcc-c++ </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装nginx依赖的库</span></span><br><span class=\"line\">yum -y install pcre pcre-devel    </span><br><span class=\"line\">yum -y install zlib zlib-devel</span><br><span class=\"line\">yum install -y openssl openssl-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 安装</span></span><br><span class=\"line\">wget  http://nginx.org/download/nginx-1.9.15.tar.gz</span><br><span class=\"line\">tar -zxvf nginx-1.9.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> nginx-1.9.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后面的模块需要一起安装</span></span><br><span class=\"line\">./configure   --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止 </span></span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#重启</span></span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"nginx模型概念\"><a href=\"#nginx模型概念\" class=\"headerlink\" title=\"nginx模型概念\"></a>nginx模型概念</h4><p>Nginx会按需同时运行多个进程：</p>\n<ul>\n<li>一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。 </li>\n<li>所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。 </li>\n<li>主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份（user配置项）运行。</li>\n</ul>\n<p>主进程主要完成如下工作：</p>\n<ol>\n<li>读取并验正配置信息；</li>\n<li>创建、绑定及关闭套接字；</li>\n<li>启动、终止及维护worker进程的个数；</li>\n<li>无须中止服务而重新配置工作特性；</li>\n<li>重新打开日志文件；</li>\n</ol>\n<p>worker进程主要完成的任务包括：</p>\n<ol>\n<li>接收、传入并处理来自客户端的连接；</li>\n<li>提供反向代理及过滤功能；</li>\n<li>nginx任何能完成的其它任务；</li>\n</ol>\n<h4 id=\"nginx配置文件\"><a href=\"#nginx配置文件\" class=\"headerlink\" title=\"nginx配置文件\"></a>nginx配置文件</h4><p>例:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#user www-data;</span></span><br><span class=\"line\">worker_processes  4;</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/<span class=\"built_in\">log</span>/nginx/error.log;</span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">\tuse epoll;</span><br><span class=\"line\">    worker_connections 2048;</span><br><span class=\"line\">    <span class=\"comment\"># multi_accept on;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"><span class=\"comment\">#    include       /etc/nginx/mime.types;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    types_hash_max_size 2048;</span><br><span class=\"line\">    server_names_hash_bucket_size 64;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format custom <span class=\"string\">'$remote_addr - $remote_user [$time_local] '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$request\" $status $request_time $body_bytes_sent '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$http_referer\" \"$http_user_agent\" \"$request_body\"'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/<span class=\"built_in\">log</span>/nginx/access.log custom;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    <span class=\"comment\">#tcp_nopush     on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#keepalive_timeout  0;</span></span><br><span class=\"line\">    keepalive_timeout  120;</span><br><span class=\"line\">    tcp_nodelay        on;</span><br><span class=\"line\"></span><br><span class=\"line\">    proxy_connect_timeout 120;</span><br><span class=\"line\">    proxy_send_timeout 120;</span><br><span class=\"line\">    proxy_read_timeout 120;</span><br><span class=\"line\">    send_timeout       120;</span><br><span class=\"line\"></span><br><span class=\"line\">    gzip  on;</span><br><span class=\"line\">    gzip_disable <span class=\"string\">\"MSIE [1-6]\\.(?!.*SV1)\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream backend &#123;</span><br><span class=\"line\">      server localhost:3456 ;</span><br><span class=\"line\">      server localhost:4567 ;</span><br><span class=\"line\">      server localhost:5678 ;</span><br><span class=\"line\">      server localhost:6789 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream manage &#123;</span><br><span class=\"line\">      server 127.0.0.1:8080 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream web &#123;</span><br><span class=\"line\">      server localhost:1603 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">       listen 80;</span><br><span class=\"line\">       location / &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://manage/;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       location /api &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://backend/api;</span><br><span class=\"line\">         client_max_body_size    30m;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       location /trig &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://backend/trig;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">       listen 1604;</span><br><span class=\"line\">       location / &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://web/;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>全局属性配置：</p>\n<ul>\n<li>user :主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。       </li>\n<li>worker_processes: 指定Nginx要开启的进程数。</li>\n<li><p>error log:用来定义全局错设日志文件的路径和日志名称。日志输出级别有debug，info，notice，warn，error，crit可供选择，其中debug输出日志最为详细，面crit（严重）输出日志最少。默认是error</p>\n</li>\n<li><p>pid: 用来指定进程id的存储文件位置。</p>\n</li>\n<li>event：设定nginx的工作模式及连接数上限，其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O Multiplexing)中的一种方式）,nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。worker_connection是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。</li>\n</ul>\n<p>http服务器相关属性的设置：</p>\n<ul>\n<li>http </li>\n</ul>\n<p>server段虚拟主机的配置:</p>\n<ul>\n<li>server </li>\n</ul>\n<h4 id=\"Nginx日志-log-format\"><a href=\"#Nginx日志-log-format\" class=\"headerlink\" title=\"Nginx日志 - log_format\"></a>Nginx日志 - log_format</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_format custom <span class=\"string\">'$remote_addr - $remote_user [$time_local] '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$request\" $status $request_time $body_bytes_sent '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$http_referer\" \"$http_user_agent\" \"$request_body\"'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">access_log  /var/<span class=\"built_in\">log</span>/nginx/access.log custom;</span><br></pre></td></tr></table></figure>\n<p>access_log: 配置日志位置 和 输出格式</p>\n<p>格式设置:</p>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$remote_addr</td>\n<td>客户端的ip地址(代理服务器，显示代理服务ip)</td>\n</tr>\n<tr>\n<td>$remote_user</td>\n<td>用于记录远程客户端的用户名称（一般为“-”）</td>\n</tr>\n<tr>\n<td>$time_local</td>\n<td>用于记录访问时间和时区</td>\n</tr>\n<tr>\n<td>$request</td>\n<td>用于记录请求的url以及请求方法</td>\n</tr>\n<tr>\n<td>$status</td>\n<td>响应状态码，例如：200成功、404页面找不到等。</td>\n</tr>\n<tr>\n<td>$body_bytes_sent</td>\n<td>给客户端发送的文件主体内容字节数</td>\n</tr>\n<tr>\n<td>$http_user_agent</td>\n<td>用户所使用的代理（一般为浏览器）</td>\n</tr>\n<tr>\n<td>$http_x_forwarded_for</td>\n<td>可以记录客户端IP，通过代理服务器来记录客户端的ip地址</td>\n</tr>\n<tr>\n<td>$http_referer</td>\n<td>可以记录用户是从哪个链接访问过来的</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"日志配置和及切割\"><a href=\"#日志配置和及切割\" class=\"headerlink\" title=\"日志配置和及切割\"></a>日志配置和及切割</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/rsyslog start  <span class=\"comment\">#系统日志，如不开启，看不到定时任务日志</span></span><br><span class=\"line\">/etc/rc.d/init.d/crond start\t<span class=\"comment\">#定时任务开启</span></span><br></pre></td></tr></table></figure>\n<p>编写sh：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\">#设置日志文件存放目录</span></span><br><span class=\"line\">LOG_HOME=<span class=\"string\">\"/usr/local/nginx/logs/\"</span></span><br><span class=\"line\"><span class=\"comment\">#备分文件名称</span></span><br><span class=\"line\">LOG_PATH_BAK=<span class=\"string\">\"<span class=\"variable\">$(date -d yesterday +%Y%m%d%H%M)</span>\"</span></span><br><span class=\"line\"><span class=\"comment\">#重命名日志文件</span></span><br><span class=\"line\">mv <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/access.log <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/access.<span class=\"variable\">$&#123;LOG_PATH_BAK&#125;</span>.<span class=\"built_in\">log</span></span><br><span class=\"line\">mv <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/error.log <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/error.<span class=\"variable\">$&#123;LOG_PATH_BAK&#125;</span>.<span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"comment\">#向nginx主进程发信号重新打开日志</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR1 `cat <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/nginx.pid`</span><br></pre></td></tr></table></figure>\n<p>配置cron：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * /usr/<span class=\"built_in\">local</span>/nginx/sbin/logcut.sh</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可写脚本将日志存入mongo</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Nginx简介</p>\n<h4 id=\"Nginx作用\"><a href=\"#Nginx作用\" class=\"headerlink\" title=\"Nginx作用\"></a>Nginx作用</h4><ul>\n<li>路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器</li>\n<li>负载功能（与高并发高可用对应）：对后台服务器集群进行负载</li>\n<li>静态服务器（比tomcat性能高很多）：在mvvm模式中，充当文件读取职责</li>\n</ul>\n<blockquote>\n<p>总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器</p>\n</blockquote>\n<h4 id=\"Nginx安装\"><a href=\"#Nginx安装\" class=\"headerlink\" title=\"Nginx安装\"></a>Nginx安装</h4><p>源码编译方式：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#一般系统中已经装了了make和g++，无须再装</span></span><br><span class=\"line\">yum -y install autoconf automake make</span><br><span class=\"line\">yum -y install gcc gcc-c++ </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装nginx依赖的库</span></span><br><span class=\"line\">yum -y install pcre pcre-devel    </span><br><span class=\"line\">yum -y install zlib zlib-devel</span><br><span class=\"line\">yum install -y openssl openssl-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载 安装</span></span><br><span class=\"line\">wget  http://nginx.org/download/nginx-1.9.15.tar.gz</span><br><span class=\"line\">tar -zxvf nginx-1.9.0.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> nginx-1.9.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后面的模块需要一起安装</span></span><br><span class=\"line\">./configure   --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动</span></span><br><span class=\"line\">nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止 </span></span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#重启</span></span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"nginx模型概念\"><a href=\"#nginx模型概念\" class=\"headerlink\" title=\"nginx模型概念\"></a>nginx模型概念</h4><p>Nginx会按需同时运行多个进程：</p>\n<ul>\n<li>一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。 </li>\n<li>所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。 </li>\n<li>主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份（user配置项）运行。</li>\n</ul>\n<p>主进程主要完成如下工作：</p>\n<ol>\n<li>读取并验正配置信息；</li>\n<li>创建、绑定及关闭套接字；</li>\n<li>启动、终止及维护worker进程的个数；</li>\n<li>无须中止服务而重新配置工作特性；</li>\n<li>重新打开日志文件；</li>\n</ol>\n<p>worker进程主要完成的任务包括：</p>\n<ol>\n<li>接收、传入并处理来自客户端的连接；</li>\n<li>提供反向代理及过滤功能；</li>\n<li>nginx任何能完成的其它任务；</li>\n</ol>\n<h4 id=\"nginx配置文件\"><a href=\"#nginx配置文件\" class=\"headerlink\" title=\"nginx配置文件\"></a>nginx配置文件</h4><p>例:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#user www-data;</span></span><br><span class=\"line\">worker_processes  4;</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/<span class=\"built_in\">log</span>/nginx/error.log;</span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">\tuse epoll;</span><br><span class=\"line\">    worker_connections 2048;</span><br><span class=\"line\">    <span class=\"comment\"># multi_accept on;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"><span class=\"comment\">#    include       /etc/nginx/mime.types;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    types_hash_max_size 2048;</span><br><span class=\"line\">    server_names_hash_bucket_size 64;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format custom <span class=\"string\">'$remote_addr - $remote_user [$time_local] '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$request\" $status $request_time $body_bytes_sent '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$http_referer\" \"$http_user_agent\" \"$request_body\"'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/<span class=\"built_in\">log</span>/nginx/access.log custom;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    <span class=\"comment\">#tcp_nopush     on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#keepalive_timeout  0;</span></span><br><span class=\"line\">    keepalive_timeout  120;</span><br><span class=\"line\">    tcp_nodelay        on;</span><br><span class=\"line\"></span><br><span class=\"line\">    proxy_connect_timeout 120;</span><br><span class=\"line\">    proxy_send_timeout 120;</span><br><span class=\"line\">    proxy_read_timeout 120;</span><br><span class=\"line\">    send_timeout       120;</span><br><span class=\"line\"></span><br><span class=\"line\">    gzip  on;</span><br><span class=\"line\">    gzip_disable <span class=\"string\">\"MSIE [1-6]\\.(?!.*SV1)\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream backend &#123;</span><br><span class=\"line\">      server localhost:3456 ;</span><br><span class=\"line\">      server localhost:4567 ;</span><br><span class=\"line\">      server localhost:5678 ;</span><br><span class=\"line\">      server localhost:6789 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream manage &#123;</span><br><span class=\"line\">      server 127.0.0.1:8080 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    upstream web &#123;</span><br><span class=\"line\">      server localhost:1603 ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">       listen 80;</span><br><span class=\"line\">       location / &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://manage/;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       location /api &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://backend/api;</span><br><span class=\"line\">         client_max_body_size    30m;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       location /trig &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://backend/trig;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">       listen 1604;</span><br><span class=\"line\">       location / &#123;</span><br><span class=\"line\">         proxy_set_header Referer <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         proxy_pass http://web/;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>全局属性配置：</p>\n<ul>\n<li>user :主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。       </li>\n<li>worker_processes: 指定Nginx要开启的进程数。</li>\n<li><p>error log:用来定义全局错设日志文件的路径和日志名称。日志输出级别有debug，info，notice，warn，error，crit可供选择，其中debug输出日志最为详细，面crit（严重）输出日志最少。默认是error</p>\n</li>\n<li><p>pid: 用来指定进程id的存储文件位置。</p>\n</li>\n<li>event：设定nginx的工作模式及连接数上限，其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O Multiplexing)中的一种方式）,nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。worker_connection是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。</li>\n</ul>\n<p>http服务器相关属性的设置：</p>\n<ul>\n<li>http </li>\n</ul>\n<p>server段虚拟主机的配置:</p>\n<ul>\n<li>server </li>\n</ul>\n<h4 id=\"Nginx日志-log-format\"><a href=\"#Nginx日志-log-format\" class=\"headerlink\" title=\"Nginx日志 - log_format\"></a>Nginx日志 - log_format</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_format custom <span class=\"string\">'$remote_addr - $remote_user [$time_local] '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$request\" $status $request_time $body_bytes_sent '</span></span><br><span class=\"line\">                      <span class=\"string\">'\"$http_referer\" \"$http_user_agent\" \"$request_body\"'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">access_log  /var/<span class=\"built_in\">log</span>/nginx/access.log custom;</span><br></pre></td></tr></table></figure>\n<p>access_log: 配置日志位置 和 输出格式</p>\n<p>格式设置:</p>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$remote_addr</td>\n<td>客户端的ip地址(代理服务器，显示代理服务ip)</td>\n</tr>\n<tr>\n<td>$remote_user</td>\n<td>用于记录远程客户端的用户名称（一般为“-”）</td>\n</tr>\n<tr>\n<td>$time_local</td>\n<td>用于记录访问时间和时区</td>\n</tr>\n<tr>\n<td>$request</td>\n<td>用于记录请求的url以及请求方法</td>\n</tr>\n<tr>\n<td>$status</td>\n<td>响应状态码，例如：200成功、404页面找不到等。</td>\n</tr>\n<tr>\n<td>$body_bytes_sent</td>\n<td>给客户端发送的文件主体内容字节数</td>\n</tr>\n<tr>\n<td>$http_user_agent</td>\n<td>用户所使用的代理（一般为浏览器）</td>\n</tr>\n<tr>\n<td>$http_x_forwarded_for</td>\n<td>可以记录客户端IP，通过代理服务器来记录客户端的ip地址</td>\n</tr>\n<tr>\n<td>$http_referer</td>\n<td>可以记录用户是从哪个链接访问过来的</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"日志配置和及切割\"><a href=\"#日志配置和及切割\" class=\"headerlink\" title=\"日志配置和及切割\"></a>日志配置和及切割</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/rsyslog start  <span class=\"comment\">#系统日志，如不开启，看不到定时任务日志</span></span><br><span class=\"line\">/etc/rc.d/init.d/crond start\t<span class=\"comment\">#定时任务开启</span></span><br></pre></td></tr></table></figure>\n<p>编写sh：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\">#设置日志文件存放目录</span></span><br><span class=\"line\">LOG_HOME=<span class=\"string\">\"/usr/local/nginx/logs/\"</span></span><br><span class=\"line\"><span class=\"comment\">#备分文件名称</span></span><br><span class=\"line\">LOG_PATH_BAK=<span class=\"string\">\"<span class=\"variable\">$(date -d yesterday +%Y%m%d%H%M)</span>\"</span></span><br><span class=\"line\"><span class=\"comment\">#重命名日志文件</span></span><br><span class=\"line\">mv <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/access.log <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/access.<span class=\"variable\">$&#123;LOG_PATH_BAK&#125;</span>.<span class=\"built_in\">log</span></span><br><span class=\"line\">mv <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/error.log <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/error.<span class=\"variable\">$&#123;LOG_PATH_BAK&#125;</span>.<span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"comment\">#向nginx主进程发信号重新打开日志</span></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -USR1 `cat <span class=\"variable\">$&#123;LOG_HOME&#125;</span>/nginx.pid`</span><br></pre></td></tr></table></figure>\n<p>配置cron：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * /usr/<span class=\"built_in\">local</span>/nginx/sbin/logcut.sh</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可写脚本将日志存入mongo</p>\n</blockquote>"},{"title":"Nginx - keepalived","_content":"\nNginx高可用keepalived\n\n#### keepalived\n\n思路：\n\n由 2台服务器软件虚拟出来一台 虚拟网关vip，此vip由两台机器共同协商生成。当有一台机器宕机时，另一台机器一样能维持vip。这保证了，只要两台机器不同时宕机，vip就存在(不可以用docker配置)\t\t\n\nkeepalived不常用：域名绑定ip是以实现IP路由功能 更方便\n\n功能：\n\n- 管理LVS负载均衡软件\n- 实现LVS集群节点的健康检查\n- 作为系统网络服务的高可用性（failover）\n\n<!-- more -->\n\nkeepalived配置步骤：\n\n1. 下载地址：https://pan.baidu.com/s/1G7sLL-YkZGSMu8G76yz1Rw 密码：adbw。对应centos6系统\n2. keepalived安装步骤：\t\t\n  A〉./configure --prefix=/data/program/keepalived --sysconf=/etc \t\t  ##因为keepalive启动时候会默认读取/etc/keepalived/keepalived.conf \t\t\n  B〉make && make install\t\t\n3. 修改/etc/keepalived/keepalived.conf配置文件信息\n4. 启动keepalived\t/data/program/keepalived/sbin/keepalived\n5. KEEPLIVED主从故障测试,起停主从keepalived，查看对应的vip=192.168.244.200的漫游情况\n6. 加nginx监控脚本,停止nginx，观察keepalived自动拉起nginx服务\n7. 查看keepalived日志： tail -f  /var/log/messages\n\n\n配置：\n\n```sh\nglobal_defs {             #全局配置    \n    router_id nginx_backup       #表示运行Keepalived服务器的一个标识，唯一的 两台机器一致\n}\nvrrp_script chk_http_port {\n    script \"/usr/local/src/chk_nginx_pid.sh\" #心跳执行的脚本\n    interval 2                          #（检测脚本执行的间隔，单位是秒）\n    weight 2\n}\nvrrp_instance VI_1 {        #vrrp 实例定义部分\n    state BACKUP            # 指定keepalived的角色，MASTER为主，BACKUP为备\n    interface eth0         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡)\n    virtual_router_id 66    # 虚拟路由编号，主从要一致\n    priority 100            # 优先级，数值越大，获取处理请求的优先级越高\n    advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)\n    authentication {\n        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信\n        auth_pass 1111\n    }\n    track_script {\n        chk_http_port            #（调用检测脚本）\n    }\n    virtual_ipaddress {\n        192.168.244.200            # 定义虚拟ip(VIP)，可多设，每行一个\n    }\n}\n```\n\n监控脚本：\n\n```sh\n#!/bin/bash\nA=`ps -C nginx --no-header |wc -l`        \nif [ $A -eq 0 ];then                            \n      /usr/local/nginx/sbin/nginx                #重启nginx\n      if [ `ps -C nginx --no-header |wc -l` -eq 0 ];\n      then    #nginx重启失败，则停掉keepalived服务，进行VIP转移\n              killall keepalived    #杀掉，vip就漫游到另一台机器                \n      fi\nfi\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Nginx高可用keepalived.md","raw":"---\ntitle: Nginx - keepalived\ntags:\n  - Nginx\n---\n\nNginx高可用keepalived\n\n#### keepalived\n\n思路：\n\n由 2台服务器软件虚拟出来一台 虚拟网关vip，此vip由两台机器共同协商生成。当有一台机器宕机时，另一台机器一样能维持vip。这保证了，只要两台机器不同时宕机，vip就存在(不可以用docker配置)\t\t\n\nkeepalived不常用：域名绑定ip是以实现IP路由功能 更方便\n\n功能：\n\n- 管理LVS负载均衡软件\n- 实现LVS集群节点的健康检查\n- 作为系统网络服务的高可用性（failover）\n\n<!-- more -->\n\nkeepalived配置步骤：\n\n1. 下载地址：https://pan.baidu.com/s/1G7sLL-YkZGSMu8G76yz1Rw 密码：adbw。对应centos6系统\n2. keepalived安装步骤：\t\t\n  A〉./configure --prefix=/data/program/keepalived --sysconf=/etc \t\t  ##因为keepalive启动时候会默认读取/etc/keepalived/keepalived.conf \t\t\n  B〉make && make install\t\t\n3. 修改/etc/keepalived/keepalived.conf配置文件信息\n4. 启动keepalived\t/data/program/keepalived/sbin/keepalived\n5. KEEPLIVED主从故障测试,起停主从keepalived，查看对应的vip=192.168.244.200的漫游情况\n6. 加nginx监控脚本,停止nginx，观察keepalived自动拉起nginx服务\n7. 查看keepalived日志： tail -f  /var/log/messages\n\n\n配置：\n\n```sh\nglobal_defs {             #全局配置    \n    router_id nginx_backup       #表示运行Keepalived服务器的一个标识，唯一的 两台机器一致\n}\nvrrp_script chk_http_port {\n    script \"/usr/local/src/chk_nginx_pid.sh\" #心跳执行的脚本\n    interval 2                          #（检测脚本执行的间隔，单位是秒）\n    weight 2\n}\nvrrp_instance VI_1 {        #vrrp 实例定义部分\n    state BACKUP            # 指定keepalived的角色，MASTER为主，BACKUP为备\n    interface eth0         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡)\n    virtual_router_id 66    # 虚拟路由编号，主从要一致\n    priority 100            # 优先级，数值越大，获取处理请求的优先级越高\n    advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)\n    authentication {\n        auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信\n        auth_pass 1111\n    }\n    track_script {\n        chk_http_port            #（调用检测脚本）\n    }\n    virtual_ipaddress {\n        192.168.244.200            # 定义虚拟ip(VIP)，可多设，每行一个\n    }\n}\n```\n\n监控脚本：\n\n```sh\n#!/bin/bash\nA=`ps -C nginx --no-header |wc -l`        \nif [ $A -eq 0 ];then                            \n      /usr/local/nginx/sbin/nginx                #重启nginx\n      if [ `ps -C nginx --no-header |wc -l` -eq 0 ];\n      then    #nginx重启失败，则停掉keepalived服务，进行VIP转移\n              killall keepalived    #杀掉，vip就漫游到另一台机器                \n      fi\nfi\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Nginx高可用keepalived","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15ab000m9gj7xud3s0ed","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Nginx高可用keepalived</p>\n<h4 id=\"keepalived\"><a href=\"#keepalived\" class=\"headerlink\" title=\"keepalived\"></a>keepalived</h4><p>思路：</p>\n<p>由 2台服务器软件虚拟出来一台 虚拟网关vip，此vip由两台机器共同协商生成。当有一台机器宕机时，另一台机器一样能维持vip。这保证了，只要两台机器不同时宕机，vip就存在(不可以用docker配置)        </p>\n<p>keepalived不常用：域名绑定ip是以实现IP路由功能 更方便</p>\n<p>功能：</p>\n<ul>\n<li>管理LVS负载均衡软件</li>\n<li>实现LVS集群节点的健康检查</li>\n<li>作为系统网络服务的高可用性（failover）</li>\n</ul>\n<a id=\"more\"></a>\n<p>keepalived配置步骤：</p>\n<ol>\n<li>下载地址：<a href=\"https://pan.baidu.com/s/1G7sLL-YkZGSMu8G76yz1Rw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1G7sLL-YkZGSMu8G76yz1Rw</a> 密码：adbw。对应centos6系统</li>\n<li>keepalived安装步骤：<br>A〉./configure –prefix=/data/program/keepalived –sysconf=/etc           ##因为keepalive启动时候会默认读取/etc/keepalived/keepalived.conf<br>B〉make &amp;&amp; make install        </li>\n<li>修改/etc/keepalived/keepalived.conf配置文件信息</li>\n<li>启动keepalived    /data/program/keepalived/sbin/keepalived</li>\n<li>KEEPLIVED主从故障测试,起停主从keepalived，查看对应的vip=192.168.244.200的漫游情况</li>\n<li>加nginx监控脚本,停止nginx，观察keepalived自动拉起nginx服务</li>\n<li>查看keepalived日志： tail -f  /var/log/messages</li>\n</ol>\n<p>配置：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global_defs &#123;             <span class=\"comment\">#全局配置    </span></span><br><span class=\"line\">    router_id nginx_backup       <span class=\"comment\">#表示运行Keepalived服务器的一个标识，唯一的 两台机器一致</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vrrp_script chk_http_port &#123;</span><br><span class=\"line\">    script <span class=\"string\">\"/usr/local/src/chk_nginx_pid.sh\"</span> <span class=\"comment\">#心跳执行的脚本</span></span><br><span class=\"line\">    interval 2                          <span class=\"comment\">#（检测脚本执行的间隔，单位是秒）</span></span><br><span class=\"line\">    weight 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vrrp_instance VI_1 &#123;        <span class=\"comment\">#vrrp 实例定义部分</span></span><br><span class=\"line\">    state BACKUP            <span class=\"comment\"># 指定keepalived的角色，MASTER为主，BACKUP为备</span></span><br><span class=\"line\">    interface eth0         <span class=\"comment\"># 当前进行vrrp通讯的网络接口卡(当前centos的网卡)</span></span><br><span class=\"line\">    virtual_router_id 66    <span class=\"comment\"># 虚拟路由编号，主从要一致</span></span><br><span class=\"line\">    priority 100            <span class=\"comment\"># 优先级，数值越大，获取处理请求的优先级越高</span></span><br><span class=\"line\">    advert_int 1            <span class=\"comment\"># 检查间隔，默认为1s(vrrp组播周期秒数)</span></span><br><span class=\"line\">    authentication &#123;</span><br><span class=\"line\">        auth_type PASS <span class=\"comment\">#设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信</span></span><br><span class=\"line\">        auth_pass 1111</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">        chk_http_port            <span class=\"comment\">#（调用检测脚本）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.244.200            <span class=\"comment\"># 定义虚拟ip(VIP)，可多设，每行一个</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监控脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">A=`ps -C nginx --no-header |wc -l`        </span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$A</span> -eq 0 ];<span class=\"keyword\">then</span>                            </span><br><span class=\"line\">      /usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx                <span class=\"comment\">#重启nginx</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> [ `ps -C nginx --no-header |wc -l` -eq 0 ];</span><br><span class=\"line\">      <span class=\"keyword\">then</span>    <span class=\"comment\">#nginx重启失败，则停掉keepalived服务，进行VIP转移</span></span><br><span class=\"line\">              killall keepalived    <span class=\"comment\">#杀掉，vip就漫游到另一台机器                </span></span><br><span class=\"line\">      <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Nginx高可用keepalived</p>\n<h4 id=\"keepalived\"><a href=\"#keepalived\" class=\"headerlink\" title=\"keepalived\"></a>keepalived</h4><p>思路：</p>\n<p>由 2台服务器软件虚拟出来一台 虚拟网关vip，此vip由两台机器共同协商生成。当有一台机器宕机时，另一台机器一样能维持vip。这保证了，只要两台机器不同时宕机，vip就存在(不可以用docker配置)        </p>\n<p>keepalived不常用：域名绑定ip是以实现IP路由功能 更方便</p>\n<p>功能：</p>\n<ul>\n<li>管理LVS负载均衡软件</li>\n<li>实现LVS集群节点的健康检查</li>\n<li>作为系统网络服务的高可用性（failover）</li>\n</ul>","more":"<p>keepalived配置步骤：</p>\n<ol>\n<li>下载地址：<a href=\"https://pan.baidu.com/s/1G7sLL-YkZGSMu8G76yz1Rw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1G7sLL-YkZGSMu8G76yz1Rw</a> 密码：adbw。对应centos6系统</li>\n<li>keepalived安装步骤：<br>A〉./configure –prefix=/data/program/keepalived –sysconf=/etc           ##因为keepalive启动时候会默认读取/etc/keepalived/keepalived.conf<br>B〉make &amp;&amp; make install        </li>\n<li>修改/etc/keepalived/keepalived.conf配置文件信息</li>\n<li>启动keepalived    /data/program/keepalived/sbin/keepalived</li>\n<li>KEEPLIVED主从故障测试,起停主从keepalived，查看对应的vip=192.168.244.200的漫游情况</li>\n<li>加nginx监控脚本,停止nginx，观察keepalived自动拉起nginx服务</li>\n<li>查看keepalived日志： tail -f  /var/log/messages</li>\n</ol>\n<p>配置：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global_defs &#123;             <span class=\"comment\">#全局配置    </span></span><br><span class=\"line\">    router_id nginx_backup       <span class=\"comment\">#表示运行Keepalived服务器的一个标识，唯一的 两台机器一致</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vrrp_script chk_http_port &#123;</span><br><span class=\"line\">    script <span class=\"string\">\"/usr/local/src/chk_nginx_pid.sh\"</span> <span class=\"comment\">#心跳执行的脚本</span></span><br><span class=\"line\">    interval 2                          <span class=\"comment\">#（检测脚本执行的间隔，单位是秒）</span></span><br><span class=\"line\">    weight 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">vrrp_instance VI_1 &#123;        <span class=\"comment\">#vrrp 实例定义部分</span></span><br><span class=\"line\">    state BACKUP            <span class=\"comment\"># 指定keepalived的角色，MASTER为主，BACKUP为备</span></span><br><span class=\"line\">    interface eth0         <span class=\"comment\"># 当前进行vrrp通讯的网络接口卡(当前centos的网卡)</span></span><br><span class=\"line\">    virtual_router_id 66    <span class=\"comment\"># 虚拟路由编号，主从要一致</span></span><br><span class=\"line\">    priority 100            <span class=\"comment\"># 优先级，数值越大，获取处理请求的优先级越高</span></span><br><span class=\"line\">    advert_int 1            <span class=\"comment\"># 检查间隔，默认为1s(vrrp组播周期秒数)</span></span><br><span class=\"line\">    authentication &#123;</span><br><span class=\"line\">        auth_type PASS <span class=\"comment\">#设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信</span></span><br><span class=\"line\">        auth_pass 1111</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    track_script &#123;</span><br><span class=\"line\">        chk_http_port            <span class=\"comment\">#（调用检测脚本）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    virtual_ipaddress &#123;</span><br><span class=\"line\">        192.168.244.200            <span class=\"comment\"># 定义虚拟ip(VIP)，可多设，每行一个</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>监控脚本：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">A=`ps -C nginx --no-header |wc -l`        </span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$A</span> -eq 0 ];<span class=\"keyword\">then</span>                            </span><br><span class=\"line\">      /usr/<span class=\"built_in\">local</span>/nginx/sbin/nginx                <span class=\"comment\">#重启nginx</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> [ `ps -C nginx --no-header |wc -l` -eq 0 ];</span><br><span class=\"line\">      <span class=\"keyword\">then</span>    <span class=\"comment\">#nginx重启失败，则停掉keepalived服务，进行VIP转移</span></span><br><span class=\"line\">              killall keepalived    <span class=\"comment\">#杀掉，vip就漫游到另一台机器                </span></span><br><span class=\"line\">      <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>"},{"title":"Nginx - 跨域/防盗链/缓存/压缩/Https","_content":"\nNginx跨域/防盗链/缓存/压缩/Https\n\n#### 跨域解决\n\n流程：\n\n- 当chrome发现ajax请求的网址，与当前主域名不一致（跨域）时，会在请求header中追加值页面主域名值，即：origin = http://static.enjoy.com\n- nginx在接收到ajax请求时，会查看origin值，即请求我的网址是谁？此处使用正则来校验，即：只要是enjoy.com下的网址，都允许访问我，返回信息时，nginx追加header值：access-control-allow-origin = static.enjoy.com（回答浏览器，static域名网址可以访问我）\n- chrome收到ajax返回值后，查看返回的header中access-control-allow-origin的值，发现其中的值是static.enjoy.com,正是当前的页面主域名。这是允许访问，于是执行ajax返回值内容。（ps：若此处access-control-allow-origin不存在，或者值不是static域名，chrome就拒绝执行返回值）\n\n<!-- more -->\n\n```sh\nserver{\n\tlisten 80;\n\tserver-name www.enjoy.com;\n\n\tif($http_origin ~ http://(.*).enjoy.com){\n\t\tset $allow_url $http_origin;\n\t}\n\t#是否允许请求带有验证信息\n\tadd_header Access-Control-Allow-Credentials true;\n\t#允许跨域访问的域名,可以是一个域的列表，也可以是通配符*\n\tadd_header Access-Control-Allow-Origin  $allow_url;\n\t#允许脚本访问的返回头\n\tadd_header Access-Control-Allow-Headers 'x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp';\n\t#允许使用的请求方法，以逗号隔开\n\tadd_header Access-Control-Allow-Methods 'POST,GET,OPTIONS,PUT,DELETE';\n\t#允许自定义的头部，以逗号隔开,大小写不敏感\n\tadd_header Access-Control-Expose-Headers 'WWW-Authenticate,Server-Authorization';\n\t#P3P支持跨域cookie操作\n\tadd_header P3P 'policyref=\"/w3c/p3p.xml\", CP=\"NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC\"';\n\tadd_header test  1;\n\n\t if ($request_method = 'OPTIONS') {\n             return 204;\n         }\n\n}\n```\n\n\n\n\n\n\n\n#### 防盗链\n\n目的：\n\n1.\t让资源只能在我的页面内显示\n2.\t不能单独来取或者下载\n\n流程：\n\n1.\tchrome以url1首次请求web服务器，得到html页面。\n2.\tchrome再次发起url2资源请求，携带referers = url1。（注意，是url1，不是本次的url2）\n3.\tnginx校验referers值，决定是否允许访问。\n4.\tvalid_referers：匹配域名白名单，如果不匹配，把内置变量$invalid_referers置为1，进入if块，返回404\n\n```sh\nlocation ^~ /mall {\n\t\tvalid_referers *.enjoy.com;\n    \tif ($invalid_referer) {\n    \t\treturn 404;\n    \t}\n        root html/gzip;\n     }\n```\n\n#### 缓存\n\n```sh\nlocation ^~ /qq.png {\n\t#\texpires 2s;#缓存2秒\n\t\texpires 2m;#缓存2分钟\n\t#\texpires 2h;#缓存2小时\n\t#\texpires 2d;#缓存2天\n\t\troot html/gzip;\n\t}\n```\n\n#### 压缩\n\n带宽资源很贵 /html/js/css压缩，/images不压缩\t\t\t\n过程：nginx压缩 ----》网络传输 ---》chrome解压（压缩和解压消耗cpu）\n\n1. 浏览器携带支持的解压方式\n2. 浏览器与nginx的交互\n\n```sh\nlocation ~ /(.*)\\.(html|js|css|jpg|jpeg|png|gif)$ {#覆盖/re/a.htm路径\n\t\tgzip on; # 启用gzip压缩，默认是off，不启用\n\t\t\n\t\t# 对js、css、jpg、png、gif格式的文件启用gzip压缩功能\n\t\tgzip_types application/javascript text/css image/jpeg image/png image/gif;\n\t\tgzip_min_length 1024; # 所压缩文件的最小值，小于这个的不会压缩\n\t\tgzip_buffers 4 1k; # 设置压缩响应的缓冲块的大小和个数，默认是内存一个页的大小\n\t\tgzip_comp_level 1; # 压缩水平，默认1。取值范围1-9，取值越大压缩比率越大，但越耗cpu时间\n\t\t\n\t\troot html/gzip;\n\t}\n```\n\n#### Https\n\nnginx配置https的时候，需要两个东西：（此两样需购买）  \t\t\n一个key，私钥。放在nginx服务器里面，仅此一份\t\t\n一个证书，公钥，供浏览器去下载。\t\t\n\n> nginx -V 需要有--with-http_ssl_module,表示安装了https模块。否则需要重新安装。\n\n配置如下：\n\n```sh\nssl_certificate      /etc/nginx/conf.d/server.crt;\nssl_certificate_key  /etc/nginx/conf.d/server_nopass.key;\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Nginx跨域.md","raw":"---\ntitle: Nginx - 跨域/防盗链/缓存/压缩/Https\ntags:\n  - Nginx\n---\n\nNginx跨域/防盗链/缓存/压缩/Https\n\n#### 跨域解决\n\n流程：\n\n- 当chrome发现ajax请求的网址，与当前主域名不一致（跨域）时，会在请求header中追加值页面主域名值，即：origin = http://static.enjoy.com\n- nginx在接收到ajax请求时，会查看origin值，即请求我的网址是谁？此处使用正则来校验，即：只要是enjoy.com下的网址，都允许访问我，返回信息时，nginx追加header值：access-control-allow-origin = static.enjoy.com（回答浏览器，static域名网址可以访问我）\n- chrome收到ajax返回值后，查看返回的header中access-control-allow-origin的值，发现其中的值是static.enjoy.com,正是当前的页面主域名。这是允许访问，于是执行ajax返回值内容。（ps：若此处access-control-allow-origin不存在，或者值不是static域名，chrome就拒绝执行返回值）\n\n<!-- more -->\n\n```sh\nserver{\n\tlisten 80;\n\tserver-name www.enjoy.com;\n\n\tif($http_origin ~ http://(.*).enjoy.com){\n\t\tset $allow_url $http_origin;\n\t}\n\t#是否允许请求带有验证信息\n\tadd_header Access-Control-Allow-Credentials true;\n\t#允许跨域访问的域名,可以是一个域的列表，也可以是通配符*\n\tadd_header Access-Control-Allow-Origin  $allow_url;\n\t#允许脚本访问的返回头\n\tadd_header Access-Control-Allow-Headers 'x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp';\n\t#允许使用的请求方法，以逗号隔开\n\tadd_header Access-Control-Allow-Methods 'POST,GET,OPTIONS,PUT,DELETE';\n\t#允许自定义的头部，以逗号隔开,大小写不敏感\n\tadd_header Access-Control-Expose-Headers 'WWW-Authenticate,Server-Authorization';\n\t#P3P支持跨域cookie操作\n\tadd_header P3P 'policyref=\"/w3c/p3p.xml\", CP=\"NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC\"';\n\tadd_header test  1;\n\n\t if ($request_method = 'OPTIONS') {\n             return 204;\n         }\n\n}\n```\n\n\n\n\n\n\n\n#### 防盗链\n\n目的：\n\n1.\t让资源只能在我的页面内显示\n2.\t不能单独来取或者下载\n\n流程：\n\n1.\tchrome以url1首次请求web服务器，得到html页面。\n2.\tchrome再次发起url2资源请求，携带referers = url1。（注意，是url1，不是本次的url2）\n3.\tnginx校验referers值，决定是否允许访问。\n4.\tvalid_referers：匹配域名白名单，如果不匹配，把内置变量$invalid_referers置为1，进入if块，返回404\n\n```sh\nlocation ^~ /mall {\n\t\tvalid_referers *.enjoy.com;\n    \tif ($invalid_referer) {\n    \t\treturn 404;\n    \t}\n        root html/gzip;\n     }\n```\n\n#### 缓存\n\n```sh\nlocation ^~ /qq.png {\n\t#\texpires 2s;#缓存2秒\n\t\texpires 2m;#缓存2分钟\n\t#\texpires 2h;#缓存2小时\n\t#\texpires 2d;#缓存2天\n\t\troot html/gzip;\n\t}\n```\n\n#### 压缩\n\n带宽资源很贵 /html/js/css压缩，/images不压缩\t\t\t\n过程：nginx压缩 ----》网络传输 ---》chrome解压（压缩和解压消耗cpu）\n\n1. 浏览器携带支持的解压方式\n2. 浏览器与nginx的交互\n\n```sh\nlocation ~ /(.*)\\.(html|js|css|jpg|jpeg|png|gif)$ {#覆盖/re/a.htm路径\n\t\tgzip on; # 启用gzip压缩，默认是off，不启用\n\t\t\n\t\t# 对js、css、jpg、png、gif格式的文件启用gzip压缩功能\n\t\tgzip_types application/javascript text/css image/jpeg image/png image/gif;\n\t\tgzip_min_length 1024; # 所压缩文件的最小值，小于这个的不会压缩\n\t\tgzip_buffers 4 1k; # 设置压缩响应的缓冲块的大小和个数，默认是内存一个页的大小\n\t\tgzip_comp_level 1; # 压缩水平，默认1。取值范围1-9，取值越大压缩比率越大，但越耗cpu时间\n\t\t\n\t\troot html/gzip;\n\t}\n```\n\n#### Https\n\nnginx配置https的时候，需要两个东西：（此两样需购买）  \t\t\n一个key，私钥。放在nginx服务器里面，仅此一份\t\t\n一个证书，公钥，供浏览器去下载。\t\t\n\n> nginx -V 需要有--with-http_ssl_module,表示安装了https模块。否则需要重新安装。\n\n配置如下：\n\n```sh\nssl_certificate      /etc/nginx/conf.d/server.crt;\nssl_certificate_key  /etc/nginx/conf.d/server_nopass.key;\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"Nginx跨域","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15ac000p9gj70wqei9h0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Nginx跨域/防盗链/缓存/压缩/Https</p>\n<h4 id=\"跨域解决\"><a href=\"#跨域解决\" class=\"headerlink\" title=\"跨域解决\"></a>跨域解决</h4><p>流程：</p>\n<ul>\n<li>当chrome发现ajax请求的网址，与当前主域名不一致（跨域）时，会在请求header中追加值页面主域名值，即：origin = <a href=\"http://static.enjoy.com\" target=\"_blank\" rel=\"noopener\">http://static.enjoy.com</a></li>\n<li>nginx在接收到ajax请求时，会查看origin值，即请求我的网址是谁？此处使用正则来校验，即：只要是enjoy.com下的网址，都允许访问我，返回信息时，nginx追加header值：access-control-allow-origin = static.enjoy.com（回答浏览器，static域名网址可以访问我）</li>\n<li>chrome收到ajax返回值后，查看返回的header中access-control-allow-origin的值，发现其中的值是static.enjoy.com,正是当前的页面主域名。这是允许访问，于是执行ajax返回值内容。（ps：若此处access-control-allow-origin不存在，或者值不是static域名，chrome就拒绝执行返回值）</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">\tlisten 80;</span><br><span class=\"line\">\tserver-name www.enjoy.com;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"variable\">$http_origin</span> ~ http://(.*).enjoy.com)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span> <span class=\"variable\">$allow_url</span> <span class=\"variable\">$http_origin</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">#是否允许请求带有验证信息</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Credentials <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许跨域访问的域名,可以是一个域的列表，也可以是通配符*</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Origin  <span class=\"variable\">$allow_url</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许脚本访问的返回头</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Headers <span class=\"string\">'x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许使用的请求方法，以逗号隔开</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Methods <span class=\"string\">'POST,GET,OPTIONS,PUT,DELETE'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许自定义的头部，以逗号隔开,大小写不敏感</span></span><br><span class=\"line\">\tadd_header Access-Control-Expose-Headers <span class=\"string\">'WWW-Authenticate,Server-Authorization'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#P3P支持跨域cookie操作</span></span><br><span class=\"line\">\tadd_header P3P <span class=\"string\">'policyref=\"/w3c/p3p.xml\", CP=\"NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC\"'</span>;</span><br><span class=\"line\">\tadd_header <span class=\"built_in\">test</span>  1;</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">if</span> (<span class=\"variable\">$request_method</span> = <span class=\"string\">'OPTIONS'</span>) &#123;</span><br><span class=\"line\">             <span class=\"built_in\">return</span> 204;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h4><p>目的：</p>\n<ol>\n<li>让资源只能在我的页面内显示</li>\n<li>不能单独来取或者下载</li>\n</ol>\n<p>流程：</p>\n<ol>\n<li>chrome以url1首次请求web服务器，得到html页面。</li>\n<li>chrome再次发起url2资源请求，携带referers = url1。（注意，是url1，不是本次的url2）</li>\n<li>nginx校验referers值，决定是否允许访问。</li>\n<li>valid_referers：匹配域名白名单，如果不匹配，把内置变量$invalid_referers置为1，进入if块，返回404</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~ /mall &#123;</span><br><span class=\"line\">\t\tvalid_referers *.enjoy.com;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (<span class=\"variable\">$invalid_referer</span>) &#123;</span><br><span class=\"line\">    \t\t<span class=\"built_in\">return</span> 404;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">        root html/gzip;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~ /qq.png &#123;</span><br><span class=\"line\">\t<span class=\"comment\">#\texpires 2s;#缓存2秒</span></span><br><span class=\"line\">\t\texpires 2m;<span class=\"comment\">#缓存2分钟</span></span><br><span class=\"line\">\t<span class=\"comment\">#\texpires 2h;#缓存2小时</span></span><br><span class=\"line\">\t<span class=\"comment\">#\texpires 2d;#缓存2天</span></span><br><span class=\"line\">\t\troot html/gzip;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h4><p>带宽资源很贵 /html/js/css压缩，/images不压缩<br>过程：nginx压缩 —-》网络传输 —》chrome解压（压缩和解压消耗cpu）</p>\n<ol>\n<li>浏览器携带支持的解压方式</li>\n<li>浏览器与nginx的交互</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ /(.*)\\.(html|js|css|jpg|jpeg|png|gif)$ &#123;<span class=\"comment\">#覆盖/re/a.htm路径</span></span><br><span class=\"line\">\t\tgzip on; <span class=\"comment\"># 启用gzip压缩，默认是off，不启用</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\"># 对js、css、jpg、png、gif格式的文件启用gzip压缩功能</span></span><br><span class=\"line\">\t\tgzip_types application/javascript text/css image/jpeg image/png image/gif;</span><br><span class=\"line\">\t\tgzip_min_length 1024; <span class=\"comment\"># 所压缩文件的最小值，小于这个的不会压缩</span></span><br><span class=\"line\">\t\tgzip_buffers 4 1k; <span class=\"comment\"># 设置压缩响应的缓冲块的大小和个数，默认是内存一个页的大小</span></span><br><span class=\"line\">\t\tgzip_comp_level 1; <span class=\"comment\"># 压缩水平，默认1。取值范围1-9，取值越大压缩比率越大，但越耗cpu时间</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\troot html/gzip;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Https\"><a href=\"#Https\" class=\"headerlink\" title=\"Https\"></a>Https</h4><p>nginx配置https的时候，需要两个东西：（此两样需购买）<br>一个key，私钥。放在nginx服务器里面，仅此一份<br>一个证书，公钥，供浏览器去下载。        </p>\n<blockquote>\n<p>nginx -V 需要有–with-http_ssl_module,表示安装了https模块。否则需要重新安装。</p>\n</blockquote>\n<p>配置如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssl_certificate      /etc/nginx/conf.d/server.crt;</span><br><span class=\"line\">ssl_certificate_key  /etc/nginx/conf.d/server_nopass.key;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Nginx跨域/防盗链/缓存/压缩/Https</p>\n<h4 id=\"跨域解决\"><a href=\"#跨域解决\" class=\"headerlink\" title=\"跨域解决\"></a>跨域解决</h4><p>流程：</p>\n<ul>\n<li>当chrome发现ajax请求的网址，与当前主域名不一致（跨域）时，会在请求header中追加值页面主域名值，即：origin = <a href=\"http://static.enjoy.com\" target=\"_blank\" rel=\"noopener\">http://static.enjoy.com</a></li>\n<li>nginx在接收到ajax请求时，会查看origin值，即请求我的网址是谁？此处使用正则来校验，即：只要是enjoy.com下的网址，都允许访问我，返回信息时，nginx追加header值：access-control-allow-origin = static.enjoy.com（回答浏览器，static域名网址可以访问我）</li>\n<li>chrome收到ajax返回值后，查看返回的header中access-control-allow-origin的值，发现其中的值是static.enjoy.com,正是当前的页面主域名。这是允许访问，于是执行ajax返回值内容。（ps：若此处access-control-allow-origin不存在，或者值不是static域名，chrome就拒绝执行返回值）</li>\n</ul>","more":"<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">\tlisten 80;</span><br><span class=\"line\">\tserver-name www.enjoy.com;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"variable\">$http_origin</span> ~ http://(.*).enjoy.com)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span> <span class=\"variable\">$allow_url</span> <span class=\"variable\">$http_origin</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">#是否允许请求带有验证信息</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Credentials <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许跨域访问的域名,可以是一个域的列表，也可以是通配符*</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Origin  <span class=\"variable\">$allow_url</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许脚本访问的返回头</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Headers <span class=\"string\">'x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许使用的请求方法，以逗号隔开</span></span><br><span class=\"line\">\tadd_header Access-Control-Allow-Methods <span class=\"string\">'POST,GET,OPTIONS,PUT,DELETE'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#允许自定义的头部，以逗号隔开,大小写不敏感</span></span><br><span class=\"line\">\tadd_header Access-Control-Expose-Headers <span class=\"string\">'WWW-Authenticate,Server-Authorization'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">#P3P支持跨域cookie操作</span></span><br><span class=\"line\">\tadd_header P3P <span class=\"string\">'policyref=\"/w3c/p3p.xml\", CP=\"NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC\"'</span>;</span><br><span class=\"line\">\tadd_header <span class=\"built_in\">test</span>  1;</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">if</span> (<span class=\"variable\">$request_method</span> = <span class=\"string\">'OPTIONS'</span>) &#123;</span><br><span class=\"line\">             <span class=\"built_in\">return</span> 204;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h4><p>目的：</p>\n<ol>\n<li>让资源只能在我的页面内显示</li>\n<li>不能单独来取或者下载</li>\n</ol>\n<p>流程：</p>\n<ol>\n<li>chrome以url1首次请求web服务器，得到html页面。</li>\n<li>chrome再次发起url2资源请求，携带referers = url1。（注意，是url1，不是本次的url2）</li>\n<li>nginx校验referers值，决定是否允许访问。</li>\n<li>valid_referers：匹配域名白名单，如果不匹配，把内置变量$invalid_referers置为1，进入if块，返回404</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~ /mall &#123;</span><br><span class=\"line\">\t\tvalid_referers *.enjoy.com;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (<span class=\"variable\">$invalid_referer</span>) &#123;</span><br><span class=\"line\">    \t\t<span class=\"built_in\">return</span> 404;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">        root html/gzip;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ^~ /qq.png &#123;</span><br><span class=\"line\">\t<span class=\"comment\">#\texpires 2s;#缓存2秒</span></span><br><span class=\"line\">\t\texpires 2m;<span class=\"comment\">#缓存2分钟</span></span><br><span class=\"line\">\t<span class=\"comment\">#\texpires 2h;#缓存2小时</span></span><br><span class=\"line\">\t<span class=\"comment\">#\texpires 2d;#缓存2天</span></span><br><span class=\"line\">\t\troot html/gzip;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h4><p>带宽资源很贵 /html/js/css压缩，/images不压缩<br>过程：nginx压缩 —-》网络传输 —》chrome解压（压缩和解压消耗cpu）</p>\n<ol>\n<li>浏览器携带支持的解压方式</li>\n<li>浏览器与nginx的交互</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ /(.*)\\.(html|js|css|jpg|jpeg|png|gif)$ &#123;<span class=\"comment\">#覆盖/re/a.htm路径</span></span><br><span class=\"line\">\t\tgzip on; <span class=\"comment\"># 启用gzip压缩，默认是off，不启用</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\"># 对js、css、jpg、png、gif格式的文件启用gzip压缩功能</span></span><br><span class=\"line\">\t\tgzip_types application/javascript text/css image/jpeg image/png image/gif;</span><br><span class=\"line\">\t\tgzip_min_length 1024; <span class=\"comment\"># 所压缩文件的最小值，小于这个的不会压缩</span></span><br><span class=\"line\">\t\tgzip_buffers 4 1k; <span class=\"comment\"># 设置压缩响应的缓冲块的大小和个数，默认是内存一个页的大小</span></span><br><span class=\"line\">\t\tgzip_comp_level 1; <span class=\"comment\"># 压缩水平，默认1。取值范围1-9，取值越大压缩比率越大，但越耗cpu时间</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\troot html/gzip;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Https\"><a href=\"#Https\" class=\"headerlink\" title=\"Https\"></a>Https</h4><p>nginx配置https的时候，需要两个东西：（此两样需购买）<br>一个key，私钥。放在nginx服务器里面，仅此一份<br>一个证书，公钥，供浏览器去下载。        </p>\n<blockquote>\n<p>nginx -V 需要有–with-http_ssl_module,表示安装了https模块。否则需要重新安装。</p>\n</blockquote>\n<p>配置如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssl_certificate      /etc/nginx/conf.d/server.crt;</span><br><span class=\"line\">ssl_certificate_key  /etc/nginx/conf.d/server_nopass.key;</span><br></pre></td></tr></table></figure>"},{"title":"docker基础","_content":"\ndocker\n\n### docker安装\n\n\n\n```sh\n\nyum update\n\n# 安装依赖\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\n# 添加源\nyum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo\n\n# 查看可安装的docker版本\nyum list docker-ce --showduplicates\n\n# 安装最新版本\nyum install docker-ce -y\n\n# 查看版本\ndocker -v\n\n# 启动docker\nsystemctl start docker\n\n# 查看docker 状态\nsystemctl status docker\n\n# 设置开机启动\nsystemctl enable docker\n\n# 设置docker镜像加速 阿里云地址 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors  通过修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://8cnlnwwc.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n\n<!-- more -->\n\n\n### docker基本概念\n\n\n- 镜像：包含容器运行环境的静态文件\n- 容器：容器的实质就是进程\n- 仓库\n- xx\n\n### docker简单操作\n\n\n#### docker安装mysql\n\n\n查询镜像的版本： [https://hub.docker.com/search?q=mysql](https://hub.docker.com/search?q=mysql) , 同时一个镜像的配置、环境变量之类的也可以在这个网址进行查询。\n\n\n查询到合适版本拉取mysql镜像\n\n```sh\n\n# 拉取镜像\ndocker pull mysql:5.7.38\n\n# 查看镜像\ndocker images\n\n# 宿主机创建mysql配置文件\n\n\n\n\n```","source":"_posts/docker-基础.md","raw":"---\ntitle: docker基础\ntags:\n  - docker\n---\n\ndocker\n\n### docker安装\n\n\n\n```sh\n\nyum update\n\n# 安装依赖\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\n# 添加源\nyum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo\n\n# 查看可安装的docker版本\nyum list docker-ce --showduplicates\n\n# 安装最新版本\nyum install docker-ce -y\n\n# 查看版本\ndocker -v\n\n# 启动docker\nsystemctl start docker\n\n# 查看docker 状态\nsystemctl status docker\n\n# 设置开机启动\nsystemctl enable docker\n\n# 设置docker镜像加速 阿里云地址 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors  通过修改daemon配置文件/etc/docker/daemon.json来使用加速器\n\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://8cnlnwwc.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n\n<!-- more -->\n\n\n### docker基本概念\n\n\n- 镜像：包含容器运行环境的静态文件\n- 容器：容器的实质就是进程\n- 仓库\n- xx\n\n### docker简单操作\n\n\n#### docker安装mysql\n\n\n查询镜像的版本： [https://hub.docker.com/search?q=mysql](https://hub.docker.com/search?q=mysql) , 同时一个镜像的配置、环境变量之类的也可以在这个网址进行查询。\n\n\n查询到合适版本拉取mysql镜像\n\n```sh\n\n# 拉取镜像\ndocker pull mysql:5.7.38\n\n# 查看镜像\ndocker images\n\n# 宿主机创建mysql配置文件\n\n\n\n\n```","slug":"docker-基础","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15ad000q9gj7vmhsobfp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>docker</p>\n<h3 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">yum update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加源</span></span><br><span class=\"line\">yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看可安装的docker版本</span></span><br><span class=\"line\">yum list docker-ce --showduplicates</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装最新版本</span></span><br><span class=\"line\">yum install docker-ce -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看版本</span></span><br><span class=\"line\">docker -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker</span></span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看docker 状态</span></span><br><span class=\"line\">systemctl status docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置开机启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置docker镜像加速 阿里云地址 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors  通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo mkdir -p /etc/docker</span><br><span class=\"line\">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://8cnlnwwc.mirror.aliyuncs.com\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"docker基本概念\"><a href=\"#docker基本概念\" class=\"headerlink\" title=\"docker基本概念\"></a>docker基本概念</h3><ul>\n<li>镜像：包含容器运行环境的静态文件</li>\n<li>容器：容器的实质就是进程</li>\n<li>仓库</li>\n<li>xx</li>\n</ul>\n<h3 id=\"docker简单操作\"><a href=\"#docker简单操作\" class=\"headerlink\" title=\"docker简单操作\"></a>docker简单操作</h3><h4 id=\"docker安装mysql\"><a href=\"#docker安装mysql\" class=\"headerlink\" title=\"docker安装mysql\"></a>docker安装mysql</h4><p>查询镜像的版本： <a href=\"https://hub.docker.com/search?q=mysql\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/search?q=mysql</a> , 同时一个镜像的配置、环境变量之类的也可以在这个网址进行查询。</p>\n<p>查询到合适版本拉取mysql镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取镜像</span></span><br><span class=\"line\">docker pull mysql:5.7.38</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看镜像</span></span><br><span class=\"line\">docker images</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 宿主机创建mysql配置文件</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>docker</p>\n<h3 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">yum update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加源</span></span><br><span class=\"line\">yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看可安装的docker版本</span></span><br><span class=\"line\">yum list docker-ce --showduplicates</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装最新版本</span></span><br><span class=\"line\">yum install docker-ce -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看版本</span></span><br><span class=\"line\">docker -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker</span></span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看docker 状态</span></span><br><span class=\"line\">systemctl status docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置开机启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置docker镜像加速 阿里云地址 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors  通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo mkdir -p /etc/docker</span><br><span class=\"line\">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">'EOF'</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"registry-mirrors\"</span>: [<span class=\"string\">\"https://8cnlnwwc.mirror.aliyuncs.com\"</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"docker基本概念\"><a href=\"#docker基本概念\" class=\"headerlink\" title=\"docker基本概念\"></a>docker基本概念</h3><ul>\n<li>镜像：包含容器运行环境的静态文件</li>\n<li>容器：容器的实质就是进程</li>\n<li>仓库</li>\n<li>xx</li>\n</ul>\n<h3 id=\"docker简单操作\"><a href=\"#docker简单操作\" class=\"headerlink\" title=\"docker简单操作\"></a>docker简单操作</h3><h4 id=\"docker安装mysql\"><a href=\"#docker安装mysql\" class=\"headerlink\" title=\"docker安装mysql\"></a>docker安装mysql</h4><p>查询镜像的版本： <a href=\"https://hub.docker.com/search?q=mysql\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/search?q=mysql</a> , 同时一个镜像的配置、环境变量之类的也可以在这个网址进行查询。</p>\n<p>查询到合适版本拉取mysql镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取镜像</span></span><br><span class=\"line\">docker pull mysql:5.7.38</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看镜像</span></span><br><span class=\"line\">docker images</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 宿主机创建mysql配置文件</span></span><br></pre></td></tr></table></figure>"},{"title":"Dubbo - rpc调用过程","_content":"\nDubbo rpc调用过程\n\n## Dubbo rpc调用过程\n\n- Dubbo的RPC服务暴露和引入\n\n![服务暴露和引入](http://image.tupelo.top/rpc%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2.png)\n\n<!-- more -->\n\n    - 服务暴露：建立一个中转对象（它能调到Impl），来接收网络请求，返回结果到网络\n    - 服务引入：找寻到对中转对象，创建一个代理，代理向中转对象传请求参数，等待返回值\n    - URL总线：中转对象---URL信息，一一对应，通过URL来找寻中转对象 \n    - URL包含完整rpc信息： rmi://192.168.56.1:20881/com.enjoy.service.ProductService?anyhost=true&application=storeServer&dubbo=2.5.7&generic=false&interface=com.enjoy.service.ProductService&methods=modify,getDetail,status&pid=2476&side=provider&timestamp=1542267315993\n\n- Dubbo的消费与服务端连接图示\n\n![连接图示](http://image.tupelo.top/%E6%B6%88%E8%B4%B9%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5.png)\n\n- Dubbo的启动流程\n\n![启动流程](http://image.tupelo.top/dubbo%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png)","source":"_posts/dubbo-03.md","raw":"---\ntitle: Dubbo - rpc调用过程\ntags:\n  - Dubbo\n---\n\nDubbo rpc调用过程\n\n## Dubbo rpc调用过程\n\n- Dubbo的RPC服务暴露和引入\n\n![服务暴露和引入](http://image.tupelo.top/rpc%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2.png)\n\n<!-- more -->\n\n    - 服务暴露：建立一个中转对象（它能调到Impl），来接收网络请求，返回结果到网络\n    - 服务引入：找寻到对中转对象，创建一个代理，代理向中转对象传请求参数，等待返回值\n    - URL总线：中转对象---URL信息，一一对应，通过URL来找寻中转对象 \n    - URL包含完整rpc信息： rmi://192.168.56.1:20881/com.enjoy.service.ProductService?anyhost=true&application=storeServer&dubbo=2.5.7&generic=false&interface=com.enjoy.service.ProductService&methods=modify,getDetail,status&pid=2476&side=provider&timestamp=1542267315993\n\n- Dubbo的消费与服务端连接图示\n\n![连接图示](http://image.tupelo.top/%E6%B6%88%E8%B4%B9%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5.png)\n\n- Dubbo的启动流程\n\n![启动流程](http://image.tupelo.top/dubbo%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png)","slug":"dubbo-03","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15af000t9gj7vfcwpqa2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Dubbo rpc调用过程</p>\n<h2 id=\"Dubbo-rpc调用过程\"><a href=\"#Dubbo-rpc调用过程\" class=\"headerlink\" title=\"Dubbo rpc调用过程\"></a>Dubbo rpc调用过程</h2><ul>\n<li>Dubbo的RPC服务暴露和引入</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/rpc%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2.png\" alt=\"服务暴露和引入\"></p>\n<a id=\"more\"></a>\n<pre><code>- 服务暴露：建立一个中转对象（它能调到Impl），来接收网络请求，返回结果到网络\n- 服务引入：找寻到对中转对象，创建一个代理，代理向中转对象传请求参数，等待返回值\n- URL总线：中转对象---URL信息，一一对应，通过URL来找寻中转对象 \n- URL包含完整rpc信息： rmi://192.168.56.1:20881/com.enjoy.service.ProductService?anyhost=true&amp;application=storeServer&amp;dubbo=2.5.7&amp;generic=false&amp;interface=com.enjoy.service.ProductService&amp;methods=modify,getDetail,status&amp;pid=2476&amp;side=provider&amp;timestamp=1542267315993\n</code></pre><ul>\n<li>Dubbo的消费与服务端连接图示</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/%E6%B6%88%E8%B4%B9%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5.png\" alt=\"连接图示\"></p>\n<ul>\n<li>Dubbo的启动流程</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/dubbo%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png\" alt=\"启动流程\"></p>\n","site":{"data":{}},"excerpt":"<p>Dubbo rpc调用过程</p>\n<h2 id=\"Dubbo-rpc调用过程\"><a href=\"#Dubbo-rpc调用过程\" class=\"headerlink\" title=\"Dubbo rpc调用过程\"></a>Dubbo rpc调用过程</h2><ul>\n<li>Dubbo的RPC服务暴露和引入</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/rpc%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2.png\" alt=\"服务暴露和引入\"></p>","more":"<pre><code>- 服务暴露：建立一个中转对象（它能调到Impl），来接收网络请求，返回结果到网络\n- 服务引入：找寻到对中转对象，创建一个代理，代理向中转对象传请求参数，等待返回值\n- URL总线：中转对象---URL信息，一一对应，通过URL来找寻中转对象 \n- URL包含完整rpc信息： rmi://192.168.56.1:20881/com.enjoy.service.ProductService?anyhost=true&amp;application=storeServer&amp;dubbo=2.5.7&amp;generic=false&amp;interface=com.enjoy.service.ProductService&amp;methods=modify,getDetail,status&amp;pid=2476&amp;side=provider&amp;timestamp=1542267315993\n</code></pre><ul>\n<li>Dubbo的消费与服务端连接图示</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/%E6%B6%88%E8%B4%B9%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5.png\" alt=\"连接图示\"></p>\n<ul>\n<li>Dubbo的启动流程</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/dubbo%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png\" alt=\"启动流程\"></p>"},{"title":"Dubbo基础 - 配置","_content":"\nDubbo基础学习配置\n\n## Dubbo 基本使用和配置\n\ndubbo主要是使不同的服务通过注册中心互相调用，可以解耦。但是依赖于spring,就是一个spring项目和一个python项目无法通过dubbo互相调用，通过consul可以互相调用。\n\n问题：dubbo调用和maven依赖有什么区别(待查证)\n\n\n### Dubbo配置的四种方式\n\n> XML配置 (使用最多)\n\n> 注解配置\n\n> 配置文件配置\n\n> API配置（研究Dubbo的入口）\n\n<!-- more -->\n- 添加dubbo所需要的依赖（zkclient dubbo）两个\n\n```java\n<dependency>\n\t<groupId>com.101tec</groupId>\n\t<artifactId>zkclient</artifactId>\n\t<version>0.3</version>\n</dependency>\n\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>dubbo</artifactId>\n\t<version>2.5.7</version>\n\t<scope>compile</scope>\n\t<exclusions>\n\t\t<exclusion>\n\t\t\t<artifactId>spring</artifactId>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n```\n\n- 新建dubbo的xml配置文件 首先是生产者provider的配置文件（以product为例）\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n             http://www.springframework.org/schema/beans/spring-beans.xsd\n             http://code.alibabatech.com/schema/dubbo\n             http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 提供方应用信息 用于计算依赖关系 -->\n    <dubbo:application name=\"productService\"/>\n    <!-- 调用协议 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n\n\t<!-- 生成远程服务代理 可以和本地bean一样使用demoService  -->\n    <dubbo:service interface=\"com.tupelo.dubboproduct.service.Product2Service\" ref=\"product2Service\" protocol=\"dubbo\"/>\n</beans>\n\t\n```\n\n消费者consumer配置文件\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t http://www.springframework.org/schema/beans/spring-beans.xsd        \n\t http://code.alibabatech.com/schema/dubbo        \n\t http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 提供方应用信息 用于计算依赖关系 -->\n    <dubbo:application name=\"enjoyStore\"/>\n\n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n\n    <dubbo:consumer check=\"false\"/>\n\n    <!-- 生成远程服务代理 可以和本地bean一样使用demoService -->\n    <dubbo:reference id=\"userService\" interface=\"com.enjoy.service.UserService\"  />\n</beans>\n```\n\n- 配置文件配置方式 在properties文件中配置相关属性补充xml中没有的属性 优先级最低 (yml文件为例)\n\n```java\ndubbo:\n  protocol:\n    name: dubbo\n    port: 20880\n  application:\n    name: productService\n  registry:\n    address: zookeeper://localhost:2181\n```\n\n- 注解方式（半注解方式 springboot是使用全部注解）使用<dubbo:annotation>去代替<dubbo:reference>和<dubbo:service>标签 同时生产者Service注解使用dubbo的注解 消费者的调用时使用@Reference注解代替@Autowired注解\n\n```java\n\n<dubbo:annotation package=\"com.cc.controller\" />\n\n调用时：\n\t//@Autowired\n\t@Reference\n    private ProductService productService;\n\n实现类：\n\t//@org.springframework.stereotype.Service\n\t@com.alibaba.dubbo.config.annotation.Service\n\tpublic class ProductServiceImpl implements ProductService(){...}\n```\n\n- API方式（待定）\n\n\n\n","source":"_posts/dubbo-01.md","raw":"---\ntitle: Dubbo基础 - 配置\ntags:\n  - Dubbo\n---\n\nDubbo基础学习配置\n\n## Dubbo 基本使用和配置\n\ndubbo主要是使不同的服务通过注册中心互相调用，可以解耦。但是依赖于spring,就是一个spring项目和一个python项目无法通过dubbo互相调用，通过consul可以互相调用。\n\n问题：dubbo调用和maven依赖有什么区别(待查证)\n\n\n### Dubbo配置的四种方式\n\n> XML配置 (使用最多)\n\n> 注解配置\n\n> 配置文件配置\n\n> API配置（研究Dubbo的入口）\n\n<!-- more -->\n- 添加dubbo所需要的依赖（zkclient dubbo）两个\n\n```java\n<dependency>\n\t<groupId>com.101tec</groupId>\n\t<artifactId>zkclient</artifactId>\n\t<version>0.3</version>\n</dependency>\n\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>dubbo</artifactId>\n\t<version>2.5.7</version>\n\t<scope>compile</scope>\n\t<exclusions>\n\t\t<exclusion>\n\t\t\t<artifactId>spring</artifactId>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n```\n\n- 新建dubbo的xml配置文件 首先是生产者provider的配置文件（以product为例）\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n             http://www.springframework.org/schema/beans/spring-beans.xsd\n             http://code.alibabatech.com/schema/dubbo\n             http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 提供方应用信息 用于计算依赖关系 -->\n    <dubbo:application name=\"productService\"/>\n    <!-- 调用协议 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\"/>\n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n\n\t<!-- 生成远程服务代理 可以和本地bean一样使用demoService  -->\n    <dubbo:service interface=\"com.tupelo.dubboproduct.service.Product2Service\" ref=\"product2Service\" protocol=\"dubbo\"/>\n</beans>\n\t\n```\n\n消费者consumer配置文件\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t http://www.springframework.org/schema/beans/spring-beans.xsd        \n\t http://code.alibabatech.com/schema/dubbo        \n\t http://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n    <!-- 提供方应用信息 用于计算依赖关系 -->\n    <dubbo:application name=\"enjoyStore\"/>\n\n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n\n    <dubbo:consumer check=\"false\"/>\n\n    <!-- 生成远程服务代理 可以和本地bean一样使用demoService -->\n    <dubbo:reference id=\"userService\" interface=\"com.enjoy.service.UserService\"  />\n</beans>\n```\n\n- 配置文件配置方式 在properties文件中配置相关属性补充xml中没有的属性 优先级最低 (yml文件为例)\n\n```java\ndubbo:\n  protocol:\n    name: dubbo\n    port: 20880\n  application:\n    name: productService\n  registry:\n    address: zookeeper://localhost:2181\n```\n\n- 注解方式（半注解方式 springboot是使用全部注解）使用<dubbo:annotation>去代替<dubbo:reference>和<dubbo:service>标签 同时生产者Service注解使用dubbo的注解 消费者的调用时使用@Reference注解代替@Autowired注解\n\n```java\n\n<dubbo:annotation package=\"com.cc.controller\" />\n\n调用时：\n\t//@Autowired\n\t@Reference\n    private ProductService productService;\n\n实现类：\n\t//@org.springframework.stereotype.Service\n\t@com.alibaba.dubbo.config.annotation.Service\n\tpublic class ProductServiceImpl implements ProductService(){...}\n```\n\n- API方式（待定）\n\n\n\n","slug":"dubbo-01","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15af000v9gj7pb3di8sn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Dubbo基础学习配置</p>\n<h2 id=\"Dubbo-基本使用和配置\"><a href=\"#Dubbo-基本使用和配置\" class=\"headerlink\" title=\"Dubbo 基本使用和配置\"></a>Dubbo 基本使用和配置</h2><p>dubbo主要是使不同的服务通过注册中心互相调用，可以解耦。但是依赖于spring,就是一个spring项目和一个python项目无法通过dubbo互相调用，通过consul可以互相调用。</p>\n<p>问题：dubbo调用和maven依赖有什么区别(待查证)</p>\n<h3 id=\"Dubbo配置的四种方式\"><a href=\"#Dubbo配置的四种方式\" class=\"headerlink\" title=\"Dubbo配置的四种方式\"></a>Dubbo配置的四种方式</h3><blockquote>\n<p>XML配置 (使用最多)</p>\n</blockquote>\n<blockquote>\n<p>注解配置</p>\n</blockquote>\n<blockquote>\n<p>配置文件配置</p>\n</blockquote>\n<blockquote>\n<p>API配置（研究Dubbo的入口）</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li>添加dubbo所需要的依赖（zkclient dubbo）两个</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;0.3&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.5.7&lt;/version&gt;</span><br><span class=\"line\">\t&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class=\"line\">\t&lt;exclusions&gt;</span><br><span class=\"line\">\t\t&lt;exclusion&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;/exclusion&gt;</span><br><span class=\"line\">\t&lt;/exclusions&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建dubbo的xml配置文件 首先是生产者provider的配置文件（以product为例）</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns:dubbo=<span class=\"string\">\"http://code.alibabatech.com/schema/dubbo\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span><br><span class=\"line\"><span class=\"string\">             http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class=\"line\"><span class=\"string\">             http://code.alibabatech.com/schema/dubbo</span></span><br><span class=\"line\"><span class=\"string\">             http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 提供方应用信息 用于计算依赖关系 --&gt;</span><br><span class=\"line\">    &lt;dubbo:application name=<span class=\"string\">\"productService\"</span>/&gt;</span><br><span class=\"line\">    &lt;!-- 调用协议 --&gt;</span><br><span class=\"line\">    &lt;dubbo:protocol name=<span class=\"string\">\"dubbo\"</span> port=<span class=\"string\">\"20880\"</span>/&gt;</span><br><span class=\"line\">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class=\"line\">    &lt;dubbo:registry address=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!-- 生成远程服务代理 可以和本地bean一样使用demoService  --&gt;</span><br><span class=\"line\">    &lt;dubbo:service <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span> ref=<span class=\"string\">\"product2Service\"</span> protocol=<span class=\"string\">\"dubbo\"</span>/&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>消费者consumer配置文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns:dubbo=<span class=\"string\">\"http://code.alibabatech.com/schema/dubbo\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span><br><span class=\"line\"><span class=\"string\">\t http://www.springframework.org/schema/beans/spring-beans.xsd        </span></span><br><span class=\"line\"><span class=\"string\">\t http://code.alibabatech.com/schema/dubbo        </span></span><br><span class=\"line\"><span class=\"string\">\t http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 提供方应用信息 用于计算依赖关系 --&gt;</span><br><span class=\"line\">    &lt;dubbo:application name=<span class=\"string\">\"enjoyStore\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class=\"line\">    &lt;dubbo:registry address=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dubbo:consumer check=<span class=\"string\">\"false\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 生成远程服务代理 可以和本地bean一样使用demoService --&gt;</span><br><span class=\"line\">    &lt;dubbo:reference id=<span class=\"string\">\"userService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.UserService\"</span>  /&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>配置文件配置方式 在properties文件中配置相关属性补充xml中没有的属性 优先级最低 (yml文件为例)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo:</span><br><span class=\"line\">  protocol:</span><br><span class=\"line\">    name: dubbo</span><br><span class=\"line\">    port: <span class=\"number\">20880</span></span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: productService</span><br><span class=\"line\">  registry:</span><br><span class=\"line\">    address: zookeeper:<span class=\"comment\">//localhost:2181</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>注解方式（半注解方式 springboot是使用全部注解）使用<a href=\"dubbo:annotation\" target=\"_blank\" rel=\"noopener\">dubbo:annotation</a>去代替<a href=\"dubbo:reference\" target=\"_blank\" rel=\"noopener\">dubbo:reference</a>和<a href=\"dubbo:service\" target=\"_blank\" rel=\"noopener\">dubbo:service</a>标签 同时生产者Service注解使用dubbo的注解 消费者的调用时使用@Reference注解代替@Autowired注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;dubbo:annotation <span class=\"keyword\">package</span>=<span class=\"string\">\"com.cc.controller\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">调用时：</span><br><span class=\"line\">\t<span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Reference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ProductService productService;</span><br><span class=\"line\"></span><br><span class=\"line\">实现类：</span><br><span class=\"line\">\t<span class=\"comment\">//@org.springframework.stereotype.Service</span></span><br><span class=\"line\">\t<span class=\"meta\">@com</span>.alibaba.dubbo.config.annotation.Service</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> class ProductServiceImpl implements <span class=\"title\">ProductService</span><span class=\"params\">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>API方式（待定）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Dubbo基础学习配置</p>\n<h2 id=\"Dubbo-基本使用和配置\"><a href=\"#Dubbo-基本使用和配置\" class=\"headerlink\" title=\"Dubbo 基本使用和配置\"></a>Dubbo 基本使用和配置</h2><p>dubbo主要是使不同的服务通过注册中心互相调用，可以解耦。但是依赖于spring,就是一个spring项目和一个python项目无法通过dubbo互相调用，通过consul可以互相调用。</p>\n<p>问题：dubbo调用和maven依赖有什么区别(待查证)</p>\n<h3 id=\"Dubbo配置的四种方式\"><a href=\"#Dubbo配置的四种方式\" class=\"headerlink\" title=\"Dubbo配置的四种方式\"></a>Dubbo配置的四种方式</h3><blockquote>\n<p>XML配置 (使用最多)</p>\n</blockquote>\n<blockquote>\n<p>注解配置</p>\n</blockquote>\n<blockquote>\n<p>配置文件配置</p>\n</blockquote>\n<blockquote>\n<p>API配置（研究Dubbo的入口）</p>\n</blockquote>","more":"<ul>\n<li>添加dubbo所需要的依赖（zkclient dubbo）两个</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;0.3&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;2.5.7&lt;/version&gt;</span><br><span class=\"line\">\t&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class=\"line\">\t&lt;exclusions&gt;</span><br><span class=\"line\">\t\t&lt;exclusion&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">\t\t&lt;/exclusion&gt;</span><br><span class=\"line\">\t&lt;/exclusions&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建dubbo的xml配置文件 首先是生产者provider的配置文件（以product为例）</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns:dubbo=<span class=\"string\">\"http://code.alibabatech.com/schema/dubbo\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span><br><span class=\"line\"><span class=\"string\">             http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class=\"line\"><span class=\"string\">             http://code.alibabatech.com/schema/dubbo</span></span><br><span class=\"line\"><span class=\"string\">             http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 提供方应用信息 用于计算依赖关系 --&gt;</span><br><span class=\"line\">    &lt;dubbo:application name=<span class=\"string\">\"productService\"</span>/&gt;</span><br><span class=\"line\">    &lt;!-- 调用协议 --&gt;</span><br><span class=\"line\">    &lt;dubbo:protocol name=<span class=\"string\">\"dubbo\"</span> port=<span class=\"string\">\"20880\"</span>/&gt;</span><br><span class=\"line\">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class=\"line\">    &lt;dubbo:registry address=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!-- 生成远程服务代理 可以和本地bean一样使用demoService  --&gt;</span><br><span class=\"line\">    &lt;dubbo:service <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span> ref=<span class=\"string\">\"product2Service\"</span> protocol=<span class=\"string\">\"dubbo\"</span>/&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>消费者consumer配置文件</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"UTF-8\"</span>?&gt;</span><br><span class=\"line\">&lt;beans xmlns=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span><br><span class=\"line\">       xmlns:xsi=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span><br><span class=\"line\">       xmlns:dubbo=<span class=\"string\">\"http://code.alibabatech.com/schema/dubbo\"</span></span><br><span class=\"line\">       xsi:schemaLocation=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span><br><span class=\"line\"><span class=\"string\">\t http://www.springframework.org/schema/beans/spring-beans.xsd        </span></span><br><span class=\"line\"><span class=\"string\">\t http://code.alibabatech.com/schema/dubbo        </span></span><br><span class=\"line\"><span class=\"string\">\t http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 提供方应用信息 用于计算依赖关系 --&gt;</span><br><span class=\"line\">    &lt;dubbo:application name=<span class=\"string\">\"enjoyStore\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class=\"line\">    &lt;dubbo:registry address=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dubbo:consumer check=<span class=\"string\">\"false\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 生成远程服务代理 可以和本地bean一样使用demoService --&gt;</span><br><span class=\"line\">    &lt;dubbo:reference id=<span class=\"string\">\"userService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.UserService\"</span>  /&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>配置文件配置方式 在properties文件中配置相关属性补充xml中没有的属性 优先级最低 (yml文件为例)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo:</span><br><span class=\"line\">  protocol:</span><br><span class=\"line\">    name: dubbo</span><br><span class=\"line\">    port: <span class=\"number\">20880</span></span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: productService</span><br><span class=\"line\">  registry:</span><br><span class=\"line\">    address: zookeeper:<span class=\"comment\">//localhost:2181</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>注解方式（半注解方式 springboot是使用全部注解）使用<a href=\"dubbo:annotation\" target=\"_blank\" rel=\"noopener\">dubbo:annotation</a>去代替<a href=\"dubbo:reference\" target=\"_blank\" rel=\"noopener\">dubbo:reference</a>和<a href=\"dubbo:service\" target=\"_blank\" rel=\"noopener\">dubbo:service</a>标签 同时生产者Service注解使用dubbo的注解 消费者的调用时使用@Reference注解代替@Autowired注解</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;dubbo:annotation <span class=\"keyword\">package</span>=<span class=\"string\">\"com.cc.controller\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">调用时：</span><br><span class=\"line\">\t<span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Reference</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ProductService productService;</span><br><span class=\"line\"></span><br><span class=\"line\">实现类：</span><br><span class=\"line\">\t<span class=\"comment\">//@org.springframework.stereotype.Service</span></span><br><span class=\"line\">\t<span class=\"meta\">@com</span>.alibaba.dubbo.config.annotation.Service</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> class ProductServiceImpl implements <span class=\"title\">ProductService</span><span class=\"params\">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>API方式（待定）</li>\n</ul>"},{"title":"Dubbo基础 - 配置文件","_content":"\nDubbo基础学习配置\n\n## Dubbo 配置文件\n\n- 消费方配置  \n\n> check\n\n```java\n <dubbo:consumer timeout=\"3000\" check=\"false\"/>\n```\n\ncheck = false 防止启动报错 没有提供者会自动生成代理(测试环境使用)  \ncheck = true 没有提供者直接报错(正式环境使用)\n\n<!-- more -->\n\n> cluster 负载策略(常用的两种)\n\n```java\n<dubbo:reference id=\"productService\" interface=\"com.tupelo.service.ProductService\" cluster=\"failover\" />\n```  \nfailover 重试其他服务 retries 重试次数  \nfailfast 直接报错\n\n> loadbalance 负载配置\n\n```java\n//消费者\n<dubbo:reference id=\"productService\" interface=\"com.tupelo.service.ProductService\"loadbalance=\"random\" />\n\n// 提供者\n<dubbo:service interface=\"com.tupelo.dubboproduct.service.ProductService\" ref=\"productService\" protocol=\"dubbo\" weight=\"20\"/>\n\n```  \nrandom   按权重随机（权重 服务方配置 weight）  \nroundRobin 轮询  \nleastActive 按活跃程度\n\n> 开启缓存\n\n```java\n<dubbo:reference id=\"productService2\" interface=\"com.tupelo.dubboproduct.service.Product2Service\">\n        <dubbo:method name=\"getProduct\" cache=\"lru\"></dubbo:method>\n</dubbo:reference>\n```  \nrandom   按权重随机（权重 服务方配置 weight） \nroundRobin 轮询  \nleastActive 按活跃程度  \n..(自定义缓存)\n\n> 异步请求 async=\"true\" 通常是配合时间通知一起处理 单独处理使用Future类(不提倡)\n\n```java\n<dubbo:reference id=\"productService2\" interface=\"com.tupelo.dubboproduct.service.Product2Service\" async=\"true\">\n    <dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"></dubbo:method>\n</dubbo:reference>\n```  \n\n> 事件通知 回调方法一个参数为返回参数 其它参数为入参\n\n```java\n<dubbo:reference id=\"productService2\" interface=\"com.tupelo.dubboproduct.service.Product2Service\">\n    <dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"></dubbo:method>\n</dubbo:reference>\n```  \nonreturn 正常返回回调  \nonthrow 方法异常回调\n\n> 回声测试 检查服务是否已经就绪\n\n```java \npublic HashMap test(HttpServletRequest request, HttpServletResponse response) {\n        String[] serviceIds = new String[]{\"productService\",\"userService\",\"orderService\",\"payService\"};\n        HashMap<String,String> retMap = new HashMap<>();\n\n        Object ret = null;\n        for (String id:serviceIds){\n            try {\n                EchoService echoService = (EchoService)ctx.getBean(id);\n                ret = echoService.$echo(\"ok\");\n                retMap.put(id,ret.toString());\n            } catch (Exception e) {\n                retMap.put(id,\"not ready\");\n            }\n        }\n\n        return retMap;\n\n    }\n```\n\n> 泛化调用 当A项目没有得到B项目的接口描述 但是还是想调用B项目的接口\n\n1 配置dubbo引入，设置generic = true\n```java\n<dubbo:reference id=\"otherService\" interface=\"com.enjoy.service.OtherService\" generic=\"true\" />\n```\n2 从IOC容器中取出代理对象，转为泛型接口对象 通过$invoke方法调用目标方法（传入方法名/参数类型/参数值）\n\n```java\npublic String other(HttpServletRequest request, HttpServletResponse response) {\n        GenericService genericService = (GenericService)ctx.getBean(\"otherService\");\n        Object ret = genericService.$invoke(\"getDetail\",new String[]{\"java.lang.String\"},new Object[]{\"name\"});\n        return ret.toString();\n    }\n```","source":"_posts/dubbo-02.md","raw":"---\ntitle: Dubbo基础 - 配置文件\ntags:\n  - Dubbo\n---\n\nDubbo基础学习配置\n\n## Dubbo 配置文件\n\n- 消费方配置  \n\n> check\n\n```java\n <dubbo:consumer timeout=\"3000\" check=\"false\"/>\n```\n\ncheck = false 防止启动报错 没有提供者会自动生成代理(测试环境使用)  \ncheck = true 没有提供者直接报错(正式环境使用)\n\n<!-- more -->\n\n> cluster 负载策略(常用的两种)\n\n```java\n<dubbo:reference id=\"productService\" interface=\"com.tupelo.service.ProductService\" cluster=\"failover\" />\n```  \nfailover 重试其他服务 retries 重试次数  \nfailfast 直接报错\n\n> loadbalance 负载配置\n\n```java\n//消费者\n<dubbo:reference id=\"productService\" interface=\"com.tupelo.service.ProductService\"loadbalance=\"random\" />\n\n// 提供者\n<dubbo:service interface=\"com.tupelo.dubboproduct.service.ProductService\" ref=\"productService\" protocol=\"dubbo\" weight=\"20\"/>\n\n```  \nrandom   按权重随机（权重 服务方配置 weight）  \nroundRobin 轮询  \nleastActive 按活跃程度\n\n> 开启缓存\n\n```java\n<dubbo:reference id=\"productService2\" interface=\"com.tupelo.dubboproduct.service.Product2Service\">\n        <dubbo:method name=\"getProduct\" cache=\"lru\"></dubbo:method>\n</dubbo:reference>\n```  \nrandom   按权重随机（权重 服务方配置 weight） \nroundRobin 轮询  \nleastActive 按活跃程度  \n..(自定义缓存)\n\n> 异步请求 async=\"true\" 通常是配合时间通知一起处理 单独处理使用Future类(不提倡)\n\n```java\n<dubbo:reference id=\"productService2\" interface=\"com.tupelo.dubboproduct.service.Product2Service\" async=\"true\">\n    <dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"></dubbo:method>\n</dubbo:reference>\n```  \n\n> 事件通知 回调方法一个参数为返回参数 其它参数为入参\n\n```java\n<dubbo:reference id=\"productService2\" interface=\"com.tupelo.dubboproduct.service.Product2Service\">\n    <dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"></dubbo:method>\n</dubbo:reference>\n```  \nonreturn 正常返回回调  \nonthrow 方法异常回调\n\n> 回声测试 检查服务是否已经就绪\n\n```java \npublic HashMap test(HttpServletRequest request, HttpServletResponse response) {\n        String[] serviceIds = new String[]{\"productService\",\"userService\",\"orderService\",\"payService\"};\n        HashMap<String,String> retMap = new HashMap<>();\n\n        Object ret = null;\n        for (String id:serviceIds){\n            try {\n                EchoService echoService = (EchoService)ctx.getBean(id);\n                ret = echoService.$echo(\"ok\");\n                retMap.put(id,ret.toString());\n            } catch (Exception e) {\n                retMap.put(id,\"not ready\");\n            }\n        }\n\n        return retMap;\n\n    }\n```\n\n> 泛化调用 当A项目没有得到B项目的接口描述 但是还是想调用B项目的接口\n\n1 配置dubbo引入，设置generic = true\n```java\n<dubbo:reference id=\"otherService\" interface=\"com.enjoy.service.OtherService\" generic=\"true\" />\n```\n2 从IOC容器中取出代理对象，转为泛型接口对象 通过$invoke方法调用目标方法（传入方法名/参数类型/参数值）\n\n```java\npublic String other(HttpServletRequest request, HttpServletResponse response) {\n        GenericService genericService = (GenericService)ctx.getBean(\"otherService\");\n        Object ret = genericService.$invoke(\"getDetail\",new String[]{\"java.lang.String\"},new Object[]{\"name\"});\n        return ret.toString();\n    }\n```","slug":"dubbo-02","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15ah000x9gj70i70ogpw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Dubbo基础学习配置</p>\n<h2 id=\"Dubbo-配置文件\"><a href=\"#Dubbo-配置文件\" class=\"headerlink\" title=\"Dubbo 配置文件\"></a>Dubbo 配置文件</h2><ul>\n<li>消费方配置  </li>\n</ul>\n<blockquote>\n<p>check</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:consumer timeout=<span class=\"string\">\"3000\"</span> check=<span class=\"string\">\"false\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>check = false 防止启动报错 没有提供者会自动生成代理(测试环境使用)<br>check = true 没有提供者直接报错(正式环境使用)</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>cluster 负载策略(常用的两种)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.service.ProductService\"</span> cluster=<span class=\"string\">\"failover\"</span> /&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\">failover 重试其他服务 retries 重试次数  </span><br><span class=\"line\">failfast 直接报错</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; loadbalance 负载配置</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.service.ProductService\"</span>loadbalance=<span class=\"string\">\"random\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提供者</span></span><br><span class=\"line\">&lt;dubbo:service <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.ProductService\"</span> ref=<span class=\"string\">\"productService\"</span> protocol=<span class=\"string\">\"dubbo\"</span> weight=<span class=\"string\">\"20\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">```  </span><br><span class=\"line\">random   按权重随机（权重 服务方配置 weight）  </span><br><span class=\"line\">roundRobin 轮询  </span><br><span class=\"line\">leastActive 按活跃程度</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 开启缓存</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService2\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span>&gt;</span><br><span class=\"line\">        &lt;dubbo:method name=\"getProduct\" cache=\"lru\"&gt;&lt;/dubbo:method&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\">random   按权重随机（权重 服务方配置 weight） </span><br><span class=\"line\">roundRobin 轮询  </span><br><span class=\"line\">leastActive 按活跃程度  </span><br><span class=\"line\">..(自定义缓存)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 异步请求 async=<span class=\"string\">\"true\"</span> 通常是配合时间通知一起处理 单独处理使用Future类(不提倡)</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService2\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span> async=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"&gt;&lt;/dubbo:method&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 事件通知 回调方法一个参数为返回参数 其它参数为入参</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService2\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span>&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"&gt;&lt;/dubbo:method&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\">onreturn 正常返回回调  </span><br><span class=\"line\">onthrow 方法异常回调</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 回声测试 检查服务是否已经就绪</span><br><span class=\"line\"></span><br><span class=\"line\">```java </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HashMap <span class=\"title\">test</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        String[] serviceIds = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"productService\"</span>,<span class=\"string\">\"userService\"</span>,<span class=\"string\">\"orderService\"</span>,<span class=\"string\">\"payService\"</span>&#125;;</span><br><span class=\"line\">        HashMap&lt;String,String&gt; retMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Object ret = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String id:serviceIds)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                EchoService echoService = (EchoService)ctx.getBean(id);</span><br><span class=\"line\">                ret = echoService.$echo(<span class=\"string\">\"ok\"</span>);</span><br><span class=\"line\">                retMap.put(id,ret.toString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                retMap.put(id,<span class=\"string\">\"not ready\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> retMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>泛化调用 当A项目没有得到B项目的接口描述 但是还是想调用B项目的接口</p>\n</blockquote>\n<p>1 配置dubbo引入，设置generic = true<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"otherService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.OtherService\"</span> generic=<span class=\"string\">\"true\"</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>2 从IOC容器中取出代理对象，转为泛型接口对象 通过$invoke方法调用目标方法（传入方法名/参数类型/参数值）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">other</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        GenericService genericService = (GenericService)ctx.getBean(<span class=\"string\">\"otherService\"</span>);</span><br><span class=\"line\">        Object ret = genericService.$invoke(<span class=\"string\">\"getDetail\"</span>,<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"java.lang.String\"</span>&#125;,<span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">\"name\"</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toString();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Dubbo基础学习配置</p>\n<h2 id=\"Dubbo-配置文件\"><a href=\"#Dubbo-配置文件\" class=\"headerlink\" title=\"Dubbo 配置文件\"></a>Dubbo 配置文件</h2><ul>\n<li>消费方配置  </li>\n</ul>\n<blockquote>\n<p>check</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:consumer timeout=<span class=\"string\">\"3000\"</span> check=<span class=\"string\">\"false\"</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>check = false 防止启动报错 没有提供者会自动生成代理(测试环境使用)<br>check = true 没有提供者直接报错(正式环境使用)</p>","more":"<blockquote>\n<p>cluster 负载策略(常用的两种)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.service.ProductService\"</span> cluster=<span class=\"string\">\"failover\"</span> /&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\">failover 重试其他服务 retries 重试次数  </span><br><span class=\"line\">failfast 直接报错</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; loadbalance 负载配置</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.service.ProductService\"</span>loadbalance=<span class=\"string\">\"random\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提供者</span></span><br><span class=\"line\">&lt;dubbo:service <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.ProductService\"</span> ref=<span class=\"string\">\"productService\"</span> protocol=<span class=\"string\">\"dubbo\"</span> weight=<span class=\"string\">\"20\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">```  </span><br><span class=\"line\">random   按权重随机（权重 服务方配置 weight）  </span><br><span class=\"line\">roundRobin 轮询  </span><br><span class=\"line\">leastActive 按活跃程度</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 开启缓存</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService2\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span>&gt;</span><br><span class=\"line\">        &lt;dubbo:method name=\"getProduct\" cache=\"lru\"&gt;&lt;/dubbo:method&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\">random   按权重随机（权重 服务方配置 weight） </span><br><span class=\"line\">roundRobin 轮询  </span><br><span class=\"line\">leastActive 按活跃程度  </span><br><span class=\"line\">..(自定义缓存)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 异步请求 async=<span class=\"string\">\"true\"</span> 通常是配合时间通知一起处理 单独处理使用Future类(不提倡)</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService2\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span> async=<span class=\"string\">\"true\"</span>&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"&gt;&lt;/dubbo:method&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 事件通知 回调方法一个参数为返回参数 其它参数为入参</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"productService2\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.tupelo.dubboproduct.service.Product2Service\"</span>&gt;</span><br><span class=\"line\">    &lt;dubbo:method name=\"getProduct\" cache=\"lru\" onreturn=\"returnCallback\" onthrow=\"errorCallback\"&gt;&lt;/dubbo:method&gt;</span><br><span class=\"line\">&lt;/dubbo:reference&gt;</span><br><span class=\"line\">```  </span><br><span class=\"line\">onreturn 正常返回回调  </span><br><span class=\"line\">onthrow 方法异常回调</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 回声测试 检查服务是否已经就绪</span><br><span class=\"line\"></span><br><span class=\"line\">```java </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HashMap <span class=\"title\">test</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        String[] serviceIds = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"productService\"</span>,<span class=\"string\">\"userService\"</span>,<span class=\"string\">\"orderService\"</span>,<span class=\"string\">\"payService\"</span>&#125;;</span><br><span class=\"line\">        HashMap&lt;String,String&gt; retMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Object ret = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String id:serviceIds)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                EchoService echoService = (EchoService)ctx.getBean(id);</span><br><span class=\"line\">                ret = echoService.$echo(<span class=\"string\">\"ok\"</span>);</span><br><span class=\"line\">                retMap.put(id,ret.toString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                retMap.put(id,<span class=\"string\">\"not ready\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> retMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>泛化调用 当A项目没有得到B项目的接口描述 但是还是想调用B项目的接口</p>\n</blockquote>\n<p>1 配置dubbo引入，设置generic = true<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference id=<span class=\"string\">\"otherService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.OtherService\"</span> generic=<span class=\"string\">\"true\"</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>2 从IOC容器中取出代理对象，转为泛型接口对象 通过$invoke方法调用目标方法（传入方法名/参数类型/参数值）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">other</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        GenericService genericService = (GenericService)ctx.getBean(<span class=\"string\">\"otherService\"</span>);</span><br><span class=\"line\">        Object ret = genericService.$invoke(<span class=\"string\">\"getDetail\"</span>,<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"java.lang.String\"</span>&#125;,<span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">\"name\"</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.toString();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo - Spi机制","_content":"\nDubbo Spi机制\n\n## Dubbo Spi机制\n\n本质是解决同一个接口，有多种实现时，使用者如何能够方便选择实现的问题\n\n\n<!-- more -->\n\n\n#### Spi机制(策略模式)\n\n\n- jdk的Spi机制\n\n![jdk的Spi机制](http://image.tupelo.top/jdkspi.png)\n\njdk中，选择SpiService的实现，方法是在jar中放置一个META-INF/services目录，目录中存放一个文本文件(文件名----是SpiService接口的全路径名)，文本中列入你选择的实现类(一行放一个------是实现类的全路径名),有了上述配置，在java程序中，使用ServiceLoader.load(SpiService.class)，\n即可将配置中选择的实现类，实例化并放入一个集合中\n\n```java\n//配置文件\ncom.enjoy.spi.service.RmiSpiServiceImpl\ncom.enjoy.spi.service.RestSpiServiceImpl\n\n//加载\npublic static void main(String[] args) throws IOException {\n        //加载接口\n        ServiceLoader<SpiService> spiLoader = ServiceLoader.load(SpiService.class);\n        Iterator<SpiService> iteratorSpi = spiLoader.iterator();\n        while (iteratorSpi.hasNext()) {\n            SpiService spiService = iteratorSpi.next();\n            spiService.sayHello();\n        }\n}\n```\n\n- Dubbo的Spi机制\n\n![spi机制](http://image.tupelo.top/spi%E6%9C%BA%E5%88%B6.png)\n\n```java\n<dubbo:reference  id=\"productService\" cluster=\"failover\" interface=\"com.enjoy.service.ProductService\" />\n<dubbo:reference  id=\"productService1\" cluster=\"failsafe\" interface=\"com.enjoy.service.ProductService\" />\n<dubbo:reference  id=\"productService2\" cluster=\"failfast\" interface=\"com.enjoy.service.ProductService\" />\n```\n\n与jdk相比,dubbo将选择权下放到了配置文件中(你配置谁，它使为你实例化谁)dubbo的目标,以cluster为例,failsafe/failover/failfast都是cluster的一种实现,现在我    们可以在标签配置时,方便地进行选择.凡是dubbo中,接口上有 @SPI 标注的，都表明此接口支持扩展.\n\n\n- 自定义扩展(LoadBalance为例)\n\n引入maven支持\n```java\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.5.7</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n新建一个类 定义使用第一个服务的负载规则\n```java\npublic class FirstLoadBalance implements LoadBalance {//filter\n    /**\n     * @param invokers 所有provider的实现\n     * @param url\n     * @param invocation\n     * @param <T>\n     * @return\n     * @throws RpcException\n     */\n    @Override\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation)\n            throws RpcException {\n        System.out.println(\"启动第一个\");\n        //固定使用第一个\n        return invokers.get(0);\n    }\n}\n```\n\n添加配置文件 路径为 resources/META-INF/dubbo,文件名和接口(LoadBalance)全路径名一样,com.alibaba.dubbo.rpc.cluster.LoadBalance,以 key-value 方式添加内容\n\n```java\nfirst=com.enjoy.loadbalance.FirstLoadBalance\n```\n\n在消费方dubbo配置文件中就可以使用自定义规则了\n\n```java\n<dubbo:reference  id=\"userService\" interface=\"com.enjoy.service.UserService\" loadbalance=\"first\" />\n\n```\n\n\n#### Spi实现原理---核心ExtensionLoader\n\nprotocol是个代理类，不是真实的协议实现\n\n```java\nprivate static final Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n```\n\n    ExtensionLoader的加载步骤\n    1、getExtensionLoader(Protocol.class)为protocol接口生成一个加载器\n    2、getAdaptiveExtension()，使用加载器生成一个代理对象---- protocol接口对象\n    3、代理对象执行时，根据参数（扩展名extName）选择实际对象\n    4、每个接口扩展点,对应一个ExtensionLoader加载器，如：\n       protocol      ExtensionLoader实例<protocol>\n       filter        ExtensionLoader实例<filter>\n       loadbalance   ExtensionLoader实例<loadbalance>\n\n代理类的创建，是通过动态代码，生成一个类源码，然后经过编译得到代理类的class(Demo)(代码hexo报错,原因待查,直接上图片)\n![demo](http://image.tupelo.top/demo.png)\n\n- Dubbo的ExtensionLoader执行逻辑\n\n![Dubbo的ExtensionLoader执行逻辑](http://image.tupelo.top/extension%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91-2.png)\n\n    a、dubbo启动加载实现类时，以   key-实例 方式map缓存各个实现类\n    b、实际调用时，通过key --取实现需要那个实现\n    c、调用的发生，由生成的代理对象的来发起，最终是从URL总线中，找出extName值，extName做为别说，在缓存map中取出正确的实现实现类\n\n\n- Dubbo的扩展框架\n\n![Dubbo的扩展框架](http://image.tupelo.top/loader%E6%9C%BA%E5%88%B6.png)\n- Dubbo的发布订阅\n    - 主要是RegistryProtocol,在zk中发布订阅.\n    - 当有新的消费节点或者服务节点进入时,触发notify,刷新所有的url信息.\n    - zk中的信息,在dubbo代码中,一样要缓存一份(查询会消耗时间),用于容错/负载等动作,此缓存信息的如何与zk中信息保持一致性,依赖发布订阅机制(监听器的及时回调).\n    - dubbo注册中心选择很多(数据库功能+发布订阅功能),之所以推荐使用zk,是因为zk在分布式环境中,搭建集群(数据冗余)方便,抗灾性强.\n\n\n","source":"_posts/dubbo-04.md","raw":"---\ntitle: Dubbo - Spi机制\ntags:\n  - Dubbo\n---\n\nDubbo Spi机制\n\n## Dubbo Spi机制\n\n本质是解决同一个接口，有多种实现时，使用者如何能够方便选择实现的问题\n\n\n<!-- more -->\n\n\n#### Spi机制(策略模式)\n\n\n- jdk的Spi机制\n\n![jdk的Spi机制](http://image.tupelo.top/jdkspi.png)\n\njdk中，选择SpiService的实现，方法是在jar中放置一个META-INF/services目录，目录中存放一个文本文件(文件名----是SpiService接口的全路径名)，文本中列入你选择的实现类(一行放一个------是实现类的全路径名),有了上述配置，在java程序中，使用ServiceLoader.load(SpiService.class)，\n即可将配置中选择的实现类，实例化并放入一个集合中\n\n```java\n//配置文件\ncom.enjoy.spi.service.RmiSpiServiceImpl\ncom.enjoy.spi.service.RestSpiServiceImpl\n\n//加载\npublic static void main(String[] args) throws IOException {\n        //加载接口\n        ServiceLoader<SpiService> spiLoader = ServiceLoader.load(SpiService.class);\n        Iterator<SpiService> iteratorSpi = spiLoader.iterator();\n        while (iteratorSpi.hasNext()) {\n            SpiService spiService = iteratorSpi.next();\n            spiService.sayHello();\n        }\n}\n```\n\n- Dubbo的Spi机制\n\n![spi机制](http://image.tupelo.top/spi%E6%9C%BA%E5%88%B6.png)\n\n```java\n<dubbo:reference  id=\"productService\" cluster=\"failover\" interface=\"com.enjoy.service.ProductService\" />\n<dubbo:reference  id=\"productService1\" cluster=\"failsafe\" interface=\"com.enjoy.service.ProductService\" />\n<dubbo:reference  id=\"productService2\" cluster=\"failfast\" interface=\"com.enjoy.service.ProductService\" />\n```\n\n与jdk相比,dubbo将选择权下放到了配置文件中(你配置谁，它使为你实例化谁)dubbo的目标,以cluster为例,failsafe/failover/failfast都是cluster的一种实现,现在我    们可以在标签配置时,方便地进行选择.凡是dubbo中,接口上有 @SPI 标注的，都表明此接口支持扩展.\n\n\n- 自定义扩展(LoadBalance为例)\n\n引入maven支持\n```java\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.5.7</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n新建一个类 定义使用第一个服务的负载规则\n```java\npublic class FirstLoadBalance implements LoadBalance {//filter\n    /**\n     * @param invokers 所有provider的实现\n     * @param url\n     * @param invocation\n     * @param <T>\n     * @return\n     * @throws RpcException\n     */\n    @Override\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation)\n            throws RpcException {\n        System.out.println(\"启动第一个\");\n        //固定使用第一个\n        return invokers.get(0);\n    }\n}\n```\n\n添加配置文件 路径为 resources/META-INF/dubbo,文件名和接口(LoadBalance)全路径名一样,com.alibaba.dubbo.rpc.cluster.LoadBalance,以 key-value 方式添加内容\n\n```java\nfirst=com.enjoy.loadbalance.FirstLoadBalance\n```\n\n在消费方dubbo配置文件中就可以使用自定义规则了\n\n```java\n<dubbo:reference  id=\"userService\" interface=\"com.enjoy.service.UserService\" loadbalance=\"first\" />\n\n```\n\n\n#### Spi实现原理---核心ExtensionLoader\n\nprotocol是个代理类，不是真实的协议实现\n\n```java\nprivate static final Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n```\n\n    ExtensionLoader的加载步骤\n    1、getExtensionLoader(Protocol.class)为protocol接口生成一个加载器\n    2、getAdaptiveExtension()，使用加载器生成一个代理对象---- protocol接口对象\n    3、代理对象执行时，根据参数（扩展名extName）选择实际对象\n    4、每个接口扩展点,对应一个ExtensionLoader加载器，如：\n       protocol      ExtensionLoader实例<protocol>\n       filter        ExtensionLoader实例<filter>\n       loadbalance   ExtensionLoader实例<loadbalance>\n\n代理类的创建，是通过动态代码，生成一个类源码，然后经过编译得到代理类的class(Demo)(代码hexo报错,原因待查,直接上图片)\n![demo](http://image.tupelo.top/demo.png)\n\n- Dubbo的ExtensionLoader执行逻辑\n\n![Dubbo的ExtensionLoader执行逻辑](http://image.tupelo.top/extension%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91-2.png)\n\n    a、dubbo启动加载实现类时，以   key-实例 方式map缓存各个实现类\n    b、实际调用时，通过key --取实现需要那个实现\n    c、调用的发生，由生成的代理对象的来发起，最终是从URL总线中，找出extName值，extName做为别说，在缓存map中取出正确的实现实现类\n\n\n- Dubbo的扩展框架\n\n![Dubbo的扩展框架](http://image.tupelo.top/loader%E6%9C%BA%E5%88%B6.png)\n- Dubbo的发布订阅\n    - 主要是RegistryProtocol,在zk中发布订阅.\n    - 当有新的消费节点或者服务节点进入时,触发notify,刷新所有的url信息.\n    - zk中的信息,在dubbo代码中,一样要缓存一份(查询会消耗时间),用于容错/负载等动作,此缓存信息的如何与zk中信息保持一致性,依赖发布订阅机制(监听器的及时回调).\n    - dubbo注册中心选择很多(数据库功能+发布订阅功能),之所以推荐使用zk,是因为zk在分布式环境中,搭建集群(数据冗余)方便,抗灾性强.\n\n\n","slug":"dubbo-04","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","_id":"clhua15ah000z9gj79uh4l5sa","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Dubbo Spi机制</p>\n<h2 id=\"Dubbo-Spi机制\"><a href=\"#Dubbo-Spi机制\" class=\"headerlink\" title=\"Dubbo Spi机制\"></a>Dubbo Spi机制</h2><p>本质是解决同一个接口，有多种实现时，使用者如何能够方便选择实现的问题</p>\n<a id=\"more\"></a>\n<h4 id=\"Spi机制-策略模式\"><a href=\"#Spi机制-策略模式\" class=\"headerlink\" title=\"Spi机制(策略模式)\"></a>Spi机制(策略模式)</h4><ul>\n<li>jdk的Spi机制</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/jdkspi.png\" alt=\"jdk的Spi机制\"></p>\n<p>jdk中，选择SpiService的实现，方法是在jar中放置一个META-INF/services目录，目录中存放一个文本文件(文件名—-是SpiService接口的全路径名)，文本中列入你选择的实现类(一行放一个——是实现类的全路径名),有了上述配置，在java程序中，使用ServiceLoader.load(SpiService.class)，<br>即可将配置中选择的实现类，实例化并放入一个集合中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置文件</span></span><br><span class=\"line\">com.enjoy.spi.service.RmiSpiServiceImpl</span><br><span class=\"line\">com.enjoy.spi.service.RestSpiServiceImpl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//加载接口</span></span><br><span class=\"line\">        ServiceLoader&lt;SpiService&gt; spiLoader = ServiceLoader.load(SpiService.class);</span><br><span class=\"line\">        Iterator&lt;SpiService&gt; iteratorSpi = spiLoader.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iteratorSpi.hasNext()) &#123;</span><br><span class=\"line\">            SpiService spiService = iteratorSpi.next();</span><br><span class=\"line\">            spiService.sayHello();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Dubbo的Spi机制</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/spi%E6%9C%BA%E5%88%B6.png\" alt=\"spi机制\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"productService\"</span> cluster=<span class=\"string\">\"failover\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.ProductService\"</span> /&gt;</span><br><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"productService1\"</span> cluster=<span class=\"string\">\"failsafe\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.ProductService\"</span> /&gt;</span><br><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"productService2\"</span> cluster=<span class=\"string\">\"failfast\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.ProductService\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>与jdk相比,dubbo将选择权下放到了配置文件中(你配置谁，它使为你实例化谁)dubbo的目标,以cluster为例,failsafe/failover/failfast都是cluster的一种实现,现在我    们可以在标签配置时,方便地进行选择.凡是dubbo中,接口上有 @SPI 标注的，都表明此接口支持扩展.</p>\n<ul>\n<li>自定义扩展(LoadBalance为例)</li>\n</ul>\n<p>引入maven支持<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.5.7&lt;/version&gt;</span><br><span class=\"line\">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>新建一个类 定义使用第一个服务的负载规则<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstLoadBalance</span> <span class=\"keyword\">implements</span> <span class=\"title\">LoadBalance</span> </span>&#123;<span class=\"comment\">//filter</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invokers 所有provider的实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> url</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invocation</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RpcException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">select</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"启动第一个\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//固定使用第一个</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加配置文件 路径为 resources/META-INF/dubbo,文件名和接口(LoadBalance)全路径名一样,com.alibaba.dubbo.rpc.cluster.LoadBalance,以 key-value 方式添加内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first=com.enjoy.loadbalance.FirstLoadBalance</span><br></pre></td></tr></table></figure>\n<p>在消费方dubbo配置文件中就可以使用自定义规则了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"userService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.UserService\"</span> loadbalance=<span class=\"string\">\"first\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Spi实现原理—核心ExtensionLoader\"><a href=\"#Spi实现原理—核心ExtensionLoader\" class=\"headerlink\" title=\"Spi实现原理—核心ExtensionLoader\"></a>Spi实现原理—核心ExtensionLoader</h4><p>protocol是个代理类，不是真实的协议实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>\n<pre><code>ExtensionLoader的加载步骤\n1、getExtensionLoader(Protocol.class)为protocol接口生成一个加载器\n2、getAdaptiveExtension()，使用加载器生成一个代理对象---- protocol接口对象\n3、代理对象执行时，根据参数（扩展名extName）选择实际对象\n4、每个接口扩展点,对应一个ExtensionLoader加载器，如：\n   protocol      ExtensionLoader实例&lt;protocol&gt;\n   filter        ExtensionLoader实例&lt;filter&gt;\n   loadbalance   ExtensionLoader实例&lt;loadbalance&gt;\n</code></pre><p>代理类的创建，是通过动态代码，生成一个类源码，然后经过编译得到代理类的class(Demo)(代码hexo报错,原因待查,直接上图片)<br><img src=\"http://image.tupelo.top/demo.png\" alt=\"demo\"></p>\n<ul>\n<li>Dubbo的ExtensionLoader执行逻辑</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/extension%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91-2.png\" alt=\"Dubbo的ExtensionLoader执行逻辑\"></p>\n<pre><code>a、dubbo启动加载实现类时，以   key-实例 方式map缓存各个实现类\nb、实际调用时，通过key --取实现需要那个实现\nc、调用的发生，由生成的代理对象的来发起，最终是从URL总线中，找出extName值，extName做为别说，在缓存map中取出正确的实现实现类\n</code></pre><ul>\n<li>Dubbo的扩展框架</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/loader%E6%9C%BA%E5%88%B6.png\" alt=\"Dubbo的扩展框架\"></p>\n<ul>\n<li>Dubbo的发布订阅<ul>\n<li>主要是RegistryProtocol,在zk中发布订阅.</li>\n<li>当有新的消费节点或者服务节点进入时,触发notify,刷新所有的url信息.</li>\n<li>zk中的信息,在dubbo代码中,一样要缓存一份(查询会消耗时间),用于容错/负载等动作,此缓存信息的如何与zk中信息保持一致性,依赖发布订阅机制(监听器的及时回调).</li>\n<li>dubbo注册中心选择很多(数据库功能+发布订阅功能),之所以推荐使用zk,是因为zk在分布式环境中,搭建集群(数据冗余)方便,抗灾性强.</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Dubbo Spi机制</p>\n<h2 id=\"Dubbo-Spi机制\"><a href=\"#Dubbo-Spi机制\" class=\"headerlink\" title=\"Dubbo Spi机制\"></a>Dubbo Spi机制</h2><p>本质是解决同一个接口，有多种实现时，使用者如何能够方便选择实现的问题</p>","more":"<h4 id=\"Spi机制-策略模式\"><a href=\"#Spi机制-策略模式\" class=\"headerlink\" title=\"Spi机制(策略模式)\"></a>Spi机制(策略模式)</h4><ul>\n<li>jdk的Spi机制</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/jdkspi.png\" alt=\"jdk的Spi机制\"></p>\n<p>jdk中，选择SpiService的实现，方法是在jar中放置一个META-INF/services目录，目录中存放一个文本文件(文件名—-是SpiService接口的全路径名)，文本中列入你选择的实现类(一行放一个——是实现类的全路径名),有了上述配置，在java程序中，使用ServiceLoader.load(SpiService.class)，<br>即可将配置中选择的实现类，实例化并放入一个集合中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置文件</span></span><br><span class=\"line\">com.enjoy.spi.service.RmiSpiServiceImpl</span><br><span class=\"line\">com.enjoy.spi.service.RestSpiServiceImpl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//加载接口</span></span><br><span class=\"line\">        ServiceLoader&lt;SpiService&gt; spiLoader = ServiceLoader.load(SpiService.class);</span><br><span class=\"line\">        Iterator&lt;SpiService&gt; iteratorSpi = spiLoader.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iteratorSpi.hasNext()) &#123;</span><br><span class=\"line\">            SpiService spiService = iteratorSpi.next();</span><br><span class=\"line\">            spiService.sayHello();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Dubbo的Spi机制</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/spi%E6%9C%BA%E5%88%B6.png\" alt=\"spi机制\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"productService\"</span> cluster=<span class=\"string\">\"failover\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.ProductService\"</span> /&gt;</span><br><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"productService1\"</span> cluster=<span class=\"string\">\"failsafe\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.ProductService\"</span> /&gt;</span><br><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"productService2\"</span> cluster=<span class=\"string\">\"failfast\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.ProductService\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>与jdk相比,dubbo将选择权下放到了配置文件中(你配置谁，它使为你实例化谁)dubbo的目标,以cluster为例,failsafe/failover/failfast都是cluster的一种实现,现在我    们可以在标签配置时,方便地进行选择.凡是dubbo中,接口上有 @SPI 标注的，都表明此接口支持扩展.</p>\n<ul>\n<li>自定义扩展(LoadBalance为例)</li>\n</ul>\n<p>引入maven支持<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.5.7&lt;/version&gt;</span><br><span class=\"line\">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>新建一个类 定义使用第一个服务的负载规则<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstLoadBalance</span> <span class=\"keyword\">implements</span> <span class=\"title\">LoadBalance</span> </span>&#123;<span class=\"comment\">//filter</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invokers 所有provider的实现</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> url</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invocation</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RpcException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">select</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"启动第一个\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//固定使用第一个</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>添加配置文件 路径为 resources/META-INF/dubbo,文件名和接口(LoadBalance)全路径名一样,com.alibaba.dubbo.rpc.cluster.LoadBalance,以 key-value 方式添加内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first=com.enjoy.loadbalance.FirstLoadBalance</span><br></pre></td></tr></table></figure>\n<p>在消费方dubbo配置文件中就可以使用自定义规则了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dubbo:reference  id=<span class=\"string\">\"userService\"</span> <span class=\"class\"><span class=\"keyword\">interface</span></span>=<span class=\"string\">\"com.enjoy.service.UserService\"</span> loadbalance=<span class=\"string\">\"first\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Spi实现原理—核心ExtensionLoader\"><a href=\"#Spi实现原理—核心ExtensionLoader\" class=\"headerlink\" title=\"Spi实现原理—核心ExtensionLoader\"></a>Spi实现原理—核心ExtensionLoader</h4><p>protocol是个代理类，不是真实的协议实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Protocol refprotocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>\n<pre><code>ExtensionLoader的加载步骤\n1、getExtensionLoader(Protocol.class)为protocol接口生成一个加载器\n2、getAdaptiveExtension()，使用加载器生成一个代理对象---- protocol接口对象\n3、代理对象执行时，根据参数（扩展名extName）选择实际对象\n4、每个接口扩展点,对应一个ExtensionLoader加载器，如：\n   protocol      ExtensionLoader实例&lt;protocol&gt;\n   filter        ExtensionLoader实例&lt;filter&gt;\n   loadbalance   ExtensionLoader实例&lt;loadbalance&gt;\n</code></pre><p>代理类的创建，是通过动态代码，生成一个类源码，然后经过编译得到代理类的class(Demo)(代码hexo报错,原因待查,直接上图片)<br><img src=\"http://image.tupelo.top/demo.png\" alt=\"demo\"></p>\n<ul>\n<li>Dubbo的ExtensionLoader执行逻辑</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/extension%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91-2.png\" alt=\"Dubbo的ExtensionLoader执行逻辑\"></p>\n<pre><code>a、dubbo启动加载实现类时，以   key-实例 方式map缓存各个实现类\nb、实际调用时，通过key --取实现需要那个实现\nc、调用的发生，由生成的代理对象的来发起，最终是从URL总线中，找出extName值，extName做为别说，在缓存map中取出正确的实现实现类\n</code></pre><ul>\n<li>Dubbo的扩展框架</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/loader%E6%9C%BA%E5%88%B6.png\" alt=\"Dubbo的扩展框架\"></p>\n<ul>\n<li>Dubbo的发布订阅<ul>\n<li>主要是RegistryProtocol,在zk中发布订阅.</li>\n<li>当有新的消费节点或者服务节点进入时,触发notify,刷新所有的url信息.</li>\n<li>zk中的信息,在dubbo代码中,一样要缓存一份(查询会消耗时间),用于容错/负载等动作,此缓存信息的如何与zk中信息保持一致性,依赖发布订阅机制(监听器的及时回调).</li>\n<li>dubbo注册中心选择很多(数据库功能+发布订阅功能),之所以推荐使用zk,是因为zk在分布式环境中,搭建集群(数据冗余)方便,抗灾性强.</li>\n</ul>\n</li>\n</ul>"},{"title":"Git使用笔记","_content":"\nGit使用笔记\n\n## Git使用笔记\n\n#### 安装和配置\n\n下载地址 ： ```https://git-scm.com/downloads```      \n查看当前git用户名： ```git config user.name```      \n查看当前git邮箱： ```git config user.email```      \n切换git用户名: ```git config --global user.name \"user name\"```       \n切换git邮箱： ```git config --global user.email  \"e-mail\"```     \n生成SSH Keys: ```ssh-keygen -t rsa -C \"e-mail\"```\n\n\n#### Git指令模式\n\n\n##### 基本操作      \n\n- ```git init``` 初始化一个git项目\n- ```git commit -am 'new project'``` 加入缓存区并提交\n- ```git chceckout [-b] king```  切换(新增分支)\n\n##### 远程仓库\n\n- ```git remote add origin https://github.com/xx/xxx.git```  本地新建一个远程连接\n- ```git remote [-v]```  查看远程连接(详情)\n- ```git branch --set-upstream-to=origin/xxx xxx```  本地分支与远程分支关联\n- ```git push --set-upstream origin master```  上传本地项目至GitHub\n- ```git fetch```  提取远程仓库\n\n##### 分支合并\n\n- ```git merge xxx``` 将指定版本与当前版本合并\n\n> 有冲突的话相关的文件会显示,需要手动解决冲突后再次push\n\n\n##### 日志标签\n\n- ```git log [--oneline] [--graph]``` 显示提交日志(简化成一行)(显示分支)\n- ```git tag [-a][-d] xxx -m 'xxxx'``` 为某一个分支(创建)(删除)一个tag\n- ```git show xxx``` 显示某一个tag的附属信息\n- ```git push origin -tags``` 本地标签提交到远程仓库\n\n\n##### 代码回滚 两种方式：回退（reset）、反做（revert）\n\n- ```git reset``` 的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本。（比如需要回到到V0.3）使用 ```git reset --hard 目标版本号``` 命令将版本回退\n- ```git revert``` 的作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。\n\n\n","source":"_posts/git使用笔记.md","raw":"---\ntitle: Git使用笔记\ntags:\n  - Git\n---\n\nGit使用笔记\n\n## Git使用笔记\n\n#### 安装和配置\n\n下载地址 ： ```https://git-scm.com/downloads```      \n查看当前git用户名： ```git config user.name```      \n查看当前git邮箱： ```git config user.email```      \n切换git用户名: ```git config --global user.name \"user name\"```       \n切换git邮箱： ```git config --global user.email  \"e-mail\"```     \n生成SSH Keys: ```ssh-keygen -t rsa -C \"e-mail\"```\n\n\n#### Git指令模式\n\n\n##### 基本操作      \n\n- ```git init``` 初始化一个git项目\n- ```git commit -am 'new project'``` 加入缓存区并提交\n- ```git chceckout [-b] king```  切换(新增分支)\n\n##### 远程仓库\n\n- ```git remote add origin https://github.com/xx/xxx.git```  本地新建一个远程连接\n- ```git remote [-v]```  查看远程连接(详情)\n- ```git branch --set-upstream-to=origin/xxx xxx```  本地分支与远程分支关联\n- ```git push --set-upstream origin master```  上传本地项目至GitHub\n- ```git fetch```  提取远程仓库\n\n##### 分支合并\n\n- ```git merge xxx``` 将指定版本与当前版本合并\n\n> 有冲突的话相关的文件会显示,需要手动解决冲突后再次push\n\n\n##### 日志标签\n\n- ```git log [--oneline] [--graph]``` 显示提交日志(简化成一行)(显示分支)\n- ```git tag [-a][-d] xxx -m 'xxxx'``` 为某一个分支(创建)(删除)一个tag\n- ```git show xxx``` 显示某一个tag的附属信息\n- ```git push origin -tags``` 本地标签提交到远程仓库\n\n\n##### 代码回滚 两种方式：回退（reset）、反做（revert）\n\n- ```git reset``` 的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本。（比如需要回到到V0.3）使用 ```git reset --hard 目标版本号``` 命令将版本回退\n- ```git revert``` 的作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。\n\n\n","slug":"git使用笔记","published":1,"date":"2023-05-19T02:16:10.334Z","updated":"2023-05-19T02:16:10.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15aj00119gj7alwyzc8o","content":"<p>Git使用笔记</p>\n<h2 id=\"Git使用笔记\"><a href=\"#Git使用笔记\" class=\"headerlink\" title=\"Git使用笔记\"></a>Git使用笔记</h2><h4 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h4><p>下载地址 ： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前git用户名： ```git config user.name```      </span><br><span class=\"line\">查看当前git邮箱： ```git config user.email```      </span><br><span class=\"line\">切换git用户名: ```git config --global user.name &quot;user name&quot;```       </span><br><span class=\"line\">切换git邮箱： ```git config --global user.email  &quot;e-mail&quot;```     </span><br><span class=\"line\">生成SSH Keys: ```ssh-keygen -t rsa -C &quot;e-mail&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Git指令模式\"><a href=\"#Git指令模式\" class=\"headerlink\" title=\"Git指令模式\"></a>Git指令模式</h4><h5 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h5><ul>\n<li><code>git init</code> 初始化一个git项目</li>\n<li><code>git commit -am &#39;new project&#39;</code> 加入缓存区并提交</li>\n<li><code>git chceckout [-b] king</code>  切换(新增分支)</li>\n</ul>\n<h5 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h5><ul>\n<li><code>git remote add origin https://github.com/xx/xxx.git</code>  本地新建一个远程连接</li>\n<li><code>git remote [-v]</code>  查看远程连接(详情)</li>\n<li><code>git branch --set-upstream-to=origin/xxx xxx</code>  本地分支与远程分支关联</li>\n<li><code>git push --set-upstream origin master</code>  上传本地项目至GitHub</li>\n<li><code>git fetch</code>  提取远程仓库</li>\n</ul>\n<h5 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h5><ul>\n<li><code>git merge xxx</code> 将指定版本与当前版本合并</li>\n</ul>\n<blockquote>\n<p>有冲突的话相关的文件会显示,需要手动解决冲突后再次push</p>\n</blockquote>\n<h5 id=\"日志标签\"><a href=\"#日志标签\" class=\"headerlink\" title=\"日志标签\"></a>日志标签</h5><ul>\n<li><code>git log [--oneline] [--graph]</code> 显示提交日志(简化成一行)(显示分支)</li>\n<li><code>git tag [-a][-d] xxx -m &#39;xxxx&#39;</code> 为某一个分支(创建)(删除)一个tag</li>\n<li><code>git show xxx</code> 显示某一个tag的附属信息</li>\n<li><code>git push origin -tags</code> 本地标签提交到远程仓库</li>\n</ul>\n<h5 id=\"代码回滚-两种方式：回退（reset）、反做（revert）\"><a href=\"#代码回滚-两种方式：回退（reset）、反做（revert）\" class=\"headerlink\" title=\"代码回滚 两种方式：回退（reset）、反做（revert）\"></a>代码回滚 两种方式：回退（reset）、反做（revert）</h5><ul>\n<li><code>git reset</code> 的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本。（比如需要回到到V0.3）使用 <code>git reset --hard 目标版本号</code> 命令将版本回退</li>\n<li><code>git revert</code> 的作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Git使用笔记</p>\n<h2 id=\"Git使用笔记\"><a href=\"#Git使用笔记\" class=\"headerlink\" title=\"Git使用笔记\"></a>Git使用笔记</h2><h4 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h4><p>下载地址 ： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前git用户名： ```git config user.name```      </span><br><span class=\"line\">查看当前git邮箱： ```git config user.email```      </span><br><span class=\"line\">切换git用户名: ```git config --global user.name &quot;user name&quot;```       </span><br><span class=\"line\">切换git邮箱： ```git config --global user.email  &quot;e-mail&quot;```     </span><br><span class=\"line\">生成SSH Keys: ```ssh-keygen -t rsa -C &quot;e-mail&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Git指令模式\"><a href=\"#Git指令模式\" class=\"headerlink\" title=\"Git指令模式\"></a>Git指令模式</h4><h5 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h5><ul>\n<li><code>git init</code> 初始化一个git项目</li>\n<li><code>git commit -am &#39;new project&#39;</code> 加入缓存区并提交</li>\n<li><code>git chceckout [-b] king</code>  切换(新增分支)</li>\n</ul>\n<h5 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h5><ul>\n<li><code>git remote add origin https://github.com/xx/xxx.git</code>  本地新建一个远程连接</li>\n<li><code>git remote [-v]</code>  查看远程连接(详情)</li>\n<li><code>git branch --set-upstream-to=origin/xxx xxx</code>  本地分支与远程分支关联</li>\n<li><code>git push --set-upstream origin master</code>  上传本地项目至GitHub</li>\n<li><code>git fetch</code>  提取远程仓库</li>\n</ul>\n<h5 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h5><ul>\n<li><code>git merge xxx</code> 将指定版本与当前版本合并</li>\n</ul>\n<blockquote>\n<p>有冲突的话相关的文件会显示,需要手动解决冲突后再次push</p>\n</blockquote>\n<h5 id=\"日志标签\"><a href=\"#日志标签\" class=\"headerlink\" title=\"日志标签\"></a>日志标签</h5><ul>\n<li><code>git log [--oneline] [--graph]</code> 显示提交日志(简化成一行)(显示分支)</li>\n<li><code>git tag [-a][-d] xxx -m &#39;xxxx&#39;</code> 为某一个分支(创建)(删除)一个tag</li>\n<li><code>git show xxx</code> 显示某一个tag的附属信息</li>\n<li><code>git push origin -tags</code> 本地标签提交到远程仓库</li>\n</ul>\n<h5 id=\"代码回滚-两种方式：回退（reset）、反做（revert）\"><a href=\"#代码回滚-两种方式：回退（reset）、反做（revert）\" class=\"headerlink\" title=\"代码回滚 两种方式：回退（reset）、反做（revert）\"></a>代码回滚 两种方式：回退（reset）、反做（revert）</h5><ul>\n<li><code>git reset</code> 的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本。（比如需要回到到V0.3）使用 <code>git reset --hard 目标版本号</code> 命令将版本回退</li>\n<li><code>git revert</code> 的作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。</li>\n</ul>\n"},{"title":"Dubbo - 总结","_content":"\nDubbo 总结\n\n> 参考官方文档：http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html\n\n<!-- more -->\n\n## Dubbo 总结\n\n#### dubbo初始化流程\n\n- 入口\n    - spring标签DubboNameSpaceHandler\n    - referencebean + servicebean \n    - 继承了spring initalizingBean接口\n    - afterPropertiesSet\n    - protocol.refer(url) + protocol.export(url)+(registryURL)\n\n- 消费端\n    - RegistryProtocol.refer\n    - zkRegistry.subscribe\n    - 触发监听器回调\n    - registryDictory \n    - protocol.refer \n    - dubboProtocol.refer + interface\n    - 消费方interface代理对象\n\n- 服务端\n    - RegistryProtocol.export \n    - protocol.export \n    - 创建中转对象\n    - zkRegistry.subscribe注册\n\n\n#### spi\n\njdk的spi：把实现类,装入一个list中\ndubbo的spi：把实现类,装入一个map中(配置文件指定一key),key指代实现类\n\n#### RegistryProtocol\n\ndubbo偷懒，借用protocol流程模块，把注册模块，伪装成protocol协议(注册协议),注册协议跟其它不一样，任何协议dubbo/rmi/rest,要生效,都必须注册,因此RegistryProtocol是最优先被调用，然后再转给真实的协议\n\n#### 服务治理\n\n- dubbo只是服务治理，springcloud包含所有全套微服务功能\n- dubbo把rpc做了成透明化的调度,减少出错机率(spring cloud易出错)\n- springcloud的远程调用，没能完全透明化。透明化调度，意思你使用它，像本地服务一样用。\n- dubbo控制台，可以关闭某个服务，不对外开放（开发环境常用）\n","source":"_posts/dubbo-05.md","raw":"---\ntitle: Dubbo - 总结\ntags:\n  - Dubbo\n---\n\nDubbo 总结\n\n> 参考官方文档：http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html\n\n<!-- more -->\n\n## Dubbo 总结\n\n#### dubbo初始化流程\n\n- 入口\n    - spring标签DubboNameSpaceHandler\n    - referencebean + servicebean \n    - 继承了spring initalizingBean接口\n    - afterPropertiesSet\n    - protocol.refer(url) + protocol.export(url)+(registryURL)\n\n- 消费端\n    - RegistryProtocol.refer\n    - zkRegistry.subscribe\n    - 触发监听器回调\n    - registryDictory \n    - protocol.refer \n    - dubboProtocol.refer + interface\n    - 消费方interface代理对象\n\n- 服务端\n    - RegistryProtocol.export \n    - protocol.export \n    - 创建中转对象\n    - zkRegistry.subscribe注册\n\n\n#### spi\n\njdk的spi：把实现类,装入一个list中\ndubbo的spi：把实现类,装入一个map中(配置文件指定一key),key指代实现类\n\n#### RegistryProtocol\n\ndubbo偷懒，借用protocol流程模块，把注册模块，伪装成protocol协议(注册协议),注册协议跟其它不一样，任何协议dubbo/rmi/rest,要生效,都必须注册,因此RegistryProtocol是最优先被调用，然后再转给真实的协议\n\n#### 服务治理\n\n- dubbo只是服务治理，springcloud包含所有全套微服务功能\n- dubbo把rpc做了成透明化的调度,减少出错机率(spring cloud易出错)\n- springcloud的远程调用，没能完全透明化。透明化调度，意思你使用它，像本地服务一样用。\n- dubbo控制台，可以关闭某个服务，不对外开放（开发环境常用）\n","slug":"dubbo-05","published":1,"date":"2025-02-12T08:28:16.464Z","updated":"2025-02-12T08:28:16.464Z","_id":"clhua15aj00139gj7vw55hkey","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Dubbo 总结</p>\n<blockquote>\n<p>参考官方文档：<a href=\"http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"Dubbo-总结\"><a href=\"#Dubbo-总结\" class=\"headerlink\" title=\"Dubbo 总结\"></a>Dubbo 总结</h2><h4 id=\"dubbo初始化流程\"><a href=\"#dubbo初始化流程\" class=\"headerlink\" title=\"dubbo初始化流程\"></a>dubbo初始化流程</h4><ul>\n<li><p>入口</p>\n<ul>\n<li>spring标签DubboNameSpaceHandler</li>\n<li>referencebean + servicebean </li>\n<li>继承了spring initalizingBean接口</li>\n<li>afterPropertiesSet</li>\n<li>protocol.refer(url) + protocol.export(url)+(registryURL)</li>\n</ul>\n</li>\n<li><p>消费端</p>\n<ul>\n<li>RegistryProtocol.refer</li>\n<li>zkRegistry.subscribe</li>\n<li>触发监听器回调</li>\n<li>registryDictory </li>\n<li>protocol.refer </li>\n<li>dubboProtocol.refer + interface</li>\n<li>消费方interface代理对象</li>\n</ul>\n</li>\n<li><p>服务端</p>\n<ul>\n<li>RegistryProtocol.export </li>\n<li>protocol.export </li>\n<li>创建中转对象</li>\n<li>zkRegistry.subscribe注册</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"spi\"><a href=\"#spi\" class=\"headerlink\" title=\"spi\"></a>spi</h4><p>jdk的spi：把实现类,装入一个list中<br>dubbo的spi：把实现类,装入一个map中(配置文件指定一key),key指代实现类</p>\n<h4 id=\"RegistryProtocol\"><a href=\"#RegistryProtocol\" class=\"headerlink\" title=\"RegistryProtocol\"></a>RegistryProtocol</h4><p>dubbo偷懒，借用protocol流程模块，把注册模块，伪装成protocol协议(注册协议),注册协议跟其它不一样，任何协议dubbo/rmi/rest,要生效,都必须注册,因此RegistryProtocol是最优先被调用，然后再转给真实的协议</p>\n<h4 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h4><ul>\n<li>dubbo只是服务治理，springcloud包含所有全套微服务功能</li>\n<li>dubbo把rpc做了成透明化的调度,减少出错机率(spring cloud易出错)</li>\n<li>springcloud的远程调用，没能完全透明化。透明化调度，意思你使用它，像本地服务一样用。</li>\n<li>dubbo控制台，可以关闭某个服务，不对外开放（开发环境常用）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Dubbo 总结</p>\n<blockquote>\n<p>参考官方文档：<a href=\"http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html</a></p>\n</blockquote>","more":"<h2 id=\"Dubbo-总结\"><a href=\"#Dubbo-总结\" class=\"headerlink\" title=\"Dubbo 总结\"></a>Dubbo 总结</h2><h4 id=\"dubbo初始化流程\"><a href=\"#dubbo初始化流程\" class=\"headerlink\" title=\"dubbo初始化流程\"></a>dubbo初始化流程</h4><ul>\n<li><p>入口</p>\n<ul>\n<li>spring标签DubboNameSpaceHandler</li>\n<li>referencebean + servicebean </li>\n<li>继承了spring initalizingBean接口</li>\n<li>afterPropertiesSet</li>\n<li>protocol.refer(url) + protocol.export(url)+(registryURL)</li>\n</ul>\n</li>\n<li><p>消费端</p>\n<ul>\n<li>RegistryProtocol.refer</li>\n<li>zkRegistry.subscribe</li>\n<li>触发监听器回调</li>\n<li>registryDictory </li>\n<li>protocol.refer </li>\n<li>dubboProtocol.refer + interface</li>\n<li>消费方interface代理对象</li>\n</ul>\n</li>\n<li><p>服务端</p>\n<ul>\n<li>RegistryProtocol.export </li>\n<li>protocol.export </li>\n<li>创建中转对象</li>\n<li>zkRegistry.subscribe注册</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"spi\"><a href=\"#spi\" class=\"headerlink\" title=\"spi\"></a>spi</h4><p>jdk的spi：把实现类,装入一个list中<br>dubbo的spi：把实现类,装入一个map中(配置文件指定一key),key指代实现类</p>\n<h4 id=\"RegistryProtocol\"><a href=\"#RegistryProtocol\" class=\"headerlink\" title=\"RegistryProtocol\"></a>RegistryProtocol</h4><p>dubbo偷懒，借用protocol流程模块，把注册模块，伪装成protocol协议(注册协议),注册协议跟其它不一样，任何协议dubbo/rmi/rest,要生效,都必须注册,因此RegistryProtocol是最优先被调用，然后再转给真实的协议</p>\n<h4 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h4><ul>\n<li>dubbo只是服务治理，springcloud包含所有全套微服务功能</li>\n<li>dubbo把rpc做了成透明化的调度,减少出错机率(spring cloud易出错)</li>\n<li>springcloud的远程调用，没能完全透明化。透明化调度，意思你使用它，像本地服务一样用。</li>\n<li>dubbo控制台，可以关闭某个服务，不对外开放（开发环境常用）</li>\n</ul>"},{"title":"Hello World","_content":"\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n<!-- more -->\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\n  - hexo\ncategories: \n  - hexo\n---\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n<!-- more -->\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2025-02-12T08:28:16.464Z","updated":"2025-02-12T08:28:16.464Z","_id":"clhua15al00159gj76ig3w433","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>","more":"<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"JVM - java内存区域","_content":"\njava内存区域\n\n#### java内存区域\n\nJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域： \n\n![java内存区域](http://image.tupelo.top/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png?imageMogr2/auto-orient/thumbnail/700x700)\n\n<!-- more -->\n\n- 程序计数器\n\n当前线程执行的字节码的行号指示器，占用空间小，也无法干涉\n\n- 虚拟机栈\n\n每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，\n存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。\n每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。\n栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k\n\n- 本地方法栈\n\n地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，\nJVM只是简单地动态链接并直接调用native方法。\n\n- Java堆\n\n几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：\n-Xms：堆的最小值；\n-Xmx：堆的最大值；\n-Xmn：新生代的大小；\n-XX:NewSize；新生代最小值；\n-XX:MaxNewSize：新生代最大值；\n例如- Xmx256m\n\n\n\n- 方法区(运行时常量池)\n\n用于存储已经被虚拟机加载的类信息，常量(\"zdy\",\"123\"等)，静态变量(static变量)等数据，可用以下参数调整：\njdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；\njdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize\njdk1.8以后大小就只受本机总内存的限制\n如：-XX:MaxMetaspaceSize=3M\n\n\n- 直接内存\n\n不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；\n如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；\n这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），\n所以也会出现OOM异常。\n\n\n栈、本地方法栈、程序计数器为线程私有内存区，随线程产生和消亡，不需要过多考虑内存回收的问题。堆和方法区为线程间共享。\n\n#### java内存区域各个版本之间的变化\n\n- jdk1.6 运行时常量池和方法区在一起\n- jdk1.7 运行时常量池改为和堆在一起\n- jdk1.8 方法区移出了运行时数据区，并改为了元空间metaspace\n\n#### 栈上分配和逃逸分析\n\n虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，<font color=\"red\">任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</font>\n\n- 启用栈上分配\n\n```\n-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client\n-Xmx10m和-Xms10m：堆的大小\n-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)\n-XX:+PrintGC：打印GC日志\n-XX:+EliminateAllocations：标量替换(默认打开)\n-XX:-UseTLAB 关闭本地线程分配缓冲TLABThreadLocalAllocBuffer\n```\n\n对栈上分配发生影响的参数就是三个，```-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations```，任何一个发生变化都不会发生栈上分配，其中启用逃逸分析和标量替换默认是打开的。\n\n#### 虚拟机中对象的分配\n\n虚拟机遇到一条new指令时：      \n\n1. 先执行相应的类加载过程。\n2. 接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。\n如果Java堆中<font color=\"red\">内存是绝对规整的</font>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<font color=\"red\">指针碰撞</font>”。\n如果Java堆中的<font color=\"red\">内存并不是规整的</font>，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<font color=\"red\">空闲列表</font>”。\n<font color=\"red\">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</font>\n除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理,实际上虚拟机采用<font color=\"red\">CAS配上失败重试的方式保证更新操作的原子性</font>；\n另一种是<font color=\"red\">把内存分配的动作按照线程划分在不同的空间之中进行</font>，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数<font color=\"red\">``` -XX:UseTLAB```</font>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。\nTLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。\nTLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。\n3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n4. 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中\n5. 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n\n#### 对象的内存布局\n\n- 对象头（Header）\n- 实例数据（Instance Data）\n- 对齐填充（Padding）\n\n#### 对象的访问定位\n\n- 句柄访问\n- 直接指针访问\n\n#### 堆参数设置和内存溢出实战\n\n- 堆溢出\n\n```java.lang.OutOfMemoryError: GC overhead limit exceeded``` 一般是（某个循环里可能性最大）在不停的分配对象，但是分配的太多，把堆撑爆了。     \n```java.lang.OutOfMemoryError: Java heap space``` 一般是分配了巨型对象。     \n\n- 栈溢出\n\n```java.lang.StackOverflowError``` 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。","source":"_posts/jvm-java内存区域.md","raw":"---\ntitle: JVM - java内存区域\ntags:\n  - JVM\n---\n\njava内存区域\n\n#### java内存区域\n\nJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域： \n\n![java内存区域](http://image.tupelo.top/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png?imageMogr2/auto-orient/thumbnail/700x700)\n\n<!-- more -->\n\n- 程序计数器\n\n当前线程执行的字节码的行号指示器，占用空间小，也无法干涉\n\n- 虚拟机栈\n\n每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，\n存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。\n每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。\n栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k\n\n- 本地方法栈\n\n地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，\nJVM只是简单地动态链接并直接调用native方法。\n\n- Java堆\n\n几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：\n-Xms：堆的最小值；\n-Xmx：堆的最大值；\n-Xmn：新生代的大小；\n-XX:NewSize；新生代最小值；\n-XX:MaxNewSize：新生代最大值；\n例如- Xmx256m\n\n\n\n- 方法区(运行时常量池)\n\n用于存储已经被虚拟机加载的类信息，常量(\"zdy\",\"123\"等)，静态变量(static变量)等数据，可用以下参数调整：\njdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；\njdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize\njdk1.8以后大小就只受本机总内存的限制\n如：-XX:MaxMetaspaceSize=3M\n\n\n- 直接内存\n\n不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；\n如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；\n这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），\n所以也会出现OOM异常。\n\n\n栈、本地方法栈、程序计数器为线程私有内存区，随线程产生和消亡，不需要过多考虑内存回收的问题。堆和方法区为线程间共享。\n\n#### java内存区域各个版本之间的变化\n\n- jdk1.6 运行时常量池和方法区在一起\n- jdk1.7 运行时常量池改为和堆在一起\n- jdk1.8 方法区移出了运行时数据区，并改为了元空间metaspace\n\n#### 栈上分配和逃逸分析\n\n虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，<font color=\"red\">任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</font>\n\n- 启用栈上分配\n\n```\n-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client\n-Xmx10m和-Xms10m：堆的大小\n-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)\n-XX:+PrintGC：打印GC日志\n-XX:+EliminateAllocations：标量替换(默认打开)\n-XX:-UseTLAB 关闭本地线程分配缓冲TLABThreadLocalAllocBuffer\n```\n\n对栈上分配发生影响的参数就是三个，```-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations```，任何一个发生变化都不会发生栈上分配，其中启用逃逸分析和标量替换默认是打开的。\n\n#### 虚拟机中对象的分配\n\n虚拟机遇到一条new指令时：      \n\n1. 先执行相应的类加载过程。\n2. 接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。\n如果Java堆中<font color=\"red\">内存是绝对规整的</font>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<font color=\"red\">指针碰撞</font>”。\n如果Java堆中的<font color=\"red\">内存并不是规整的</font>，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<font color=\"red\">空闲列表</font>”。\n<font color=\"red\">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</font>\n除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理,实际上虚拟机采用<font color=\"red\">CAS配上失败重试的方式保证更新操作的原子性</font>；\n另一种是<font color=\"red\">把内存分配的动作按照线程划分在不同的空间之中进行</font>，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数<font color=\"red\">``` -XX:UseTLAB```</font>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。\nTLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。\nTLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。\n3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n4. 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中\n5. 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n\n#### 对象的内存布局\n\n- 对象头（Header）\n- 实例数据（Instance Data）\n- 对齐填充（Padding）\n\n#### 对象的访问定位\n\n- 句柄访问\n- 直接指针访问\n\n#### 堆参数设置和内存溢出实战\n\n- 堆溢出\n\n```java.lang.OutOfMemoryError: GC overhead limit exceeded``` 一般是（某个循环里可能性最大）在不停的分配对象，但是分配的太多，把堆撑爆了。     \n```java.lang.OutOfMemoryError: Java heap space``` 一般是分配了巨型对象。     \n\n- 栈溢出\n\n```java.lang.StackOverflowError``` 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。","slug":"jvm-java内存区域","published":1,"date":"2023-05-19T02:16:10.335Z","updated":"2023-05-19T02:16:10.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15al00179gj7gjx646i5","content":"<p>java内存区域</p>\n<h4 id=\"java内存区域\"><a href=\"#java内存区域\" class=\"headerlink\" title=\"java内存区域\"></a>java内存区域</h4><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域： </p>\n<p><img src=\"http://image.tupelo.top/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png?imageMogr2/auto-orient/thumbnail/700x700\" alt=\"java内存区域\"></p>\n<a id=\"more\"></a>\n<ul>\n<li>程序计数器</li>\n</ul>\n<p>当前线程执行的字节码的行号指示器，占用空间小，也无法干涉</p>\n<ul>\n<li>虚拟机栈</li>\n</ul>\n<p>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，<br>存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。<br>每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。<br>栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p>\n<ul>\n<li>本地方法栈</li>\n</ul>\n<p>地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，<br>JVM只是简单地动态链接并直接调用native方法。</p>\n<ul>\n<li>Java堆</li>\n</ul>\n<p>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：<br>-Xms：堆的最小值；<br>-Xmx：堆的最大值；<br>-Xmn：新生代的大小；<br>-XX:NewSize；新生代最小值；<br>-XX:MaxNewSize：新生代最大值；<br>例如- Xmx256m</p>\n<ul>\n<li>方法区(运行时常量池)</li>\n</ul>\n<p>用于存储已经被虚拟机加载的类信息，常量(“zdy”,”123”等)，静态变量(static变量)等数据，可用以下参数调整：<br>jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；<br>jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize<br>jdk1.8以后大小就只受本机总内存的限制<br>如：-XX:MaxMetaspaceSize=3M</p>\n<ul>\n<li>直接内存</li>\n</ul>\n<p>不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；<br>如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；<br>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），<br>所以也会出现OOM异常。</p>\n<p>栈、本地方法栈、程序计数器为线程私有内存区，随线程产生和消亡，不需要过多考虑内存回收的问题。堆和方法区为线程间共享。</p>\n<h4 id=\"java内存区域各个版本之间的变化\"><a href=\"#java内存区域各个版本之间的变化\" class=\"headerlink\" title=\"java内存区域各个版本之间的变化\"></a>java内存区域各个版本之间的变化</h4><ul>\n<li>jdk1.6 运行时常量池和方法区在一起</li>\n<li>jdk1.7 运行时常量池改为和堆在一起</li>\n<li>jdk1.8 方法区移出了运行时数据区，并改为了元空间metaspace</li>\n</ul>\n<h4 id=\"栈上分配和逃逸分析\"><a href=\"#栈上分配和逃逸分析\" class=\"headerlink\" title=\"栈上分配和逃逸分析\"></a>栈上分配和逃逸分析</h4><p>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，<font color=\"red\">任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</font></p>\n<ul>\n<li>启用栈上分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client</span><br><span class=\"line\">-Xmx10m和-Xms10m：堆的大小</span><br><span class=\"line\">-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)</span><br><span class=\"line\">-XX:+PrintGC：打印GC日志</span><br><span class=\"line\">-XX:+EliminateAllocations：标量替换(默认打开)</span><br><span class=\"line\">-XX:-UseTLAB 关闭本地线程分配缓冲TLABThreadLocalAllocBuffer</span><br></pre></td></tr></table></figure>\n<p>对栈上分配发生影响的参数就是三个，<code>-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations</code>，任何一个发生变化都不会发生栈上分配，其中启用逃逸分析和标量替换默认是打开的。</p>\n<h4 id=\"虚拟机中对象的分配\"><a href=\"#虚拟机中对象的分配\" class=\"headerlink\" title=\"虚拟机中对象的分配\"></a>虚拟机中对象的分配</h4><p>虚拟机遇到一条new指令时：      </p>\n<ol>\n<li>先执行相应的类加载过程。</li>\n<li>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>如果Java堆中<font color=\"red\">内存是绝对规整的</font>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<font color=\"red\">指针碰撞</font>”。<br>如果Java堆中的<font color=\"red\">内存并不是规整的</font>，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<font color=\"red\">空闲列表</font>”。<br><font color=\"red\">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</font><br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理,实际上虚拟机采用<font color=\"red\">CAS配上失败重试的方式保证更新操作的原子性</font>；<br>另一种是<font color=\"red\">把内存分配的动作按照线程划分在不同的空间之中进行</font>，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数<font color=\"red\"><code>-XX:UseTLAB</code></font>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。<br>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。<br>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</li>\n<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\n<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中</li>\n<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><ul>\n<li>对象头（Header）</li>\n<li>实例数据（Instance Data）</li>\n<li>对齐填充（Padding）</li>\n</ul>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><ul>\n<li>句柄访问</li>\n<li>直接指针访问</li>\n</ul>\n<h4 id=\"堆参数设置和内存溢出实战\"><a href=\"#堆参数设置和内存溢出实战\" class=\"headerlink\" title=\"堆参数设置和内存溢出实战\"></a>堆参数设置和内存溢出实战</h4><ul>\n<li>堆溢出</li>\n</ul>\n<p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 一般是（某个循环里可能性最大）在不停的分配对象，但是分配的太多，把堆撑爆了。<br><code>java.lang.OutOfMemoryError: Java heap space</code> 一般是分配了巨型对象。     </p>\n<ul>\n<li>栈溢出</li>\n</ul>\n<p><code>java.lang.StackOverflowError</code> 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。</p>\n","site":{"data":{}},"excerpt":"<p>java内存区域</p>\n<h4 id=\"java内存区域\"><a href=\"#java内存区域\" class=\"headerlink\" title=\"java内存区域\"></a>java内存区域</h4><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域： </p>\n<p><img src=\"http://image.tupelo.top/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png?imageMogr2/auto-orient/thumbnail/700x700\" alt=\"java内存区域\"></p>","more":"<ul>\n<li>程序计数器</li>\n</ul>\n<p>当前线程执行的字节码的行号指示器，占用空间小，也无法干涉</p>\n<ul>\n<li>虚拟机栈</li>\n</ul>\n<p>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，<br>存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。<br>每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。<br>栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p>\n<ul>\n<li>本地方法栈</li>\n</ul>\n<p>地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，<br>JVM只是简单地动态链接并直接调用native方法。</p>\n<ul>\n<li>Java堆</li>\n</ul>\n<p>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：<br>-Xms：堆的最小值；<br>-Xmx：堆的最大值；<br>-Xmn：新生代的大小；<br>-XX:NewSize；新生代最小值；<br>-XX:MaxNewSize：新生代最大值；<br>例如- Xmx256m</p>\n<ul>\n<li>方法区(运行时常量池)</li>\n</ul>\n<p>用于存储已经被虚拟机加载的类信息，常量(“zdy”,”123”等)，静态变量(static变量)等数据，可用以下参数调整：<br>jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；<br>jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize<br>jdk1.8以后大小就只受本机总内存的限制<br>如：-XX:MaxMetaspaceSize=3M</p>\n<ul>\n<li>直接内存</li>\n</ul>\n<p>不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；<br>如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；<br>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），<br>所以也会出现OOM异常。</p>\n<p>栈、本地方法栈、程序计数器为线程私有内存区，随线程产生和消亡，不需要过多考虑内存回收的问题。堆和方法区为线程间共享。</p>\n<h4 id=\"java内存区域各个版本之间的变化\"><a href=\"#java内存区域各个版本之间的变化\" class=\"headerlink\" title=\"java内存区域各个版本之间的变化\"></a>java内存区域各个版本之间的变化</h4><ul>\n<li>jdk1.6 运行时常量池和方法区在一起</li>\n<li>jdk1.7 运行时常量池改为和堆在一起</li>\n<li>jdk1.8 方法区移出了运行时数据区，并改为了元空间metaspace</li>\n</ul>\n<h4 id=\"栈上分配和逃逸分析\"><a href=\"#栈上分配和逃逸分析\" class=\"headerlink\" title=\"栈上分配和逃逸分析\"></a>栈上分配和逃逸分析</h4><p>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，<font color=\"red\">任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</font></p>\n<ul>\n<li>启用栈上分配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client</span><br><span class=\"line\">-Xmx10m和-Xms10m：堆的大小</span><br><span class=\"line\">-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)</span><br><span class=\"line\">-XX:+PrintGC：打印GC日志</span><br><span class=\"line\">-XX:+EliminateAllocations：标量替换(默认打开)</span><br><span class=\"line\">-XX:-UseTLAB 关闭本地线程分配缓冲TLABThreadLocalAllocBuffer</span><br></pre></td></tr></table></figure>\n<p>对栈上分配发生影响的参数就是三个，<code>-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations</code>，任何一个发生变化都不会发生栈上分配，其中启用逃逸分析和标量替换默认是打开的。</p>\n<h4 id=\"虚拟机中对象的分配\"><a href=\"#虚拟机中对象的分配\" class=\"headerlink\" title=\"虚拟机中对象的分配\"></a>虚拟机中对象的分配</h4><p>虚拟机遇到一条new指令时：      </p>\n<ol>\n<li>先执行相应的类加载过程。</li>\n<li>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>如果Java堆中<font color=\"red\">内存是绝对规整的</font>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<font color=\"red\">指针碰撞</font>”。<br>如果Java堆中的<font color=\"red\">内存并不是规整的</font>，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<font color=\"red\">空闲列表</font>”。<br><font color=\"red\">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</font><br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理,实际上虚拟机采用<font color=\"red\">CAS配上失败重试的方式保证更新操作的原子性</font>；<br>另一种是<font color=\"red\">把内存分配的动作按照线程划分在不同的空间之中进行</font>，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数<font color=\"red\"><code>-XX:UseTLAB</code></font>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。<br>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。<br>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</li>\n<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>\n<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中</li>\n<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><ul>\n<li>对象头（Header）</li>\n<li>实例数据（Instance Data）</li>\n<li>对齐填充（Padding）</li>\n</ul>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><ul>\n<li>句柄访问</li>\n<li>直接指针访问</li>\n</ul>\n<h4 id=\"堆参数设置和内存溢出实战\"><a href=\"#堆参数设置和内存溢出实战\" class=\"headerlink\" title=\"堆参数设置和内存溢出实战\"></a>堆参数设置和内存溢出实战</h4><ul>\n<li>堆溢出</li>\n</ul>\n<p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 一般是（某个循环里可能性最大）在不停的分配对象，但是分配的太多，把堆撑爆了。<br><code>java.lang.OutOfMemoryError: Java heap space</code> 一般是分配了巨型对象。     </p>\n<ul>\n<li>栈溢出</li>\n</ul>\n<p><code>java.lang.StackOverflowError</code> 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。</p>"},{"title":"JVM - 垃圾回收与内存分配策略","_content":"\n垃圾回收与内存分配策略\n\n#### 判断对象的存活\n\n- 引用计数法\n\n    当一个对象有引用的时候计数+1,引用结束时计数-1,当计数大于0时则认为对象存活。\n    优点：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否改回收。\n\n- 可达性分析\n\n    通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，\n    搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。\n    作为GC Roots的对象包括下面几种：\n    1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n    2. 方法区中类静态属性引用的对象。\n    3. 方法区中常量引用的对象。\n    4. 本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n<!-- more -->\n\n#### java中的引用\n\n- 强引用\n\n    一般的Object obj = new Object() ，就属于强引用。\n\n- 软引用 SoftReference\n\n    一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。\n\n- 弱引用 WeakReference\n\n    一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，\n    GC发生时，不管内存够不够，都会被回收。\n\n- 虚引用 PhantomReference\n\n软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。\n例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。\n\n#### 垃圾回收算法\n\n- 标记-清除算法（Mark-Sweep）\n\n    算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n    它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，\n    无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n- 复制算法（Copying）\n\n    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，\n    然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，\n    内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。\n    只是这种算法的代价是将内存缩小为了原来的一半。\n\n- 标记-整理算法（Mark-Compact）\n\n    首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，\n    而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。\n在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。\n\n\n#### 垃圾回收器\n\n\n##### Serial\n\n新生代,复制算法,单线程,进行垃圾收集时,必须暂停所有工作线程,直到完成(stop the world).简单高效,适合内存不大的情况.\n\n##### ParNew\n\n新生代,复制算法,并行的多线程收集器,ParNew垃圾收集器是Serial收集器的多线程版本.搭配CMS垃圾回收器的首选.\n\n##### Parallel Scavenge吞吐量优先收集器\n\n新生代,复制算法,并行的多线程收集器,类似ParNew,更加关注吞吐量,达到一个可控制的吞吐量.适合本身是Server级别多CPU机器上的默认GC方式,主要适合后台运算不需要太多交互的任务.\n\n##### Serial Old\n\n老年代,标记整理算法,单线程,jdk7/8默认的老生代垃圾回收器.适合Client模式下虚拟机使用.\n\n\n##### Parallel Old\n\n老年代,标记整理算法,并行的多线程收集器,Parallel Scavenge收集器的老年代版本,为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合. 在注重吞吐量以及CPU资源敏感的场合采用\n\n\n##### CMS\n\n老年代,标记清除算法 ,并行与并发收集器,尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：\n1. 内存碎片\n2. 需要更多cpu资源\n3. 浮动垃圾问题，需要更大的堆空间  \n适合于重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器.\n\n##### G1\n\n跨新生代和老年代；标记整理 + 化整为零,并行与并发收集器    JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势,面向服务端应用的垃圾回收器，目标为取代CMS\n\n\n回收器之间的关系：\n\n![垃圾回收器](http://image.tupelo.top/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg)\n\n\n回收器相关配置:\n\n-XX:+UseSerialGC 新生代和老年代都用串行收集器     \n-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old        \n-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old      \n-XX:+ UseParallelOldGC 新生代使用ParallerGC，老年代使用Parallel Old        \n-XX:+UseConcMarkSweepGC 表示新生代使用ParNew，老年代的用CMS      \n-XX:+UseG1GC 使用G1收集器        \n\n\n#### Stop The World现象\n\nGC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数.\n\n\n#### 内存分配与回收策略\n\n1. 对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC\n2. 大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。\n-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。\n3. 长期存活的对象将进入老年代，默认15岁，-XX:MaxTenuringThreshold调整\n4. 动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄\n5. 空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。\n   \n\n#### 内存泄漏和内存溢出辨析(todo)\n\n内存溢出：实实在在的内存空间不足导致.         \n内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下.          \n\n#### JDK为我们提供的工具 \n\n- jps \n- jstat\n- jinfo \n- jmap\n- jhat\n- jstack\n\n其它分析工具 MAT\n    \n \n","source":"_posts/jvm-垃圾回收与内存分配策略.md","raw":"---\ntitle: JVM - 垃圾回收与内存分配策略\ntags:\n  - JVM\n---\n\n垃圾回收与内存分配策略\n\n#### 判断对象的存活\n\n- 引用计数法\n\n    当一个对象有引用的时候计数+1,引用结束时计数-1,当计数大于0时则认为对象存活。\n    优点：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否改回收。\n\n- 可达性分析\n\n    通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，\n    搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。\n    作为GC Roots的对象包括下面几种：\n    1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n    2. 方法区中类静态属性引用的对象。\n    3. 方法区中常量引用的对象。\n    4. 本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n<!-- more -->\n\n#### java中的引用\n\n- 强引用\n\n    一般的Object obj = new Object() ，就属于强引用。\n\n- 软引用 SoftReference\n\n    一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。\n\n- 弱引用 WeakReference\n\n    一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，\n    GC发生时，不管内存够不够，都会被回收。\n\n- 虚引用 PhantomReference\n\n软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。\n例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。\n\n#### 垃圾回收算法\n\n- 标记-清除算法（Mark-Sweep）\n\n    算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n    它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，\n    无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n- 复制算法（Copying）\n\n    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，\n    然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，\n    内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。\n    只是这种算法的代价是将内存缩小为了原来的一半。\n\n- 标记-整理算法（Mark-Compact）\n\n    首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，\n    而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。\n在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。\n\n\n#### 垃圾回收器\n\n\n##### Serial\n\n新生代,复制算法,单线程,进行垃圾收集时,必须暂停所有工作线程,直到完成(stop the world).简单高效,适合内存不大的情况.\n\n##### ParNew\n\n新生代,复制算法,并行的多线程收集器,ParNew垃圾收集器是Serial收集器的多线程版本.搭配CMS垃圾回收器的首选.\n\n##### Parallel Scavenge吞吐量优先收集器\n\n新生代,复制算法,并行的多线程收集器,类似ParNew,更加关注吞吐量,达到一个可控制的吞吐量.适合本身是Server级别多CPU机器上的默认GC方式,主要适合后台运算不需要太多交互的任务.\n\n##### Serial Old\n\n老年代,标记整理算法,单线程,jdk7/8默认的老生代垃圾回收器.适合Client模式下虚拟机使用.\n\n\n##### Parallel Old\n\n老年代,标记整理算法,并行的多线程收集器,Parallel Scavenge收集器的老年代版本,为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合. 在注重吞吐量以及CPU资源敏感的场合采用\n\n\n##### CMS\n\n老年代,标记清除算法 ,并行与并发收集器,尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：\n1. 内存碎片\n2. 需要更多cpu资源\n3. 浮动垃圾问题，需要更大的堆空间  \n适合于重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器.\n\n##### G1\n\n跨新生代和老年代；标记整理 + 化整为零,并行与并发收集器    JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势,面向服务端应用的垃圾回收器，目标为取代CMS\n\n\n回收器之间的关系：\n\n![垃圾回收器](http://image.tupelo.top/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg)\n\n\n回收器相关配置:\n\n-XX:+UseSerialGC 新生代和老年代都用串行收集器     \n-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old        \n-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old      \n-XX:+ UseParallelOldGC 新生代使用ParallerGC，老年代使用Parallel Old        \n-XX:+UseConcMarkSweepGC 表示新生代使用ParNew，老年代的用CMS      \n-XX:+UseG1GC 使用G1收集器        \n\n\n#### Stop The World现象\n\nGC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数.\n\n\n#### 内存分配与回收策略\n\n1. 对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC\n2. 大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。\n-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。\n3. 长期存活的对象将进入老年代，默认15岁，-XX:MaxTenuringThreshold调整\n4. 动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄\n5. 空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。\n   \n\n#### 内存泄漏和内存溢出辨析(todo)\n\n内存溢出：实实在在的内存空间不足导致.         \n内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下.          \n\n#### JDK为我们提供的工具 \n\n- jps \n- jstat\n- jinfo \n- jmap\n- jhat\n- jstack\n\n其它分析工具 MAT\n    \n \n","slug":"jvm-垃圾回收与内存分配策略","published":1,"date":"2023-05-19T02:16:10.335Z","updated":"2023-05-19T02:16:10.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15an001a9gj736rvzzzz","content":"<p>垃圾回收与内存分配策略</p>\n<h4 id=\"判断对象的存活\"><a href=\"#判断对象的存活\" class=\"headerlink\" title=\"判断对象的存活\"></a>判断对象的存活</h4><ul>\n<li><p>引用计数法</p>\n<p>  当一个对象有引用的时候计数+1,引用结束时计数-1,当计数大于0时则认为对象存活。<br>  优点：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否改回收。</p>\n</li>\n<li><p>可达性分析</p>\n<p>  通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，<br>  搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>  作为GC Roots的对象包括下面几种：</p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>\n<li>方法区中类静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>\n</ol>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"java中的引用\"><a href=\"#java中的引用\" class=\"headerlink\" title=\"java中的引用\"></a>java中的引用</h4><ul>\n<li><p>强引用</p>\n<p>  一般的Object obj = new Object() ，就属于强引用。</p>\n</li>\n<li><p>软引用 SoftReference</p>\n<p>  一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。</p>\n</li>\n<li><p>弱引用 WeakReference</p>\n<p>  一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，<br>  GC发生时，不管内存够不够，都会被回收。</p>\n</li>\n<li><p>虚引用 PhantomReference</p>\n</li>\n</ul>\n<p>软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。<br>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p>\n<h4 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h4><ul>\n<li><p>标记-清除算法（Mark-Sweep）</p>\n<p>  算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>  它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，<br>  无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n</li>\n<li><p>复制算法（Copying）</p>\n<p>  将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，<br>  然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，<br>  内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。<br>  只是这种算法的代价是将内存缩小为了原来的一半。</p>\n</li>\n<li><p>标记-整理算法（Mark-Compact）</p>\n<p>  首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，<br>  而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n</li>\n</ul>\n<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>\n<h4 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h4><h5 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h5><p>新生代,复制算法,单线程,进行垃圾收集时,必须暂停所有工作线程,直到完成(stop the world).简单高效,适合内存不大的情况.</p>\n<h5 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h5><p>新生代,复制算法,并行的多线程收集器,ParNew垃圾收集器是Serial收集器的多线程版本.搭配CMS垃圾回收器的首选.</p>\n<h5 id=\"Parallel-Scavenge吞吐量优先收集器\"><a href=\"#Parallel-Scavenge吞吐量优先收集器\" class=\"headerlink\" title=\"Parallel Scavenge吞吐量优先收集器\"></a>Parallel Scavenge吞吐量优先收集器</h5><p>新生代,复制算法,并行的多线程收集器,类似ParNew,更加关注吞吐量,达到一个可控制的吞吐量.适合本身是Server级别多CPU机器上的默认GC方式,主要适合后台运算不需要太多交互的任务.</p>\n<h5 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h5><p>老年代,标记整理算法,单线程,jdk7/8默认的老生代垃圾回收器.适合Client模式下虚拟机使用.</p>\n<h5 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h5><p>老年代,标记整理算法,并行的多线程收集器,Parallel Scavenge收集器的老年代版本,为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合. 在注重吞吐量以及CPU资源敏感的场合采用</p>\n<h5 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h5><p>老年代,标记清除算法 ,并行与并发收集器,尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：</p>\n<ol>\n<li>内存碎片</li>\n<li>需要更多cpu资源</li>\n<li>浮动垃圾问题，需要更大的堆空间<br>适合于重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器.</li>\n</ol>\n<h5 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h5><p>跨新生代和老年代；标记整理 + 化整为零,并行与并发收集器    JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势,面向服务端应用的垃圾回收器，目标为取代CMS</p>\n<p>回收器之间的关系：</p>\n<p><img src=\"http://image.tupelo.top/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg\" alt=\"垃圾回收器\"></p>\n<p>回收器相关配置:</p>\n<p>-XX:+UseSerialGC 新生代和老年代都用串行收集器<br>-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old<br>-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old<br>-XX:+ UseParallelOldGC 新生代使用ParallerGC，老年代使用Parallel Old<br>-XX:+UseConcMarkSweepGC 表示新生代使用ParNew，老年代的用CMS<br>-XX:+UseG1GC 使用G1收集器        </p>\n<h4 id=\"Stop-The-World现象\"><a href=\"#Stop-The-World现象\" class=\"headerlink\" title=\"Stop The World现象\"></a>Stop The World现象</h4><p>GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数.</p>\n<h4 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h4><ol>\n<li>对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC</li>\n<li>大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。<br>-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。</li>\n<li>长期存活的对象将进入老年代，默认15岁，-XX:MaxTenuringThreshold调整</li>\n<li>动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li>\n<li>空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。</li>\n</ol>\n<h4 id=\"内存泄漏和内存溢出辨析-todo\"><a href=\"#内存泄漏和内存溢出辨析-todo\" class=\"headerlink\" title=\"内存泄漏和内存溢出辨析(todo)\"></a>内存泄漏和内存溢出辨析(todo)</h4><p>内存溢出：实实在在的内存空间不足导致.<br>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下.          </p>\n<h4 id=\"JDK为我们提供的工具\"><a href=\"#JDK为我们提供的工具\" class=\"headerlink\" title=\"JDK为我们提供的工具\"></a>JDK为我们提供的工具</h4><ul>\n<li>jps </li>\n<li>jstat</li>\n<li>jinfo </li>\n<li>jmap</li>\n<li>jhat</li>\n<li>jstack</li>\n</ul>\n<p>其它分析工具 MAT</p>\n","site":{"data":{}},"excerpt":"<p>垃圾回收与内存分配策略</p>\n<h4 id=\"判断对象的存活\"><a href=\"#判断对象的存活\" class=\"headerlink\" title=\"判断对象的存活\"></a>判断对象的存活</h4><ul>\n<li><p>引用计数法</p>\n<p>  当一个对象有引用的时候计数+1,引用结束时计数-1,当计数大于0时则认为对象存活。<br>  优点：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否改回收。</p>\n</li>\n<li><p>可达性分析</p>\n<p>  通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，<br>  搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>  作为GC Roots的对象包括下面几种：</p>\n<ol>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>\n<li>方法区中类静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>\n</ol>\n</li>\n</ul>","more":"<h4 id=\"java中的引用\"><a href=\"#java中的引用\" class=\"headerlink\" title=\"java中的引用\"></a>java中的引用</h4><ul>\n<li><p>强引用</p>\n<p>  一般的Object obj = new Object() ，就属于强引用。</p>\n</li>\n<li><p>软引用 SoftReference</p>\n<p>  一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。</p>\n</li>\n<li><p>弱引用 WeakReference</p>\n<p>  一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，<br>  GC发生时，不管内存够不够，都会被回收。</p>\n</li>\n<li><p>虚引用 PhantomReference</p>\n</li>\n</ul>\n<p>软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。<br>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p>\n<h4 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h4><ul>\n<li><p>标记-清除算法（Mark-Sweep）</p>\n<p>  算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>  它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，<br>  无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n</li>\n<li><p>复制算法（Copying）</p>\n<p>  将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，<br>  然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，<br>  内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。<br>  只是这种算法的代价是将内存缩小为了原来的一半。</p>\n</li>\n<li><p>标记-整理算法（Mark-Compact）</p>\n<p>  首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，<br>  而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n</li>\n</ul>\n<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>\n<h4 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h4><h5 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h5><p>新生代,复制算法,单线程,进行垃圾收集时,必须暂停所有工作线程,直到完成(stop the world).简单高效,适合内存不大的情况.</p>\n<h5 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h5><p>新生代,复制算法,并行的多线程收集器,ParNew垃圾收集器是Serial收集器的多线程版本.搭配CMS垃圾回收器的首选.</p>\n<h5 id=\"Parallel-Scavenge吞吐量优先收集器\"><a href=\"#Parallel-Scavenge吞吐量优先收集器\" class=\"headerlink\" title=\"Parallel Scavenge吞吐量优先收集器\"></a>Parallel Scavenge吞吐量优先收集器</h5><p>新生代,复制算法,并行的多线程收集器,类似ParNew,更加关注吞吐量,达到一个可控制的吞吐量.适合本身是Server级别多CPU机器上的默认GC方式,主要适合后台运算不需要太多交互的任务.</p>\n<h5 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h5><p>老年代,标记整理算法,单线程,jdk7/8默认的老生代垃圾回收器.适合Client模式下虚拟机使用.</p>\n<h5 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h5><p>老年代,标记整理算法,并行的多线程收集器,Parallel Scavenge收集器的老年代版本,为了配合Parallel Scavenge的面向吞吐量的特性而开发的对应组合. 在注重吞吐量以及CPU资源敏感的场合采用</p>\n<h5 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h5><p>老年代,标记清除算法 ,并行与并发收集器,尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：</p>\n<ol>\n<li>内存碎片</li>\n<li>需要更多cpu资源</li>\n<li>浮动垃圾问题，需要更大的堆空间<br>适合于重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器.</li>\n</ol>\n<h5 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h5><p>跨新生代和老年代；标记整理 + 化整为零,并行与并发收集器    JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势,面向服务端应用的垃圾回收器，目标为取代CMS</p>\n<p>回收器之间的关系：</p>\n<p><img src=\"http://image.tupelo.top/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg\" alt=\"垃圾回收器\"></p>\n<p>回收器相关配置:</p>\n<p>-XX:+UseSerialGC 新生代和老年代都用串行收集器<br>-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old<br>-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old<br>-XX:+ UseParallelOldGC 新生代使用ParallerGC，老年代使用Parallel Old<br>-XX:+UseConcMarkSweepGC 表示新生代使用ParNew，老年代的用CMS<br>-XX:+UseG1GC 使用G1收集器        </p>\n<h4 id=\"Stop-The-World现象\"><a href=\"#Stop-The-World现象\" class=\"headerlink\" title=\"Stop The World现象\"></a>Stop The World现象</h4><p>GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数.</p>\n<h4 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h4><ol>\n<li>对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC</li>\n<li>大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。<br>-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。</li>\n<li>长期存活的对象将进入老年代，默认15岁，-XX:MaxTenuringThreshold调整</li>\n<li>动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li>\n<li>空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。</li>\n</ol>\n<h4 id=\"内存泄漏和内存溢出辨析-todo\"><a href=\"#内存泄漏和内存溢出辨析-todo\" class=\"headerlink\" title=\"内存泄漏和内存溢出辨析(todo)\"></a>内存泄漏和内存溢出辨析(todo)</h4><p>内存溢出：实实在在的内存空间不足导致.<br>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下.          </p>\n<h4 id=\"JDK为我们提供的工具\"><a href=\"#JDK为我们提供的工具\" class=\"headerlink\" title=\"JDK为我们提供的工具\"></a>JDK为我们提供的工具</h4><ul>\n<li>jps </li>\n<li>jstat</li>\n<li>jinfo </li>\n<li>jmap</li>\n<li>jhat</li>\n<li>jstack</li>\n</ul>\n<p>其它分析工具 MAT</p>"},{"title":"Kafka学习 - 安装","_content":"\nkafka基础学习-在centos7服务器上搭建kafka\n\n### 安装zookeeper\n\n- 下载zookeeper安装包 [https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/](https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/)\n\n- 解压到指定目录 \n```bash\ntar -zxvf zookeeper-3.4.10.tar.gz -C /usr/local/zookeeper\n```\n\n- 修改配置文件\n```bash\ncd /usr/local/zookeeper/zookeeper-3.4.10/conf/\ncp zoo_sample.cfg zoo.cfg\n```\n\n<!-- more -->\n\n- 修改zoo.cfg一些基本设置 数据目录 日志目录等\n\n- 配置环境变量(未生效 原因待定)\n```bash\nvim /etc/profile\n\nexport ZOOKEEPER_HOME=/usr/local/zookeeper/zookeeper-3.4.10/\nexport PATH=$ZOOKEEPER_HOME/bin:$PATH\n\nsource /et/profile\n```\n\n- 启动zookeeper\n```bash\n./zkServer.sh start/status/stop/restart\n```\n\n\n### 安装kafka\n\n- 下载kafka安装包 [http://kafka.apache.org/downloads.html](http://kafka.apache.org/downloads.html)\n\n\n- 解压到指定目录 \n```bash\ntar -zxvf kafka_2.12-2.0.0.tgz -C /usr/local/kafka/\n```\n\n- 配置环境变量\n\n```bash\nvim /etc/profile\n\nexport KAFKA_HOME=/usr/local/kafka/kafka_2.12-2.0.0\nexport PATH=$PATH:$KAFKA_HOME/bin\n\nsource /et/profile\n```\n\n\n- 验证kafka功能\n    - 启动zookeeper\n    ```bash\n\t./zookeeper-server-start.sh -daemon ../config/zookeeper.properties\n    ```\n\n    - 启动kafka\n    ```bash\n\t./kafka-server-start.sh ../config/server.properties\n    ```\n\n    - 我的服务器为1核1G，kafka启动报错,内存不足Cannot allocate memory\n    ```bash\n    Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error='Cannot allocate memory' (errno=12)\n\t#\n\t# There is insufficient memory for the Java Runtime Environment to continue.\n\t# Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.\n\t# An error report file with more information is saved as:\n\t# /usr/local/kafka/kafka_2.12-2.0.0/bin/hs_err_pid6279.log\n    ```\n\n    - 查看启动脚本 [kafka-server-start.sh] 发现默认配置为：\n    ```bash\n    if [ \"x$KAFKA_HEAP_OPTS\" = \"x\" ]; then\n    \texport KAFKA_HEAP_OPTS=\"-Xmx1G -Xms1G\"\n\tfi\n    ```\n    修改配置为 [-Xmx256M -Xms128M] 重启kafka成功\n\n    - 测试创建一个topic\n    ```bash\n\t./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 1 --replication-factor 1 --topic test\n    ```\n\n    - 查看topic列表\n    ```bash\n\t./kafka-topics.sh --list --zookeeper localhost:2181\n    ```\n\n    - 生产者发送消息\n    ```bash\n\t./kafka-console-producer.sh --broker-list localhost:9092 --topic test\n\t>haha\n    ```\n\n    - 消费者接受消息\n    ```bash\n    ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning\n\thaha\n    ```\n\n    - 集群配置(未配置)...\n\n","source":"_posts/kafka-01.md","raw":"---\ntitle: Kafka学习 - 安装\ntags:\n  - Kafka\n  - Zookeeper\n---\n\nkafka基础学习-在centos7服务器上搭建kafka\n\n### 安装zookeeper\n\n- 下载zookeeper安装包 [https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/](https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/)\n\n- 解压到指定目录 \n```bash\ntar -zxvf zookeeper-3.4.10.tar.gz -C /usr/local/zookeeper\n```\n\n- 修改配置文件\n```bash\ncd /usr/local/zookeeper/zookeeper-3.4.10/conf/\ncp zoo_sample.cfg zoo.cfg\n```\n\n<!-- more -->\n\n- 修改zoo.cfg一些基本设置 数据目录 日志目录等\n\n- 配置环境变量(未生效 原因待定)\n```bash\nvim /etc/profile\n\nexport ZOOKEEPER_HOME=/usr/local/zookeeper/zookeeper-3.4.10/\nexport PATH=$ZOOKEEPER_HOME/bin:$PATH\n\nsource /et/profile\n```\n\n- 启动zookeeper\n```bash\n./zkServer.sh start/status/stop/restart\n```\n\n\n### 安装kafka\n\n- 下载kafka安装包 [http://kafka.apache.org/downloads.html](http://kafka.apache.org/downloads.html)\n\n\n- 解压到指定目录 \n```bash\ntar -zxvf kafka_2.12-2.0.0.tgz -C /usr/local/kafka/\n```\n\n- 配置环境变量\n\n```bash\nvim /etc/profile\n\nexport KAFKA_HOME=/usr/local/kafka/kafka_2.12-2.0.0\nexport PATH=$PATH:$KAFKA_HOME/bin\n\nsource /et/profile\n```\n\n\n- 验证kafka功能\n    - 启动zookeeper\n    ```bash\n\t./zookeeper-server-start.sh -daemon ../config/zookeeper.properties\n    ```\n\n    - 启动kafka\n    ```bash\n\t./kafka-server-start.sh ../config/server.properties\n    ```\n\n    - 我的服务器为1核1G，kafka启动报错,内存不足Cannot allocate memory\n    ```bash\n    Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error='Cannot allocate memory' (errno=12)\n\t#\n\t# There is insufficient memory for the Java Runtime Environment to continue.\n\t# Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.\n\t# An error report file with more information is saved as:\n\t# /usr/local/kafka/kafka_2.12-2.0.0/bin/hs_err_pid6279.log\n    ```\n\n    - 查看启动脚本 [kafka-server-start.sh] 发现默认配置为：\n    ```bash\n    if [ \"x$KAFKA_HEAP_OPTS\" = \"x\" ]; then\n    \texport KAFKA_HEAP_OPTS=\"-Xmx1G -Xms1G\"\n\tfi\n    ```\n    修改配置为 [-Xmx256M -Xms128M] 重启kafka成功\n\n    - 测试创建一个topic\n    ```bash\n\t./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 1 --replication-factor 1 --topic test\n    ```\n\n    - 查看topic列表\n    ```bash\n\t./kafka-topics.sh --list --zookeeper localhost:2181\n    ```\n\n    - 生产者发送消息\n    ```bash\n\t./kafka-console-producer.sh --broker-list localhost:9092 --topic test\n\t>haha\n    ```\n\n    - 消费者接受消息\n    ```bash\n    ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning\n\thaha\n    ```\n\n    - 集群配置(未配置)...\n\n","slug":"kafka-01","published":1,"date":"2025-02-12T08:28:16.464Z","updated":"2025-02-12T08:28:16.464Z","_id":"clhua15ao001c9gj7oxhvr7hr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>kafka基础学习-在centos7服务器上搭建kafka</p>\n<h3 id=\"安装zookeeper\"><a href=\"#安装zookeeper\" class=\"headerlink\" title=\"安装zookeeper\"></a>安装zookeeper</h3><ul>\n<li><p>下载zookeeper安装包 <a href=\"https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/\" target=\"_blank\" rel=\"noopener\">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/</a></p>\n</li>\n<li><p>解压到指定目录 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf zookeeper-3.4.10.tar.gz -C /usr/<span class=\"built_in\">local</span>/zookeeper</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/zookeeper/zookeeper-3.4.10/conf/</span><br><span class=\"line\">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>修改zoo.cfg一些基本设置 数据目录 日志目录等</p>\n</li>\n<li><p>配置环境变量(未生效 原因待定)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> ZOOKEEPER_HOME=/usr/<span class=\"built_in\">local</span>/zookeeper/zookeeper-3.4.10/</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$ZOOKEEPER_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> /et/profile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动zookeeper</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zkServer.sh start/status/stop/restart</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h3><ul>\n<li>下载kafka安装包 <a href=\"http://kafka.apache.org/downloads.html\" target=\"_blank\" rel=\"noopener\">http://kafka.apache.org/downloads.html</a></li>\n</ul>\n<ul>\n<li><p>解压到指定目录 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf kafka_2.12-2.0.0.tgz -C /usr/<span class=\"built_in\">local</span>/kafka/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置环境变量</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_HOME=/usr/<span class=\"built_in\">local</span>/kafka/kafka_2.12-2.0.0</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$KAFKA_HOME</span>/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> /et/profile</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>验证kafka功能</p>\n<ul>\n<li><p>启动zookeeper</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zookeeper-server-start.sh -daemon ../config/zookeeper.properties</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动kafka</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-server-start.sh ../config/server.properties</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我的服务器为1核1G，kafka启动报错,内存不足Cannot allocate memory</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error=<span class=\"string\">'Cannot allocate memory'</span> (errno=12)</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># There is insufficient memory for the Java Runtime Environment to continue.</span></span><br><span class=\"line\"><span class=\"comment\"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span></span><br><span class=\"line\"><span class=\"comment\"># An error report file with more information is saved as:</span></span><br><span class=\"line\"><span class=\"comment\"># /usr/local/kafka/kafka_2.12-2.0.0/bin/hs_err_pid6279.log</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看启动脚本 [kafka-server-start.sh] 发现默认配置为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">if</span> [ <span class=\"string\">\"x<span class=\"variable\">$KAFKA_HEAP_OPTS</span>\"</span> = <span class=\"string\">\"x\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">   \t<span class=\"built_in\">export</span> KAFKA_HEAP_OPTS=<span class=\"string\">\"-Xmx1G -Xms1G\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<p>修改配置为 [-Xmx256M -Xms128M] 重启kafka成功</p>\n</li>\n<li><p>测试创建一个topic</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 1 --replication-factor 1 --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看topic列表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者发送消息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --broker-list localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt;haha</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消费者接受消息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --from-beginning</span><br><span class=\"line\">haha</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集群配置(未配置)…</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>kafka基础学习-在centos7服务器上搭建kafka</p>\n<h3 id=\"安装zookeeper\"><a href=\"#安装zookeeper\" class=\"headerlink\" title=\"安装zookeeper\"></a>安装zookeeper</h3><ul>\n<li><p>下载zookeeper安装包 <a href=\"https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/\" target=\"_blank\" rel=\"noopener\">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/</a></p>\n</li>\n<li><p>解压到指定目录 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf zookeeper-3.4.10.tar.gz -C /usr/<span class=\"built_in\">local</span>/zookeeper</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/zookeeper/zookeeper-3.4.10/conf/</span><br><span class=\"line\">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>\n</li>\n</ul>","more":"<ul>\n<li><p>修改zoo.cfg一些基本设置 数据目录 日志目录等</p>\n</li>\n<li><p>配置环境变量(未生效 原因待定)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> ZOOKEEPER_HOME=/usr/<span class=\"built_in\">local</span>/zookeeper/zookeeper-3.4.10/</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$ZOOKEEPER_HOME</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> /et/profile</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动zookeeper</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zkServer.sh start/status/stop/restart</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"安装kafka\"><a href=\"#安装kafka\" class=\"headerlink\" title=\"安装kafka\"></a>安装kafka</h3><ul>\n<li>下载kafka安装包 <a href=\"http://kafka.apache.org/downloads.html\" target=\"_blank\" rel=\"noopener\">http://kafka.apache.org/downloads.html</a></li>\n</ul>\n<ul>\n<li><p>解压到指定目录 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf kafka_2.12-2.0.0.tgz -C /usr/<span class=\"built_in\">local</span>/kafka/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置环境变量</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> KAFKA_HOME=/usr/<span class=\"built_in\">local</span>/kafka/kafka_2.12-2.0.0</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$KAFKA_HOME</span>/bin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> /et/profile</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>验证kafka功能</p>\n<ul>\n<li><p>启动zookeeper</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zookeeper-server-start.sh -daemon ../config/zookeeper.properties</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动kafka</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-server-start.sh ../config/server.properties</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我的服务器为1核1G，kafka启动报错,内存不足Cannot allocate memory</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error=<span class=\"string\">'Cannot allocate memory'</span> (errno=12)</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># There is insufficient memory for the Java Runtime Environment to continue.</span></span><br><span class=\"line\"><span class=\"comment\"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span></span><br><span class=\"line\"><span class=\"comment\"># An error report file with more information is saved as:</span></span><br><span class=\"line\"><span class=\"comment\"># /usr/local/kafka/kafka_2.12-2.0.0/bin/hs_err_pid6279.log</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看启动脚本 [kafka-server-start.sh] 发现默认配置为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">if</span> [ <span class=\"string\">\"x<span class=\"variable\">$KAFKA_HEAP_OPTS</span>\"</span> = <span class=\"string\">\"x\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">   \t<span class=\"built_in\">export</span> KAFKA_HEAP_OPTS=<span class=\"string\">\"-Xmx1G -Xms1G\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<p>修改配置为 [-Xmx256M -Xms128M] 重启kafka成功</p>\n</li>\n<li><p>测试创建一个topic</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --create --zookeeper localhost:2181 --partitions 1 --replication-factor 1 --topic <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看topic列表</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者发送消息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --broker-list localhost:9092 --topic <span class=\"built_in\">test</span></span><br><span class=\"line\">&gt;haha</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消费者接受消息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class=\"built_in\">test</span> --from-beginning</span><br><span class=\"line\">haha</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集群配置(未配置)…</p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"JVM - 执行子系统","_content":"\n执行子系统\n\n#### Class类文件结构\n\n\n#### 字节码指令\n\n\n\n#### 类加载机制\n\n\n\n#### 方法调用详解\n\n\n    \n \n\n\n","source":"_posts/jvm-执行子系统.md","raw":"---\ntitle: JVM - 执行子系统\ntags:\n  - JVM\n---\n\n执行子系统\n\n#### Class类文件结构\n\n\n#### 字节码指令\n\n\n\n#### 类加载机制\n\n\n\n#### 方法调用详解\n\n\n    \n \n\n\n","slug":"jvm-执行子系统","published":1,"date":"2023-05-19T02:16:10.336Z","updated":"2023-05-19T02:16:10.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15ap001e9gj7kaxem7y9","content":"<p>执行子系统</p>\n<h4 id=\"Class类文件结构\"><a href=\"#Class类文件结构\" class=\"headerlink\" title=\"Class类文件结构\"></a>Class类文件结构</h4><h4 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h4><h4 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h4><h4 id=\"方法调用详解\"><a href=\"#方法调用详解\" class=\"headerlink\" title=\"方法调用详解\"></a>方法调用详解</h4>","site":{"data":{}},"excerpt":"","more":"<p>执行子系统</p>\n<h4 id=\"Class类文件结构\"><a href=\"#Class类文件结构\" class=\"headerlink\" title=\"Class类文件结构\"></a>Class类文件结构</h4><h4 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h4><h4 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h4><h4 id=\"方法调用详解\"><a href=\"#方法调用详解\" class=\"headerlink\" title=\"方法调用详解\"></a>方法调用详解</h4>"},{"title":"RabbitMq - 入门","_content":"\nAMQP概论\n\n## 交换器、队列、绑定、路由键\n\n- rabbitMq流程\n\n![rabbitMq流程](http://image.tupelo.top/rabbitmq%E6%B5%81%E7%A8%8B.png)\n\n\t交换机类型:\n\tfanout 交换机绑定队列,根据交换机发送消息到指定队列\n\tdirect 交换机通过路由键绑定队列,根据交换机和路由键发送消息\n\ttopic  交换机通过路由键绑定队列,根据交换机和路由键发送消息(路由键可进行匹配 #匹配一次或者多次 *匹配一次)\n\n> 需要多个队列接受同样的消息 多个队列绑定同一个路由键 一条消息只能被一个消费者消费\n\n<!-- more -->\n\n### 不同交换机的Demo\n\n- 添加依赖\n\n```java\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n- 创建配置类,初始化的时候指定交换机的类型\n\n```java\n\n@Configuration\npublic class RabbitMqConfig {\n\n\t// 创建连接\n    @Bean\n    public ConnectionFactory connectionFactory() {\n        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();\n        connectionFactory.setHost(host);\n        connectionFactory.setPort(port);\n        connectionFactory.setUsername(username);\n        connectionFactory.setPassword(password);\n        connectionFactory.setVirtualHost(virtualHost);\n        return connectionFactory;\n    }\n\n    // 初始化 RabbitTemplate\n    @Bean\n    @Primary\n    public RabbitTemplate rabbitTemplate() {\n        return new RabbitTemplate(connectionFactory());\n    }\n\n    // 创建队列 没有的话会创建新的队列\n    @Bean\n    public Queue fanoutQueue(){\n        return new Queue(\"two.queue\");\n    }\n    @Bean\n    public Queue directQueue(){\n        return new Queue(\"four.queue\");\n    }\n    @Bean\n    public Queue topQueue(){\n        return new Queue(\"three.queue\");\n    }\n    @Bean\n    public Queue directOneQueue(){\n        return new Queue(\"four_one.queue\");\n    }\n\n    // 创建三种类型的交换机\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"two.exchange\");\n    }\n    @Bean\n    public DirectExchange directExchange(){\n        return new DirectExchange(\"four.exchange\");\n    }\n    @Bean\n    public TopicExchange topicExchange(){\n        return new TopicExchange(\"three.exchange\");\n    }\n\n    // 交换机和队列绑定\n    @Bean\n    public Binding fanoutBinding(){\n        return BindingBuilder.bind(fanoutQueue()).to(fanoutExchange());\n    }\n    @Bean\n    public Binding directBinding(){\n        return BindingBuilder.bind(directQueue()).to(directExchange()).with(\"four.bind\");\n    }\n    @Bean\n    public Binding directOneBinding(){\n        return BindingBuilder.bind(directOneQueue()).to(directExchange()).with(\"four.bind\");\n    }\n    @Bean\n    public Binding topicBinding(){\n        return BindingBuilder.bind(topQueue()).to(topicExchange()).with(\"topicBind\");\n    }\n}\n```\n\n- 消费者部分代码,只需要监听指定队列,获取的消息是根据生产者发送过来的消息(Message/String)\n\n```java\n@RabbitListener(queues = \"four.queue\")\n@RabbitHandler\npublic void fanoutConsumer2(Object msg){\n    Message message = (Message) msg;\n    log.info(\"2fanoutConsumer 接收消息msg: {}\" , new String(message.getBody()));\n}\n\n@RabbitListener(queues = \"four.queue\")\n@RabbitHandler\npublic void fanoutConsumer3(String msg){\n    log.info(\"3fanoutConsumer 接收消息msg: {}\" , msg);\n}\n```\n\n- 生产者部分代码(fanout方式路由键参数不生效),生产者不用考虑队列,投放消息只和交换机和路由键相关\n\n```java\n// 发送Message\n@RequestMapping(\"/send1/{msg}\")\npublic String sendMessage(@PathVariable(\"msg\") String msg) {\n    log.info(\"msg1\");\n    Message message = new Message(msg.getBytes(),new MessageProperties());\n    rabbitTemplate.send(\"four.exchange\",\"aqweq\",message);\n    return msg;\n}\n// 发送String\n@RequestMapping(\"/send/{msg}\")\npublic String sendMessage1(@PathVariable(\"msg\") String msg) {\n   log.info(\"msg2\");\n   amqpTemplate.convertAndSend(\"four.exchange\",\"four.bind\",msg);\n   return msg;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/rabbitmq-01.md","raw":"---\ntitle: RabbitMq - 入门\ntags:\n  - RabbitMq\n---\n\nAMQP概论\n\n## 交换器、队列、绑定、路由键\n\n- rabbitMq流程\n\n![rabbitMq流程](http://image.tupelo.top/rabbitmq%E6%B5%81%E7%A8%8B.png)\n\n\t交换机类型:\n\tfanout 交换机绑定队列,根据交换机发送消息到指定队列\n\tdirect 交换机通过路由键绑定队列,根据交换机和路由键发送消息\n\ttopic  交换机通过路由键绑定队列,根据交换机和路由键发送消息(路由键可进行匹配 #匹配一次或者多次 *匹配一次)\n\n> 需要多个队列接受同样的消息 多个队列绑定同一个路由键 一条消息只能被一个消费者消费\n\n<!-- more -->\n\n### 不同交换机的Demo\n\n- 添加依赖\n\n```java\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n- 创建配置类,初始化的时候指定交换机的类型\n\n```java\n\n@Configuration\npublic class RabbitMqConfig {\n\n\t// 创建连接\n    @Bean\n    public ConnectionFactory connectionFactory() {\n        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();\n        connectionFactory.setHost(host);\n        connectionFactory.setPort(port);\n        connectionFactory.setUsername(username);\n        connectionFactory.setPassword(password);\n        connectionFactory.setVirtualHost(virtualHost);\n        return connectionFactory;\n    }\n\n    // 初始化 RabbitTemplate\n    @Bean\n    @Primary\n    public RabbitTemplate rabbitTemplate() {\n        return new RabbitTemplate(connectionFactory());\n    }\n\n    // 创建队列 没有的话会创建新的队列\n    @Bean\n    public Queue fanoutQueue(){\n        return new Queue(\"two.queue\");\n    }\n    @Bean\n    public Queue directQueue(){\n        return new Queue(\"four.queue\");\n    }\n    @Bean\n    public Queue topQueue(){\n        return new Queue(\"three.queue\");\n    }\n    @Bean\n    public Queue directOneQueue(){\n        return new Queue(\"four_one.queue\");\n    }\n\n    // 创建三种类型的交换机\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"two.exchange\");\n    }\n    @Bean\n    public DirectExchange directExchange(){\n        return new DirectExchange(\"four.exchange\");\n    }\n    @Bean\n    public TopicExchange topicExchange(){\n        return new TopicExchange(\"three.exchange\");\n    }\n\n    // 交换机和队列绑定\n    @Bean\n    public Binding fanoutBinding(){\n        return BindingBuilder.bind(fanoutQueue()).to(fanoutExchange());\n    }\n    @Bean\n    public Binding directBinding(){\n        return BindingBuilder.bind(directQueue()).to(directExchange()).with(\"four.bind\");\n    }\n    @Bean\n    public Binding directOneBinding(){\n        return BindingBuilder.bind(directOneQueue()).to(directExchange()).with(\"four.bind\");\n    }\n    @Bean\n    public Binding topicBinding(){\n        return BindingBuilder.bind(topQueue()).to(topicExchange()).with(\"topicBind\");\n    }\n}\n```\n\n- 消费者部分代码,只需要监听指定队列,获取的消息是根据生产者发送过来的消息(Message/String)\n\n```java\n@RabbitListener(queues = \"four.queue\")\n@RabbitHandler\npublic void fanoutConsumer2(Object msg){\n    Message message = (Message) msg;\n    log.info(\"2fanoutConsumer 接收消息msg: {}\" , new String(message.getBody()));\n}\n\n@RabbitListener(queues = \"four.queue\")\n@RabbitHandler\npublic void fanoutConsumer3(String msg){\n    log.info(\"3fanoutConsumer 接收消息msg: {}\" , msg);\n}\n```\n\n- 生产者部分代码(fanout方式路由键参数不生效),生产者不用考虑队列,投放消息只和交换机和路由键相关\n\n```java\n// 发送Message\n@RequestMapping(\"/send1/{msg}\")\npublic String sendMessage(@PathVariable(\"msg\") String msg) {\n    log.info(\"msg1\");\n    Message message = new Message(msg.getBytes(),new MessageProperties());\n    rabbitTemplate.send(\"four.exchange\",\"aqweq\",message);\n    return msg;\n}\n// 发送String\n@RequestMapping(\"/send/{msg}\")\npublic String sendMessage1(@PathVariable(\"msg\") String msg) {\n   log.info(\"msg2\");\n   amqpTemplate.convertAndSend(\"four.exchange\",\"four.bind\",msg);\n   return msg;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"rabbitmq-01","published":1,"date":"2025-02-12T08:28:16.464Z","updated":"2025-02-12T08:28:16.464Z","_id":"clhua15aq001g9gj77wbjvx31","comments":1,"layout":"post","photos":[],"link":"","content":"<p>AMQP概论</p>\n<h2 id=\"交换器、队列、绑定、路由键\"><a href=\"#交换器、队列、绑定、路由键\" class=\"headerlink\" title=\"交换器、队列、绑定、路由键\"></a>交换器、队列、绑定、路由键</h2><ul>\n<li>rabbitMq流程</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/rabbitmq%E6%B5%81%E7%A8%8B.png\" alt=\"rabbitMq流程\"></p>\n<pre><code>交换机类型:\nfanout 交换机绑定队列,根据交换机发送消息到指定队列\ndirect 交换机通过路由键绑定队列,根据交换机和路由键发送消息\ntopic  交换机通过路由键绑定队列,根据交换机和路由键发送消息(路由键可进行匹配 #匹配一次或者多次 *匹配一次)\n</code></pre><blockquote>\n<p>需要多个队列接受同样的消息 多个队列绑定同一个路由键 一条消息只能被一个消费者消费</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"不同交换机的Demo\"><a href=\"#不同交换机的Demo\" class=\"headerlink\" title=\"不同交换机的Demo\"></a>不同交换机的Demo</h3><ul>\n<li>添加依赖</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建配置类,初始化的时候指定交换机的类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMqConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建连接</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ConnectionFactory <span class=\"title\">connectionFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CachingConnectionFactory connectionFactory = <span class=\"keyword\">new</span> CachingConnectionFactory();</span><br><span class=\"line\">        connectionFactory.setHost(host);</span><br><span class=\"line\">        connectionFactory.setPort(port);</span><br><span class=\"line\">        connectionFactory.setUsername(username);</span><br><span class=\"line\">        connectionFactory.setPassword(password);</span><br><span class=\"line\">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connectionFactory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 RabbitTemplate</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">rabbitTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建队列 没有的话会创建新的队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"two.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"four.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"three.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directOneQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"four_one.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建三种类型的交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">\"two.exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"four.exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"three.exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 交换机和队列绑定</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueue()).to(fanoutExchange());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue()).to(directExchange()).with(<span class=\"string\">\"four.bind\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directOneBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directOneQueue()).to(directExchange()).with(<span class=\"string\">\"four.bind\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topQueue()).to(topicExchange()).with(<span class=\"string\">\"topicBind\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>消费者部分代码,只需要监听指定队列,获取的消息是根据生产者发送过来的消息(Message/String)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"four.queue\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer2</span><span class=\"params\">(Object msg)</span></span>&#123;</span><br><span class=\"line\">    Message message = (Message) msg;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"2fanoutConsumer 接收消息msg: &#123;&#125;\"</span> , <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"four.queue\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer3</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"3fanoutConsumer 接收消息msg: &#123;&#125;\"</span> , msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生产者部分代码(fanout方式路由键参数不生效),生产者不用考虑队列,投放消息只和交换机和路由键相关</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送Message</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send1/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessage</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"msg1\"</span>);</span><br><span class=\"line\">    Message message = <span class=\"keyword\">new</span> Message(msg.getBytes(),<span class=\"keyword\">new</span> MessageProperties());</span><br><span class=\"line\">    rabbitTemplate.send(<span class=\"string\">\"four.exchange\"</span>,<span class=\"string\">\"aqweq\"</span>,message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 发送String</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessage1</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">   log.info(<span class=\"string\">\"msg2\"</span>);</span><br><span class=\"line\">   amqpTemplate.convertAndSend(<span class=\"string\">\"four.exchange\"</span>,<span class=\"string\">\"four.bind\"</span>,msg);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>AMQP概论</p>\n<h2 id=\"交换器、队列、绑定、路由键\"><a href=\"#交换器、队列、绑定、路由键\" class=\"headerlink\" title=\"交换器、队列、绑定、路由键\"></a>交换器、队列、绑定、路由键</h2><ul>\n<li>rabbitMq流程</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/rabbitmq%E6%B5%81%E7%A8%8B.png\" alt=\"rabbitMq流程\"></p>\n<pre><code>交换机类型:\nfanout 交换机绑定队列,根据交换机发送消息到指定队列\ndirect 交换机通过路由键绑定队列,根据交换机和路由键发送消息\ntopic  交换机通过路由键绑定队列,根据交换机和路由键发送消息(路由键可进行匹配 #匹配一次或者多次 *匹配一次)\n</code></pre><blockquote>\n<p>需要多个队列接受同样的消息 多个队列绑定同一个路由键 一条消息只能被一个消费者消费</p>\n</blockquote>","more":"<h3 id=\"不同交换机的Demo\"><a href=\"#不同交换机的Demo\" class=\"headerlink\" title=\"不同交换机的Demo\"></a>不同交换机的Demo</h3><ul>\n<li>添加依赖</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建配置类,初始化的时候指定交换机的类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMqConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建连接</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ConnectionFactory <span class=\"title\">connectionFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        CachingConnectionFactory connectionFactory = <span class=\"keyword\">new</span> CachingConnectionFactory();</span><br><span class=\"line\">        connectionFactory.setHost(host);</span><br><span class=\"line\">        connectionFactory.setPort(port);</span><br><span class=\"line\">        connectionFactory.setUsername(username);</span><br><span class=\"line\">        connectionFactory.setPassword(password);</span><br><span class=\"line\">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connectionFactory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 RabbitTemplate</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">rabbitTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建队列 没有的话会创建新的队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"two.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"four.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"three.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directOneQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"four_one.queue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建三种类型的交换机</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">\"two.exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"four.exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"three.exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 交换机和队列绑定</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueue()).to(fanoutExchange());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue()).to(directExchange()).with(<span class=\"string\">\"four.bind\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directOneBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directOneQueue()).to(directExchange()).with(<span class=\"string\">\"four.bind\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topQueue()).to(topicExchange()).with(<span class=\"string\">\"topicBind\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>消费者部分代码,只需要监听指定队列,获取的消息是根据生产者发送过来的消息(Message/String)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"four.queue\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer2</span><span class=\"params\">(Object msg)</span></span>&#123;</span><br><span class=\"line\">    Message message = (Message) msg;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"2fanoutConsumer 接收消息msg: &#123;&#125;\"</span> , <span class=\"keyword\">new</span> String(message.getBody()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"four.queue\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer3</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"3fanoutConsumer 接收消息msg: &#123;&#125;\"</span> , msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生产者部分代码(fanout方式路由键参数不生效),生产者不用考虑队列,投放消息只和交换机和路由键相关</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送Message</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send1/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessage</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"msg1\"</span>);</span><br><span class=\"line\">    Message message = <span class=\"keyword\">new</span> Message(msg.getBytes(),<span class=\"keyword\">new</span> MessageProperties());</span><br><span class=\"line\">    rabbitTemplate.send(<span class=\"string\">\"four.exchange\"</span>,<span class=\"string\">\"aqweq\"</span>,message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 发送String</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessage1</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">   log.info(<span class=\"string\">\"msg2\"</span>);</span><br><span class=\"line\">   amqpTemplate.convertAndSend(<span class=\"string\">\"four.exchange\"</span>,<span class=\"string\">\"four.bind\"</span>,msg);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Maven基础 - 打包调用异常","_content":"\nMaven基础学习配置\n\n## Maven 打包遇见的问题\n\n一个项目依赖以另一个项目时引入其依赖,想要调用其依赖的jar包中的类，则打包方式需使用maven的打包方式，不能使用spring-boot的打包方式 可以使用@Component将jar包中的类扫描注入到当前项目的IOC容器中\n\n<!-- more -->\n\n```java\n<build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n        </configuration>\n      </plugin>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n\n而spring项目使用jar包启动时则需要使用spring-boot的打包方式\n```java\n<build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n\n两种方式打包的目录结构：\n\n- maven打包\n\n![maven打包的目录结构](http://tupelo.top/maven.png)\n\n- spring-boot打包\n\n![maven打包的目录结构](http://tupelo.top/spring.jpg)\n\n\n\n\n\n","source":"_posts/maven-01.md","raw":"---\ntitle: Maven基础 - 打包调用异常\ntags:\n  - Maven\n---\n\nMaven基础学习配置\n\n## Maven 打包遇见的问题\n\n一个项目依赖以另一个项目时引入其依赖,想要调用其依赖的jar包中的类，则打包方式需使用maven的打包方式，不能使用spring-boot的打包方式 可以使用@Component将jar包中的类扫描注入到当前项目的IOC容器中\n\n<!-- more -->\n\n```java\n<build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n        </configuration>\n      </plugin>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n\n而spring项目使用jar包启动时则需要使用spring-boot的打包方式\n```java\n<build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n\n两种方式打包的目录结构：\n\n- maven打包\n\n![maven打包的目录结构](http://tupelo.top/maven.png)\n\n- spring-boot打包\n\n![maven打包的目录结构](http://tupelo.top/spring.jpg)\n\n\n\n\n\n","slug":"maven-01","published":1,"date":"2025-02-12T08:28:16.464Z","updated":"2025-02-12T08:28:16.464Z","_id":"clhua15ar001i9gj71512di82","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Maven基础学习配置</p>\n<h2 id=\"Maven-打包遇见的问题\"><a href=\"#Maven-打包遇见的问题\" class=\"headerlink\" title=\"Maven 打包遇见的问题\"></a>Maven 打包遇见的问题</h2><p>一个项目依赖以另一个项目时引入其依赖,想要调用其依赖的jar包中的类，则打包方式需使用maven的打包方式，不能使用spring-boot的打包方式 可以使用@Component将jar包中的类扫描注入到当前项目的IOC容器中</p>\n<a id=\"more\"></a>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.1&lt;/version&gt;</span><br><span class=\"line\">        &lt;configuration&gt;</span><br><span class=\"line\">          &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">          &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">        &lt;/configuration&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure>\n<p>而spring项目使用jar包启动时则需要使用spring-boot的打包方式<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></p>\n<p>两种方式打包的目录结构：</p>\n<ul>\n<li>maven打包</li>\n</ul>\n<p><img src=\"http://tupelo.top/maven.png\" alt=\"maven打包的目录结构\"></p>\n<ul>\n<li>spring-boot打包</li>\n</ul>\n<p><img src=\"http://tupelo.top/spring.jpg\" alt=\"maven打包的目录结构\"></p>\n","site":{"data":{}},"excerpt":"<p>Maven基础学习配置</p>\n<h2 id=\"Maven-打包遇见的问题\"><a href=\"#Maven-打包遇见的问题\" class=\"headerlink\" title=\"Maven 打包遇见的问题\"></a>Maven 打包遇见的问题</h2><p>一个项目依赖以另一个项目时引入其依赖,想要调用其依赖的jar包中的类，则打包方式需使用maven的打包方式，不能使用spring-boot的打包方式 可以使用@Component将jar包中的类扫描注入到当前项目的IOC容器中</p>","more":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.1&lt;/version&gt;</span><br><span class=\"line\">        &lt;configuration&gt;</span><br><span class=\"line\">          &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">          &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">        &lt;/configuration&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure>\n<p>而spring项目使用jar包启动时则需要使用spring-boot的打包方式<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></p>\n<p>两种方式打包的目录结构：</p>\n<ul>\n<li>maven打包</li>\n</ul>\n<p><img src=\"http://tupelo.top/maven.png\" alt=\"maven打包的目录结构\"></p>\n<ul>\n<li>spring-boot打包</li>\n</ul>\n<p><img src=\"http://tupelo.top/spring.jpg\" alt=\"maven打包的目录结构\"></p>"},{"title":"RabbitMq - 生产者消息确认","_content":"\nRabbitMq生产者消息确认\n\n## RabbitMq 生产者消息确认\n\n### 生产者权衡\n> 快、低==========> 慢、高\n\n- 无保障\n- 失败通知  参数mandatory 消息是否成功到达队列\n- 发送方确认模式  消息是否成功到达exchange 和失败通知结合使用\n- 备用交换机     定义个一个备用交换机 Map\n- 高可用队列\n- 事务          影响性能 2-10倍 强一致性\n- 事务+高可用\n- 持久化\n\n<!-- more -->\n\n#### 失败通知 需要开启 PublisherReturns=true mandatory=true\n\n```java\n// 初始化一个rabbitTemplateReturn 用来做失败通知 设置PublisherReturns=true\n@Bean(value = \"rabbitTemplateReturn\")\npublic RabbitTemplate rabbitTemplateReturn() {\n    RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());\n    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherReturns(true);\n    return rabbitTemplate;\n}\n\n// 定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ReturnCallback\n@Component\npublic class RabbitReturnCallback implements RabbitTemplate.ReturnCallback {\n\n    @Autowired\n    @Qualifier(\"rabbitTemplateReturn\")\n    private RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void init(){\n        //指定 ReturnCallback\n        rabbitTemplate.setReturnCallback(this);\n        rabbitTemplate.setMandatory(true);\n    }\n\n    @Override\n    public void returnedMessage(Message message, int i, String s, String s1, String s2) {\n        System.out.println(\"消息主体 message : \"+message);\n        System.out.println(\"消息主体 message : \"+i);\n        System.out.println(\"描述：\"+s);\n        System.out.println(\"消息使用的交换器 exchange : \"+s1);\n        System.out.println(\"消息使用的路由键 routing : \"+s2);\n    }\n}\n\n// 发送方 若没有成功路由 则回调returnedMessage方法\n@RequestMapping(\"/send2/{msg}\")\npublic String sendMessageReturn(@PathVariable(\"msg\") String msg) {\n    log.info(\"msg1\");\n    Message message = new Message(msg.getBytes(),new MessageProperties());\n    rabbitTemplateRerutn.send(\"four.exchange\",\"aqweq\",message);\n    return msg;\n}\n\n```\n\n#### 发送方确认模式 需要开启 PublisherReturns=true mandatory=true\n\n\t确认的三种方式:  \n\tchannel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true  \n\tchannel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException异常  \n\tchannel.addConfirmListener()异步监听发送方确认模式  \n\n```java\n\n// 初始化一个rabbitTemplateConfirm 用来做失败通知 设置PublisherReturns=true\n@Bean(value = \"rabbitTemplateConfirm\")\npublic RabbitTemplate rabbitTemplateConfirm() {\n    RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());\n    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherConfirms(true);\n    return rabbitTemplate;\n}\n\n\n/**\n*\t定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ConfirmCallback\n*\tack 消息是否成功到达exchange 若没有正确路由到队列 ack返回也是true 所以和失败通知结合使用 \n*   这是异步处理的方式\n*/\n@Component\npublic class RabbitConfirmCallback implements RabbitTemplate.ConfirmCallback {\n\n    @Autowired\n    @Qualifier(\"rabbitTemplateConfirm\")\n    private RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void init(){\n        //指定 ConfirmCallback\n        rabbitTemplate.setConfirmCallback(this);\n        rabbitTemplate.setMandatory(true);\n    }\n\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause){\n        System.out.println(\"消息唯一标识：\"+correlationData);\n        System.out.println(\"确认结果：\"+ack);\n        System.out.println(\"失败原因：\"+cause);\n    }\n}\n\n// 发送方 \n@RequestMapping(\"/send3/{msg}\")\npublic String sendMessageConfirm(@PathVariable(\"msg\") String msg) {\n    String msgId = UUID.randomUUID().toString();\n\tCorrelationData date = new CorrelationData(msgId);\n\t// message 可以设置一些头信息 msgId \n\tMessage message = MessageBuilder.withBody(\"测试\".toString().getBytes())\n                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)\n                .setCorrelationId(msgId).build();\n    rabbitTemplateConfirm.send(\"four.exchange1\",\"aqweq\",message,date);\n    return msg;\n}\n\n\n/**\n*  \n*   同步处理方式如下：\n*   发送方\n*   TODO operations.waitForConfirms返回一直是true? 待处理\n*/\n\n@RequestMapping(\"/send4/{msg}\")\npublic String sendMessageOperateConfirm(@PathVariable(\"msg\") String msg) {\n    Message message = new Message(msg.getBytes(),new MessageProperties());\n    rabbitTemplateOperateConfirm.send(\"four.exchange1\",\"aqweq\",message);\n\n    rabbitTemplateOperateConfirm.invoke(new RabbitOperations.OperationsCallback<Object>() {\n        @Override\n        public Object doInRabbit(RabbitOperations operations) {\n//          operations.waitForConfirmsOrDie(100);\n            System.out.println(operations.waitForConfirms(100));\n            return null;\n        }\n    });\n    return msg;\n}\n\n```\n\n> 以上确认可互相配合\n\n- 发送消息前,绑定并保存msgId和message的关系\n- 当confirm或return回调时,根据ack类别等,分别处理. 例如return或者ack=false则说明有问题,报警, 如果ack=true则删除关系(因为return在confirm前,所以一条消息在return后又ack=true的情况也是按return处理)\n- 定时检查这个绑定关系列表,如果发现一些已经超时(自己设定的超时时间)未被处理(即未return和confirm),则手动处理这些消息.\n- 需要注意如果是自动重发的话,消费端需要做幂等或去重处理.\n\n\n\n#### 备用交换机\n\n- 定义一个备用交换机\n- 声明一个map key为\"alternate-exchange\" value为备用交换机的名称\n- 声明主交换机时添加参数map\n- 如果发送消息到主交换机失败则会转发到备用交换机\n\n```java\n\n// 定义备用交换机 一般为fanout类型 路由键一般为#\n@Bean\npublic Queue fanoutBakQueue(){\n    return new Queue(\"four_bak.queue\");\n}\n@Bean\npublic FanoutExchange fanoutBakExchange(){\n    return new FanoutExchange(\"four.exchange_bak\");\n}\n@Bean\npublic Binding fanoutBakBinding(){\n    return BindingBuilder.bind(fanoutBakQueue()).to(fanoutBakExchange());\n}\n\n// 定义主交换机 定义map\n@Bean\npublic DirectExchange directExchange(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    map.put(\"alternate-exchange\",\"four.exchange_bak\");\n    return new DirectExchange(\"four.exchange\",false,false,map);\n}\n\n```\n\n#### 高可用队列\n\n> 集群情况使用\n\n#### 消息持久化\n\n> 可靠性最高\n\n\n#### 事务 事务高可用队列\n\n> 不使用 性能损耗严重\n\n\n\n\n\n\n\n","source":"_posts/rabbitmq-03.md","raw":"---\ntitle: RabbitMq - 生产者消息确认\ntags:\n  - RabbitMq\n---\n\nRabbitMq生产者消息确认\n\n## RabbitMq 生产者消息确认\n\n### 生产者权衡\n> 快、低==========> 慢、高\n\n- 无保障\n- 失败通知  参数mandatory 消息是否成功到达队列\n- 发送方确认模式  消息是否成功到达exchange 和失败通知结合使用\n- 备用交换机     定义个一个备用交换机 Map\n- 高可用队列\n- 事务          影响性能 2-10倍 强一致性\n- 事务+高可用\n- 持久化\n\n<!-- more -->\n\n#### 失败通知 需要开启 PublisherReturns=true mandatory=true\n\n```java\n// 初始化一个rabbitTemplateReturn 用来做失败通知 设置PublisherReturns=true\n@Bean(value = \"rabbitTemplateReturn\")\npublic RabbitTemplate rabbitTemplateReturn() {\n    RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());\n    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherReturns(true);\n    return rabbitTemplate;\n}\n\n// 定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ReturnCallback\n@Component\npublic class RabbitReturnCallback implements RabbitTemplate.ReturnCallback {\n\n    @Autowired\n    @Qualifier(\"rabbitTemplateReturn\")\n    private RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void init(){\n        //指定 ReturnCallback\n        rabbitTemplate.setReturnCallback(this);\n        rabbitTemplate.setMandatory(true);\n    }\n\n    @Override\n    public void returnedMessage(Message message, int i, String s, String s1, String s2) {\n        System.out.println(\"消息主体 message : \"+message);\n        System.out.println(\"消息主体 message : \"+i);\n        System.out.println(\"描述：\"+s);\n        System.out.println(\"消息使用的交换器 exchange : \"+s1);\n        System.out.println(\"消息使用的路由键 routing : \"+s2);\n    }\n}\n\n// 发送方 若没有成功路由 则回调returnedMessage方法\n@RequestMapping(\"/send2/{msg}\")\npublic String sendMessageReturn(@PathVariable(\"msg\") String msg) {\n    log.info(\"msg1\");\n    Message message = new Message(msg.getBytes(),new MessageProperties());\n    rabbitTemplateRerutn.send(\"four.exchange\",\"aqweq\",message);\n    return msg;\n}\n\n```\n\n#### 发送方确认模式 需要开启 PublisherReturns=true mandatory=true\n\n\t确认的三种方式:  \n\tchannel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true  \n\tchannel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException异常  \n\tchannel.addConfirmListener()异步监听发送方确认模式  \n\n```java\n\n// 初始化一个rabbitTemplateConfirm 用来做失败通知 设置PublisherReturns=true\n@Bean(value = \"rabbitTemplateConfirm\")\npublic RabbitTemplate rabbitTemplateConfirm() {\n    RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());\n    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherConfirms(true);\n    return rabbitTemplate;\n}\n\n\n/**\n*\t定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ConfirmCallback\n*\tack 消息是否成功到达exchange 若没有正确路由到队列 ack返回也是true 所以和失败通知结合使用 \n*   这是异步处理的方式\n*/\n@Component\npublic class RabbitConfirmCallback implements RabbitTemplate.ConfirmCallback {\n\n    @Autowired\n    @Qualifier(\"rabbitTemplateConfirm\")\n    private RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void init(){\n        //指定 ConfirmCallback\n        rabbitTemplate.setConfirmCallback(this);\n        rabbitTemplate.setMandatory(true);\n    }\n\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause){\n        System.out.println(\"消息唯一标识：\"+correlationData);\n        System.out.println(\"确认结果：\"+ack);\n        System.out.println(\"失败原因：\"+cause);\n    }\n}\n\n// 发送方 \n@RequestMapping(\"/send3/{msg}\")\npublic String sendMessageConfirm(@PathVariable(\"msg\") String msg) {\n    String msgId = UUID.randomUUID().toString();\n\tCorrelationData date = new CorrelationData(msgId);\n\t// message 可以设置一些头信息 msgId \n\tMessage message = MessageBuilder.withBody(\"测试\".toString().getBytes())\n                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)\n                .setCorrelationId(msgId).build();\n    rabbitTemplateConfirm.send(\"four.exchange1\",\"aqweq\",message,date);\n    return msg;\n}\n\n\n/**\n*  \n*   同步处理方式如下：\n*   发送方\n*   TODO operations.waitForConfirms返回一直是true? 待处理\n*/\n\n@RequestMapping(\"/send4/{msg}\")\npublic String sendMessageOperateConfirm(@PathVariable(\"msg\") String msg) {\n    Message message = new Message(msg.getBytes(),new MessageProperties());\n    rabbitTemplateOperateConfirm.send(\"four.exchange1\",\"aqweq\",message);\n\n    rabbitTemplateOperateConfirm.invoke(new RabbitOperations.OperationsCallback<Object>() {\n        @Override\n        public Object doInRabbit(RabbitOperations operations) {\n//          operations.waitForConfirmsOrDie(100);\n            System.out.println(operations.waitForConfirms(100));\n            return null;\n        }\n    });\n    return msg;\n}\n\n```\n\n> 以上确认可互相配合\n\n- 发送消息前,绑定并保存msgId和message的关系\n- 当confirm或return回调时,根据ack类别等,分别处理. 例如return或者ack=false则说明有问题,报警, 如果ack=true则删除关系(因为return在confirm前,所以一条消息在return后又ack=true的情况也是按return处理)\n- 定时检查这个绑定关系列表,如果发现一些已经超时(自己设定的超时时间)未被处理(即未return和confirm),则手动处理这些消息.\n- 需要注意如果是自动重发的话,消费端需要做幂等或去重处理.\n\n\n\n#### 备用交换机\n\n- 定义一个备用交换机\n- 声明一个map key为\"alternate-exchange\" value为备用交换机的名称\n- 声明主交换机时添加参数map\n- 如果发送消息到主交换机失败则会转发到备用交换机\n\n```java\n\n// 定义备用交换机 一般为fanout类型 路由键一般为#\n@Bean\npublic Queue fanoutBakQueue(){\n    return new Queue(\"four_bak.queue\");\n}\n@Bean\npublic FanoutExchange fanoutBakExchange(){\n    return new FanoutExchange(\"four.exchange_bak\");\n}\n@Bean\npublic Binding fanoutBakBinding(){\n    return BindingBuilder.bind(fanoutBakQueue()).to(fanoutBakExchange());\n}\n\n// 定义主交换机 定义map\n@Bean\npublic DirectExchange directExchange(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    map.put(\"alternate-exchange\",\"four.exchange_bak\");\n    return new DirectExchange(\"four.exchange\",false,false,map);\n}\n\n```\n\n#### 高可用队列\n\n> 集群情况使用\n\n#### 消息持久化\n\n> 可靠性最高\n\n\n#### 事务 事务高可用队列\n\n> 不使用 性能损耗严重\n\n\n\n\n\n\n\n","slug":"rabbitmq-03","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15as001l9gj7zbvq8fmm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMq生产者消息确认</p>\n<h2 id=\"RabbitMq-生产者消息确认\"><a href=\"#RabbitMq-生产者消息确认\" class=\"headerlink\" title=\"RabbitMq 生产者消息确认\"></a>RabbitMq 生产者消息确认</h2><h3 id=\"生产者权衡\"><a href=\"#生产者权衡\" class=\"headerlink\" title=\"生产者权衡\"></a>生产者权衡</h3><blockquote>\n<p>快、低==========&gt; 慢、高</p>\n</blockquote>\n<ul>\n<li>无保障</li>\n<li>失败通知  参数mandatory 消息是否成功到达队列</li>\n<li>发送方确认模式  消息是否成功到达exchange 和失败通知结合使用</li>\n<li>备用交换机     定义个一个备用交换机 Map</li>\n<li>高可用队列</li>\n<li>事务          影响性能 2-10倍 强一致性</li>\n<li>事务+高可用</li>\n<li>持久化</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"失败通知-需要开启-PublisherReturns-true-mandatory-true\"><a href=\"#失败通知-需要开启-PublisherReturns-true-mandatory-true\" class=\"headerlink\" title=\"失败通知 需要开启 PublisherReturns=true mandatory=true\"></a>失败通知 需要开启 PublisherReturns=true mandatory=true</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化一个rabbitTemplateReturn 用来做失败通知 设置PublisherReturns=true</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(value = <span class=\"string\">\"rabbitTemplateReturn\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">rabbitTemplateReturn</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    RabbitTemplate rabbitTemplate = <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory());</span><br><span class=\"line\">    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherReturns(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ReturnCallback</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitReturnCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ReturnCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"rabbitTemplateReturn\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定 ReturnCallback</span></span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"keyword\">int</span> i, String s, String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息主体 message : \"</span>+message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息主体 message : \"</span>+i);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"描述：\"</span>+s);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息使用的交换器 exchange : \"</span>+s1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息使用的路由键 routing : \"</span>+s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送方 若没有成功路由 则回调returnedMessage方法</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send2/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessageReturn</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"msg1\"</span>);</span><br><span class=\"line\">    Message message = <span class=\"keyword\">new</span> Message(msg.getBytes(),<span class=\"keyword\">new</span> MessageProperties());</span><br><span class=\"line\">    rabbitTemplateRerutn.send(<span class=\"string\">\"four.exchange\"</span>,<span class=\"string\">\"aqweq\"</span>,message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送方确认模式-需要开启-PublisherReturns-true-mandatory-true\"><a href=\"#发送方确认模式-需要开启-PublisherReturns-true-mandatory-true\" class=\"headerlink\" title=\"发送方确认模式 需要开启 PublisherReturns=true mandatory=true\"></a>发送方确认模式 需要开启 PublisherReturns=true mandatory=true</h4><pre><code>确认的三种方式:  \nchannel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true  \nchannel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException异常  \nchannel.addConfirmListener()异步监听发送方确认模式  \n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个rabbitTemplateConfirm 用来做失败通知 设置PublisherReturns=true</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(value = <span class=\"string\">\"rabbitTemplateConfirm\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">rabbitTemplateConfirm</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    RabbitTemplate rabbitTemplate = <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory());</span><br><span class=\"line\">    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherConfirms(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*\t定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ConfirmCallback</span></span><br><span class=\"line\"><span class=\"comment\">*\tack 消息是否成功到达exchange 若没有正确路由到队列 ack返回也是true 所以和失败通知结合使用 </span></span><br><span class=\"line\"><span class=\"comment\">*   这是异步处理的方式</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfirmCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"rabbitTemplateConfirm\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定 ConfirmCallback</span></span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息唯一标识：\"</span>+correlationData);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"确认结果：\"</span>+ack);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"失败原因：\"</span>+cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送方 </span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send3/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessageConfirm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    String msgId = UUID.randomUUID().toString();</span><br><span class=\"line\">\tCorrelationData date = <span class=\"keyword\">new</span> CorrelationData(msgId);</span><br><span class=\"line\">\t<span class=\"comment\">// message 可以设置一些头信息 msgId </span></span><br><span class=\"line\">\tMessage message = MessageBuilder.withBody(<span class=\"string\">\"测试\"</span>.toString().getBytes())</span><br><span class=\"line\">                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class=\"line\">                .setCorrelationId(msgId).build();</span><br><span class=\"line\">    rabbitTemplateConfirm.send(<span class=\"string\">\"four.exchange1\"</span>,<span class=\"string\">\"aqweq\"</span>,message,date);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  </span></span><br><span class=\"line\"><span class=\"comment\">*   同步处理方式如下：</span></span><br><span class=\"line\"><span class=\"comment\">*   发送方</span></span><br><span class=\"line\"><span class=\"comment\">*   TODO operations.waitForConfirms返回一直是true? 待处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send4/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessageOperateConfirm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    Message message = <span class=\"keyword\">new</span> Message(msg.getBytes(),<span class=\"keyword\">new</span> MessageProperties());</span><br><span class=\"line\">    rabbitTemplateOperateConfirm.send(<span class=\"string\">\"four.exchange1\"</span>,<span class=\"string\">\"aqweq\"</span>,message);</span><br><span class=\"line\"></span><br><span class=\"line\">    rabbitTemplateOperateConfirm.invoke(<span class=\"keyword\">new</span> RabbitOperations.OperationsCallback&lt;Object&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">doInRabbit</span><span class=\"params\">(RabbitOperations operations)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//          operations.waitForConfirmsOrDie(100);</span></span><br><span class=\"line\">            System.out.println(operations.waitForConfirms(<span class=\"number\">100</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上确认可互相配合</p>\n</blockquote>\n<ul>\n<li>发送消息前,绑定并保存msgId和message的关系</li>\n<li>当confirm或return回调时,根据ack类别等,分别处理. 例如return或者ack=false则说明有问题,报警, 如果ack=true则删除关系(因为return在confirm前,所以一条消息在return后又ack=true的情况也是按return处理)</li>\n<li>定时检查这个绑定关系列表,如果发现一些已经超时(自己设定的超时时间)未被处理(即未return和confirm),则手动处理这些消息.</li>\n<li>需要注意如果是自动重发的话,消费端需要做幂等或去重处理.</li>\n</ul>\n<h4 id=\"备用交换机\"><a href=\"#备用交换机\" class=\"headerlink\" title=\"备用交换机\"></a>备用交换机</h4><ul>\n<li>定义一个备用交换机</li>\n<li>声明一个map key为”alternate-exchange” value为备用交换机的名称</li>\n<li>声明主交换机时添加参数map</li>\n<li>如果发送消息到主交换机失败则会转发到备用交换机</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义备用交换机 一般为fanout类型 路由键一般为#</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutBakQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"four_bak.queue\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutBakExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">\"four.exchange_bak\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBakBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutBakQueue()).to(fanoutBakExchange());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义主交换机 定义map</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String,Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">    map.put(<span class=\"string\">\"alternate-exchange\"</span>,<span class=\"string\">\"four.exchange_bak\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"four.exchange\"</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"高可用队列\"><a href=\"#高可用队列\" class=\"headerlink\" title=\"高可用队列\"></a>高可用队列</h4><blockquote>\n<p>集群情况使用</p>\n</blockquote>\n<h4 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h4><blockquote>\n<p>可靠性最高</p>\n</blockquote>\n<h4 id=\"事务-事务高可用队列\"><a href=\"#事务-事务高可用队列\" class=\"headerlink\" title=\"事务 事务高可用队列\"></a>事务 事务高可用队列</h4><blockquote>\n<p>不使用 性能损耗严重</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>RabbitMq生产者消息确认</p>\n<h2 id=\"RabbitMq-生产者消息确认\"><a href=\"#RabbitMq-生产者消息确认\" class=\"headerlink\" title=\"RabbitMq 生产者消息确认\"></a>RabbitMq 生产者消息确认</h2><h3 id=\"生产者权衡\"><a href=\"#生产者权衡\" class=\"headerlink\" title=\"生产者权衡\"></a>生产者权衡</h3><blockquote>\n<p>快、低==========&gt; 慢、高</p>\n</blockquote>\n<ul>\n<li>无保障</li>\n<li>失败通知  参数mandatory 消息是否成功到达队列</li>\n<li>发送方确认模式  消息是否成功到达exchange 和失败通知结合使用</li>\n<li>备用交换机     定义个一个备用交换机 Map</li>\n<li>高可用队列</li>\n<li>事务          影响性能 2-10倍 强一致性</li>\n<li>事务+高可用</li>\n<li>持久化</li>\n</ul>","more":"<h4 id=\"失败通知-需要开启-PublisherReturns-true-mandatory-true\"><a href=\"#失败通知-需要开启-PublisherReturns-true-mandatory-true\" class=\"headerlink\" title=\"失败通知 需要开启 PublisherReturns=true mandatory=true\"></a>失败通知 需要开启 PublisherReturns=true mandatory=true</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化一个rabbitTemplateReturn 用来做失败通知 设置PublisherReturns=true</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(value = <span class=\"string\">\"rabbitTemplateReturn\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">rabbitTemplateReturn</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    RabbitTemplate rabbitTemplate = <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory());</span><br><span class=\"line\">    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherReturns(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ReturnCallback</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitReturnCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ReturnCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"rabbitTemplateReturn\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定 ReturnCallback</span></span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"keyword\">int</span> i, String s, String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息主体 message : \"</span>+message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息主体 message : \"</span>+i);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"描述：\"</span>+s);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息使用的交换器 exchange : \"</span>+s1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息使用的路由键 routing : \"</span>+s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送方 若没有成功路由 则回调returnedMessage方法</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send2/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessageReturn</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"msg1\"</span>);</span><br><span class=\"line\">    Message message = <span class=\"keyword\">new</span> Message(msg.getBytes(),<span class=\"keyword\">new</span> MessageProperties());</span><br><span class=\"line\">    rabbitTemplateRerutn.send(<span class=\"string\">\"four.exchange\"</span>,<span class=\"string\">\"aqweq\"</span>,message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送方确认模式-需要开启-PublisherReturns-true-mandatory-true\"><a href=\"#发送方确认模式-需要开启-PublisherReturns-true-mandatory-true\" class=\"headerlink\" title=\"发送方确认模式 需要开启 PublisherReturns=true mandatory=true\"></a>发送方确认模式 需要开启 PublisherReturns=true mandatory=true</h4><pre><code>确认的三种方式:  \nchannel.waitForConfirms()普通发送方确认模式；消息到达交换器，就会返回true  \nchannel.waitForConfirmsOrDie()批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未到达交换器就会抛出IOException异常  \nchannel.addConfirmListener()异步监听发送方确认模式  \n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个rabbitTemplateConfirm 用来做失败通知 设置PublisherReturns=true</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(value = <span class=\"string\">\"rabbitTemplateConfirm\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RabbitTemplate <span class=\"title\">rabbitTemplateConfirm</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    RabbitTemplate rabbitTemplate = <span class=\"keyword\">new</span> RabbitTemplate(connectionFactory());</span><br><span class=\"line\">    ((CachingConnectionFactory)rabbitTemplate.getConnectionFactory()).setPublisherConfirms(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*\t定义一个类实现RabbitTemplate.ReturnCallback 并且开启mandatory=true 指定ConfirmCallback</span></span><br><span class=\"line\"><span class=\"comment\">*\tack 消息是否成功到达exchange 若没有正确路由到队列 ack返回也是true 所以和失败通知结合使用 </span></span><br><span class=\"line\"><span class=\"comment\">*   这是异步处理的方式</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfirmCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"rabbitTemplateConfirm\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定 ConfirmCallback</span></span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> ack, String cause)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"消息唯一标识：\"</span>+correlationData);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"确认结果：\"</span>+ack);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"失败原因：\"</span>+cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送方 </span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send3/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessageConfirm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    String msgId = UUID.randomUUID().toString();</span><br><span class=\"line\">\tCorrelationData date = <span class=\"keyword\">new</span> CorrelationData(msgId);</span><br><span class=\"line\">\t<span class=\"comment\">// message 可以设置一些头信息 msgId </span></span><br><span class=\"line\">\tMessage message = MessageBuilder.withBody(<span class=\"string\">\"测试\"</span>.toString().getBytes())</span><br><span class=\"line\">                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class=\"line\">                .setCorrelationId(msgId).build();</span><br><span class=\"line\">    rabbitTemplateConfirm.send(<span class=\"string\">\"four.exchange1\"</span>,<span class=\"string\">\"aqweq\"</span>,message,date);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  </span></span><br><span class=\"line\"><span class=\"comment\">*   同步处理方式如下：</span></span><br><span class=\"line\"><span class=\"comment\">*   发送方</span></span><br><span class=\"line\"><span class=\"comment\">*   TODO operations.waitForConfirms返回一直是true? 待处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/send4/&#123;msg&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendMessageOperateConfirm</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">    Message message = <span class=\"keyword\">new</span> Message(msg.getBytes(),<span class=\"keyword\">new</span> MessageProperties());</span><br><span class=\"line\">    rabbitTemplateOperateConfirm.send(<span class=\"string\">\"four.exchange1\"</span>,<span class=\"string\">\"aqweq\"</span>,message);</span><br><span class=\"line\"></span><br><span class=\"line\">    rabbitTemplateOperateConfirm.invoke(<span class=\"keyword\">new</span> RabbitOperations.OperationsCallback&lt;Object&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">doInRabbit</span><span class=\"params\">(RabbitOperations operations)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//          operations.waitForConfirmsOrDie(100);</span></span><br><span class=\"line\">            System.out.println(operations.waitForConfirms(<span class=\"number\">100</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以上确认可互相配合</p>\n</blockquote>\n<ul>\n<li>发送消息前,绑定并保存msgId和message的关系</li>\n<li>当confirm或return回调时,根据ack类别等,分别处理. 例如return或者ack=false则说明有问题,报警, 如果ack=true则删除关系(因为return在confirm前,所以一条消息在return后又ack=true的情况也是按return处理)</li>\n<li>定时检查这个绑定关系列表,如果发现一些已经超时(自己设定的超时时间)未被处理(即未return和confirm),则手动处理这些消息.</li>\n<li>需要注意如果是自动重发的话,消费端需要做幂等或去重处理.</li>\n</ul>\n<h4 id=\"备用交换机\"><a href=\"#备用交换机\" class=\"headerlink\" title=\"备用交换机\"></a>备用交换机</h4><ul>\n<li>定义一个备用交换机</li>\n<li>声明一个map key为”alternate-exchange” value为备用交换机的名称</li>\n<li>声明主交换机时添加参数map</li>\n<li>如果发送消息到主交换机失败则会转发到备用交换机</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义备用交换机 一般为fanout类型 路由键一般为#</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutBakQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"four_bak.queue\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutBakExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">\"four.exchange_bak\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBakBinding</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutBakQueue()).to(fanoutBakExchange());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义主交换机 定义map</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String,Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">    map.put(<span class=\"string\">\"alternate-exchange\"</span>,<span class=\"string\">\"four.exchange_bak\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"four.exchange\"</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"高可用队列\"><a href=\"#高可用队列\" class=\"headerlink\" title=\"高可用队列\"></a>高可用队列</h4><blockquote>\n<p>集群情况使用</p>\n</blockquote>\n<h4 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h4><blockquote>\n<p>可靠性最高</p>\n</blockquote>\n<h4 id=\"事务-事务高可用队列\"><a href=\"#事务-事务高可用队列\" class=\"headerlink\" title=\"事务 事务高可用队列\"></a>事务 事务高可用队列</h4><blockquote>\n<p>不使用 性能损耗严重</p>\n</blockquote>"},{"title":"RabbitMq - 配置和相关命令","_content":"\nRabbitMq 修改端口/用户权限 相关命令\n\n## RabbitMq 基相关命令\n\n- 配置文件\n\n> RabbitMq配置文件在/etc/rabbitmq下,名为rabbitmq.config / rabbitmq-env.conf,需要自己创建。\n\n\t修改端口:\n\t创建rabbitmq-env.conf文件,添加RABBITMQ_NODE_PORT=8500,重启RabbitMq即可生效.\n\n- 启动和关闭RabbitMq\n\n```bash\nrabbitmq-server #会启动Erlang节点和Rabbitmq应用 \nrabbitmqctl stop #会关闭Erlang节点和Rabbitmq应用 \nrabbitmqctl status  #可以检查消息节点是否正常\n\n#单独关闭RabbitMQ应用\nrabbitmqctl stop_app #关闭Rabbitmq应用 \nrabbitmqctl start_app #启动Rabbitmq应用\n```\n\n<!-- more -->\n\n- 管理虚拟主机\n\n```bash\nrabbitmqctl add_vhost tupelo # 创建vhost\nrabbitmqctl list_vhosts   # 列出所有的vhost\n```\n\n- 用户管理\n\n```bash\nrabbitmqctl add_user tupelo 123456 # 创建用户\nrabbitmqctl  delete_user  Username # 删除用户\nrabbitmqctl  change_password  Username  Newpassword # 修改用户\nrabbitmqctl list_users # 查询所有的用户\n```\n\n- 用户权限管理(guest特殊用户)\n\n> guest是默认用户，具有默认virtual host \"/\"上的全部权限，仅能通过localhost访问RabbitMQ包括Plugin，建议删除或更改密码。可通过将配置文件中loopback_users来取消其本地访问的限制：[{rabbit, [{loopback_users, []}]}] \n\n> 用户仅能对其所能访问的virtual hosts中的资源进行操作。这里的资源指的是virtual hosts中的exchanges、queues等，操作包括对资源进行配置、写、读。配置权限可创建、删除、资源并修改资源的行为，写权限可向资源发送消息，读权限从资源获取消息。比如：  \nexchange和queue的declare与delete分别需要：exchange和queue上的配置权限  \n> queue的bind与unbind需要：queue写权限，exchange的读权限  \n> 发消息(publish)需exchange的写权限  \n> 获取或清除(get、consume、purge)消息需queue的读权限  \n> 对何种资源具有配置、写、读的权限通过正则表达式来匹配，具体命令如下：  \n> rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>  \n\n```bash\n#如用户Mark在虚拟主机logHost上的所有权限： \nrabbitmqctl set_permissions –p logHost Mark  '.*'  '.*'  '.*'\n# 列出用户的权限\nrabbitmqctl  list_user_permissions  User  \n# 清空(某一个vhost)用户的权限\nrabbitmqctl  clear_permissions  [-p VHostPath]  User\n# 查询(某一个vhost)所有用户的权限\nrabbitmqctl  list_permissions  [-p  VHostPath]\n```\n\n\n- 用户角色\n\n```bash\n# 设置用户角色\nrabbitmqctl  set_user_tags  tupelo administrator \n# 设置用户多个角色\nrabbitmqctl  set_user_tags  tupelo  monitoring  policymaker\n```\n\n- 用户角色分类 (none、management、policymaker、monitoring、administrator)\n\n> none、management、policymaker、monitoring、administrator\n\n\t(1) 超级管理员(administrator)\n\t\tpolicymaker和monitoring可以做的任何事加:\n\t\t创建和删除virtual hosts\n\t\t查看、创建和删除users\n\t\t查看创建和删除permissions\n\t\t关闭其他用户的connections\n\n\t(2) 监控者(monitoring)\n\t\tmanagement可以做的任何事加：\n\t\t列出所有virtual hosts，包括他们不能登录的virtual hosts\n\t\t查看其他用户的connections和channels\n\t\t查看节点级别的数据如clustering和memory使用情况\n\t\t查看真正的关于所有virtual hosts的全局的统计信息\n\n\t(3) 策略制定者(policymaker)\n\t\tmanagement可以做的任何事加：\n\t\t查看、创建和删除自己的virtual hosts所属的policies和parameters\n\n\t(4) 普通管理者(management)\n\t\t普通的生产者和消费者加：\n\t\t列出自己可以通过AMQP登入的virtual hosts  \n\t\t查看自己的virtual hosts中的queues, exchanges 和 bindings\n\t\t查看和关闭自己的channels 和 connections\n\t\t查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。\n\n\t(5) 其他(none)\n\t\t不能访问 management plugin，通常就是普通的生产者和消费者\n\n- 其他命令\n\n```bash\nrabbitmqctl list_queues    # 查看所有的队列\nrabbitmqctl list_exchanges # 查看所有的交换机\nrabbitmqctl list_bindings  #查看所有的绑定\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/rabbitmq-02.md","raw":"---\ntitle: RabbitMq - 配置和相关命令\ntags:\n  - RabbitMq\n---\n\nRabbitMq 修改端口/用户权限 相关命令\n\n## RabbitMq 基相关命令\n\n- 配置文件\n\n> RabbitMq配置文件在/etc/rabbitmq下,名为rabbitmq.config / rabbitmq-env.conf,需要自己创建。\n\n\t修改端口:\n\t创建rabbitmq-env.conf文件,添加RABBITMQ_NODE_PORT=8500,重启RabbitMq即可生效.\n\n- 启动和关闭RabbitMq\n\n```bash\nrabbitmq-server #会启动Erlang节点和Rabbitmq应用 \nrabbitmqctl stop #会关闭Erlang节点和Rabbitmq应用 \nrabbitmqctl status  #可以检查消息节点是否正常\n\n#单独关闭RabbitMQ应用\nrabbitmqctl stop_app #关闭Rabbitmq应用 \nrabbitmqctl start_app #启动Rabbitmq应用\n```\n\n<!-- more -->\n\n- 管理虚拟主机\n\n```bash\nrabbitmqctl add_vhost tupelo # 创建vhost\nrabbitmqctl list_vhosts   # 列出所有的vhost\n```\n\n- 用户管理\n\n```bash\nrabbitmqctl add_user tupelo 123456 # 创建用户\nrabbitmqctl  delete_user  Username # 删除用户\nrabbitmqctl  change_password  Username  Newpassword # 修改用户\nrabbitmqctl list_users # 查询所有的用户\n```\n\n- 用户权限管理(guest特殊用户)\n\n> guest是默认用户，具有默认virtual host \"/\"上的全部权限，仅能通过localhost访问RabbitMQ包括Plugin，建议删除或更改密码。可通过将配置文件中loopback_users来取消其本地访问的限制：[{rabbit, [{loopback_users, []}]}] \n\n> 用户仅能对其所能访问的virtual hosts中的资源进行操作。这里的资源指的是virtual hosts中的exchanges、queues等，操作包括对资源进行配置、写、读。配置权限可创建、删除、资源并修改资源的行为，写权限可向资源发送消息，读权限从资源获取消息。比如：  \nexchange和queue的declare与delete分别需要：exchange和queue上的配置权限  \n> queue的bind与unbind需要：queue写权限，exchange的读权限  \n> 发消息(publish)需exchange的写权限  \n> 获取或清除(get、consume、purge)消息需queue的读权限  \n> 对何种资源具有配置、写、读的权限通过正则表达式来匹配，具体命令如下：  \n> rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>  \n\n```bash\n#如用户Mark在虚拟主机logHost上的所有权限： \nrabbitmqctl set_permissions –p logHost Mark  '.*'  '.*'  '.*'\n# 列出用户的权限\nrabbitmqctl  list_user_permissions  User  \n# 清空(某一个vhost)用户的权限\nrabbitmqctl  clear_permissions  [-p VHostPath]  User\n# 查询(某一个vhost)所有用户的权限\nrabbitmqctl  list_permissions  [-p  VHostPath]\n```\n\n\n- 用户角色\n\n```bash\n# 设置用户角色\nrabbitmqctl  set_user_tags  tupelo administrator \n# 设置用户多个角色\nrabbitmqctl  set_user_tags  tupelo  monitoring  policymaker\n```\n\n- 用户角色分类 (none、management、policymaker、monitoring、administrator)\n\n> none、management、policymaker、monitoring、administrator\n\n\t(1) 超级管理员(administrator)\n\t\tpolicymaker和monitoring可以做的任何事加:\n\t\t创建和删除virtual hosts\n\t\t查看、创建和删除users\n\t\t查看创建和删除permissions\n\t\t关闭其他用户的connections\n\n\t(2) 监控者(monitoring)\n\t\tmanagement可以做的任何事加：\n\t\t列出所有virtual hosts，包括他们不能登录的virtual hosts\n\t\t查看其他用户的connections和channels\n\t\t查看节点级别的数据如clustering和memory使用情况\n\t\t查看真正的关于所有virtual hosts的全局的统计信息\n\n\t(3) 策略制定者(policymaker)\n\t\tmanagement可以做的任何事加：\n\t\t查看、创建和删除自己的virtual hosts所属的policies和parameters\n\n\t(4) 普通管理者(management)\n\t\t普通的生产者和消费者加：\n\t\t列出自己可以通过AMQP登入的virtual hosts  \n\t\t查看自己的virtual hosts中的queues, exchanges 和 bindings\n\t\t查看和关闭自己的channels 和 connections\n\t\t查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。\n\n\t(5) 其他(none)\n\t\t不能访问 management plugin，通常就是普通的生产者和消费者\n\n- 其他命令\n\n```bash\nrabbitmqctl list_queues    # 查看所有的队列\nrabbitmqctl list_exchanges # 查看所有的交换机\nrabbitmqctl list_bindings  #查看所有的绑定\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"rabbitmq-02","published":1,"date":"2025-02-12T08:28:16.464Z","updated":"2025-02-12T08:28:16.464Z","_id":"clhua15at001n9gj7ru7fde3u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMq 修改端口/用户权限 相关命令</p>\n<h2 id=\"RabbitMq-基相关命令\"><a href=\"#RabbitMq-基相关命令\" class=\"headerlink\" title=\"RabbitMq 基相关命令\"></a>RabbitMq 基相关命令</h2><ul>\n<li>配置文件</li>\n</ul>\n<blockquote>\n<p>RabbitMq配置文件在/etc/rabbitmq下,名为rabbitmq.config / rabbitmq-env.conf,需要自己创建。</p>\n</blockquote>\n<pre><code>修改端口:\n创建rabbitmq-env.conf文件,添加RABBITMQ_NODE_PORT=8500,重启RabbitMq即可生效.\n</code></pre><ul>\n<li>启动和关闭RabbitMq</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmq-server <span class=\"comment\">#会启动Erlang节点和Rabbitmq应用 </span></span><br><span class=\"line\">rabbitmqctl stop <span class=\"comment\">#会关闭Erlang节点和Rabbitmq应用 </span></span><br><span class=\"line\">rabbitmqctl status  <span class=\"comment\">#可以检查消息节点是否正常</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#单独关闭RabbitMQ应用</span></span><br><span class=\"line\">rabbitmqctl stop_app <span class=\"comment\">#关闭Rabbitmq应用 </span></span><br><span class=\"line\">rabbitmqctl start_app <span class=\"comment\">#启动Rabbitmq应用</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>管理虚拟主机</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl add_vhost tupelo <span class=\"comment\"># 创建vhost</span></span><br><span class=\"line\">rabbitmqctl list_vhosts   <span class=\"comment\"># 列出所有的vhost</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户管理</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl add_user tupelo 123456 <span class=\"comment\"># 创建用户</span></span><br><span class=\"line\">rabbitmqctl  delete_user  Username <span class=\"comment\"># 删除用户</span></span><br><span class=\"line\">rabbitmqctl  change_password  Username  Newpassword <span class=\"comment\"># 修改用户</span></span><br><span class=\"line\">rabbitmqctl list_users <span class=\"comment\"># 查询所有的用户</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户权限管理(guest特殊用户)</li>\n</ul>\n<blockquote>\n<p>guest是默认用户，具有默认virtual host “/“上的全部权限，仅能通过localhost访问RabbitMQ包括Plugin，建议删除或更改密码。可通过将配置文件中loopback_users来取消其本地访问的限制：[{rabbit, [{loopback_users, []}]}] </p>\n</blockquote>\n<blockquote>\n<p>用户仅能对其所能访问的virtual hosts中的资源进行操作。这里的资源指的是virtual hosts中的exchanges、queues等，操作包括对资源进行配置、写、读。配置权限可创建、删除、资源并修改资源的行为，写权限可向资源发送消息，读权限从资源获取消息。比如：<br>exchange和queue的declare与delete分别需要：exchange和queue上的配置权限<br>queue的bind与unbind需要：queue写权限，exchange的读权限<br>发消息(publish)需exchange的写权限<br>获取或清除(get、consume、purge)消息需queue的读权限<br>对何种资源具有配置、写、读的权限通过正则表达式来匹配，具体命令如下：<br>rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>  </read></write></conf></user></vhostpath></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#如用户Mark在虚拟主机logHost上的所有权限： </span></span><br><span class=\"line\">rabbitmqctl set_permissions –p logHost Mark  <span class=\"string\">'.*'</span>  <span class=\"string\">'.*'</span>  <span class=\"string\">'.*'</span></span><br><span class=\"line\"><span class=\"comment\"># 列出用户的权限</span></span><br><span class=\"line\">rabbitmqctl  list_user_permissions  User  </span><br><span class=\"line\"><span class=\"comment\"># 清空(某一个vhost)用户的权限</span></span><br><span class=\"line\">rabbitmqctl  clear_permissions  [-p VHostPath]  User</span><br><span class=\"line\"><span class=\"comment\"># 查询(某一个vhost)所有用户的权限</span></span><br><span class=\"line\">rabbitmqctl  list_permissions  [-p  VHostPath]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户角色</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置用户角色</span></span><br><span class=\"line\">rabbitmqctl  set_user_tags  tupelo administrator </span><br><span class=\"line\"><span class=\"comment\"># 设置用户多个角色</span></span><br><span class=\"line\">rabbitmqctl  set_user_tags  tupelo  monitoring  policymaker</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户角色分类 (none、management、policymaker、monitoring、administrator)</li>\n</ul>\n<blockquote>\n<p>none、management、policymaker、monitoring、administrator</p>\n</blockquote>\n<pre><code>(1) 超级管理员(administrator)\n    policymaker和monitoring可以做的任何事加:\n    创建和删除virtual hosts\n    查看、创建和删除users\n    查看创建和删除permissions\n    关闭其他用户的connections\n\n(2) 监控者(monitoring)\n    management可以做的任何事加：\n    列出所有virtual hosts，包括他们不能登录的virtual hosts\n    查看其他用户的connections和channels\n    查看节点级别的数据如clustering和memory使用情况\n    查看真正的关于所有virtual hosts的全局的统计信息\n\n(3) 策略制定者(policymaker)\n    management可以做的任何事加：\n    查看、创建和删除自己的virtual hosts所属的policies和parameters\n\n(4) 普通管理者(management)\n    普通的生产者和消费者加：\n    列出自己可以通过AMQP登入的virtual hosts  \n    查看自己的virtual hosts中的queues, exchanges 和 bindings\n    查看和关闭自己的channels 和 connections\n    查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。\n\n(5) 其他(none)\n    不能访问 management plugin，通常就是普通的生产者和消费者\n</code></pre><ul>\n<li>其他命令</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl list_queues    <span class=\"comment\"># 查看所有的队列</span></span><br><span class=\"line\">rabbitmqctl list_exchanges <span class=\"comment\"># 查看所有的交换机</span></span><br><span class=\"line\">rabbitmqctl list_bindings  <span class=\"comment\">#查看所有的绑定</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>RabbitMq 修改端口/用户权限 相关命令</p>\n<h2 id=\"RabbitMq-基相关命令\"><a href=\"#RabbitMq-基相关命令\" class=\"headerlink\" title=\"RabbitMq 基相关命令\"></a>RabbitMq 基相关命令</h2><ul>\n<li>配置文件</li>\n</ul>\n<blockquote>\n<p>RabbitMq配置文件在/etc/rabbitmq下,名为rabbitmq.config / rabbitmq-env.conf,需要自己创建。</p>\n</blockquote>\n<pre><code>修改端口:\n创建rabbitmq-env.conf文件,添加RABBITMQ_NODE_PORT=8500,重启RabbitMq即可生效.\n</code></pre><ul>\n<li>启动和关闭RabbitMq</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmq-server <span class=\"comment\">#会启动Erlang节点和Rabbitmq应用 </span></span><br><span class=\"line\">rabbitmqctl stop <span class=\"comment\">#会关闭Erlang节点和Rabbitmq应用 </span></span><br><span class=\"line\">rabbitmqctl status  <span class=\"comment\">#可以检查消息节点是否正常</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#单独关闭RabbitMQ应用</span></span><br><span class=\"line\">rabbitmqctl stop_app <span class=\"comment\">#关闭Rabbitmq应用 </span></span><br><span class=\"line\">rabbitmqctl start_app <span class=\"comment\">#启动Rabbitmq应用</span></span><br></pre></td></tr></table></figure>","more":"<ul>\n<li>管理虚拟主机</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl add_vhost tupelo <span class=\"comment\"># 创建vhost</span></span><br><span class=\"line\">rabbitmqctl list_vhosts   <span class=\"comment\"># 列出所有的vhost</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户管理</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl add_user tupelo 123456 <span class=\"comment\"># 创建用户</span></span><br><span class=\"line\">rabbitmqctl  delete_user  Username <span class=\"comment\"># 删除用户</span></span><br><span class=\"line\">rabbitmqctl  change_password  Username  Newpassword <span class=\"comment\"># 修改用户</span></span><br><span class=\"line\">rabbitmqctl list_users <span class=\"comment\"># 查询所有的用户</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户权限管理(guest特殊用户)</li>\n</ul>\n<blockquote>\n<p>guest是默认用户，具有默认virtual host “/“上的全部权限，仅能通过localhost访问RabbitMQ包括Plugin，建议删除或更改密码。可通过将配置文件中loopback_users来取消其本地访问的限制：[{rabbit, [{loopback_users, []}]}] </p>\n</blockquote>\n<blockquote>\n<p>用户仅能对其所能访问的virtual hosts中的资源进行操作。这里的资源指的是virtual hosts中的exchanges、queues等，操作包括对资源进行配置、写、读。配置权限可创建、删除、资源并修改资源的行为，写权限可向资源发送消息，读权限从资源获取消息。比如：<br>exchange和queue的declare与delete分别需要：exchange和queue上的配置权限<br>queue的bind与unbind需要：queue写权限，exchange的读权限<br>发消息(publish)需exchange的写权限<br>获取或清除(get、consume、purge)消息需queue的读权限<br>对何种资源具有配置、写、读的权限通过正则表达式来匹配，具体命令如下：<br>rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>  </read></write></conf></user></vhostpath></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#如用户Mark在虚拟主机logHost上的所有权限： </span></span><br><span class=\"line\">rabbitmqctl set_permissions –p logHost Mark  <span class=\"string\">'.*'</span>  <span class=\"string\">'.*'</span>  <span class=\"string\">'.*'</span></span><br><span class=\"line\"><span class=\"comment\"># 列出用户的权限</span></span><br><span class=\"line\">rabbitmqctl  list_user_permissions  User  </span><br><span class=\"line\"><span class=\"comment\"># 清空(某一个vhost)用户的权限</span></span><br><span class=\"line\">rabbitmqctl  clear_permissions  [-p VHostPath]  User</span><br><span class=\"line\"><span class=\"comment\"># 查询(某一个vhost)所有用户的权限</span></span><br><span class=\"line\">rabbitmqctl  list_permissions  [-p  VHostPath]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户角色</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置用户角色</span></span><br><span class=\"line\">rabbitmqctl  set_user_tags  tupelo administrator </span><br><span class=\"line\"><span class=\"comment\"># 设置用户多个角色</span></span><br><span class=\"line\">rabbitmqctl  set_user_tags  tupelo  monitoring  policymaker</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用户角色分类 (none、management、policymaker、monitoring、administrator)</li>\n</ul>\n<blockquote>\n<p>none、management、policymaker、monitoring、administrator</p>\n</blockquote>\n<pre><code>(1) 超级管理员(administrator)\n    policymaker和monitoring可以做的任何事加:\n    创建和删除virtual hosts\n    查看、创建和删除users\n    查看创建和删除permissions\n    关闭其他用户的connections\n\n(2) 监控者(monitoring)\n    management可以做的任何事加：\n    列出所有virtual hosts，包括他们不能登录的virtual hosts\n    查看其他用户的connections和channels\n    查看节点级别的数据如clustering和memory使用情况\n    查看真正的关于所有virtual hosts的全局的统计信息\n\n(3) 策略制定者(policymaker)\n    management可以做的任何事加：\n    查看、创建和删除自己的virtual hosts所属的policies和parameters\n\n(4) 普通管理者(management)\n    普通的生产者和消费者加：\n    列出自己可以通过AMQP登入的virtual hosts  \n    查看自己的virtual hosts中的queues, exchanges 和 bindings\n    查看和关闭自己的channels 和 connections\n    查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。\n\n(5) 其他(none)\n    不能访问 management plugin，通常就是普通的生产者和消费者\n</code></pre><ul>\n<li>其他命令</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl list_queues    <span class=\"comment\"># 查看所有的队列</span></span><br><span class=\"line\">rabbitmqctl list_exchanges <span class=\"comment\"># 查看所有的交换机</span></span><br><span class=\"line\">rabbitmqctl list_bindings  <span class=\"comment\">#查看所有的绑定</span></span><br></pre></td></tr></table></figure>"},{"title":"RabbitMq - 消费者消息确认","_content":"\nRabbitMq消费者消息确认\n\n## RabbitMq 消费者消息确认\n\n### 消费者权衡\n\n- 获取消息方式\n    - 拉取get\n    - 自动推送\n- 消息应答方式\n    - 自动确认\n    - 手动确认\n- Qos预取模式\n- 可靠性\n    - Qos 批量2500事务(高)\n    - 拉取事务(低)\n- 性能 \n    - 总量2500Qos(高)\n    - 少量Qos 批量2500事务\n    - 事务\n    - 拉取(低)\n\n<!-- more -->\n\n\n#### 获取消息方式\n\n##### 拉取get\n\n> channel.basicGet(String queueName, boolean autoAck) 效率低不常用\n\n##### 自动推送\n\n> springBoot监听队列注解:@RabbitListener(queues = \"queueName\"),处理方法注解:@RabbitHandler,默认是自动确认。(注解情况下手动确认?)\n\n#### 消息应答方式、Qos模式、批量确认、单条确认\n\n```java\n\n@Bean\npublic SimpleMessageListenerContainer messageListenerContainer(){\n    SimpleMessageListenerContainer messageListenerContainer = new SimpleMessageListenerContainer(connectionFactory());\n    // 开启Qos\n    //messageListenerContainer.setPrefetchCount(2500);\n    messageListenerContainer.setQueues(topicQueueBak());\n    // 开启手动确认 MANUAL  \n    messageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL);\n    messageListenerContainer.setMessageListener(firstConsumer);\n    return messageListenerContainer;\n}\n\n// 实现手动确认 实现ChannelAwareMessageListener接口，basicAck方法为成功确认\n\n@Component\npublic class FirstConsumer implements ChannelAwareMessageListener {\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        try {\n            String msg = new String(message.getBody());\n            System.out.println(\"ack>>>>>>>接收到消息:\"+msg);\n            try {\n                channel.basicAck(message.getMessageProperties().getDeliveryTag(),\n                        false);\n                System.out.println(\"ack>>>>>>消息已消费\");\n            } catch (Exception e) {\n                // 第一false 是否批量拒绝 第二个是否重新放入队列\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(),\n                        false,false);\n                System.out.println(\"UserReceiver>>>>>>拒绝消息，要求Mq重新派发\");\n                throw e;\n            }\n\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```\n\n#### 消息的拒绝\n\n> Nack 可以批量拒绝 第一false是否批量拒绝 第二个是否重新放入队列 重新放入队列容易产生死循环  \n\n    channel.basicNack(message.getMessageProperties().getDeliveryTag(),\n                        false,false);\n\n> Reject 单条拒绝  \n\n    channel.basicReject(message.getMessageProperties().getDeliveryTag(),false);\n\n#### 死信交换器DLX(消息生产者的备用交换器类似)\n\n> 将拒绝的消息可以投放至自定义的队列处理,重新定义一个队列绑定主交换机,设置参数\"x-dead-letter-exchange\",也可以添加死信路由\"x-dead-letter-routing-key\",这样不同业务拒绝的消息可以投递至不同的队列。\n\n```java\n\n// 死信交换器\n@Bean\npublic Queue topicQueueDlxBak(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    // 死信交换器\n    map.put(\"x-dead-letter-exchange\",\"dlx.exchange\");\n    return new Queue(\"dlx.queue\",false,false,false,map);\n}\n@Bean\npublic TopicExchange topicExchangeDlxBak(){\n    return new TopicExchange(\"dlx.exchange\");\n}\n@Bean\npublic Binding topicBindingDlxBak(){\n    return BindingBuilder.bind(topicQueueDlxBak()).to(topicExchangeBak()).with(\"#\");\n}\n\n// 死信交换器 + 死信路由\n@Bean\npublic Queue topicQueueDlxKeyBak(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    map.put(\"x-dead-letter-exchange\",\"dlx.key.exchange\");\n    map.put(\"x-dead-letter-routing-key\",\"dlx.key.bind\");\n    return new Queue(\"dlx.key.queue\",false,false,false,map);\n}\n@Bean\npublic TopicExchange topicExchangeDlxKeyBak(){\n    return new TopicExchange(\"dlx.key.exchange\");\n}\n@Bean\npublic Binding topicBindingDlxKeyBak(){\n    return BindingBuilder.bind(topicQueueDlxKeyBak()).to(topicExchangeBak()).with(\"dlx.key.bind\");\n}\n```\n\n\n\n","source":"_posts/rabbitmq-04.md","raw":"---\ntitle: RabbitMq - 消费者消息确认\ntags:\n  - RabbitMq\n---\n\nRabbitMq消费者消息确认\n\n## RabbitMq 消费者消息确认\n\n### 消费者权衡\n\n- 获取消息方式\n    - 拉取get\n    - 自动推送\n- 消息应答方式\n    - 自动确认\n    - 手动确认\n- Qos预取模式\n- 可靠性\n    - Qos 批量2500事务(高)\n    - 拉取事务(低)\n- 性能 \n    - 总量2500Qos(高)\n    - 少量Qos 批量2500事务\n    - 事务\n    - 拉取(低)\n\n<!-- more -->\n\n\n#### 获取消息方式\n\n##### 拉取get\n\n> channel.basicGet(String queueName, boolean autoAck) 效率低不常用\n\n##### 自动推送\n\n> springBoot监听队列注解:@RabbitListener(queues = \"queueName\"),处理方法注解:@RabbitHandler,默认是自动确认。(注解情况下手动确认?)\n\n#### 消息应答方式、Qos模式、批量确认、单条确认\n\n```java\n\n@Bean\npublic SimpleMessageListenerContainer messageListenerContainer(){\n    SimpleMessageListenerContainer messageListenerContainer = new SimpleMessageListenerContainer(connectionFactory());\n    // 开启Qos\n    //messageListenerContainer.setPrefetchCount(2500);\n    messageListenerContainer.setQueues(topicQueueBak());\n    // 开启手动确认 MANUAL  \n    messageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL);\n    messageListenerContainer.setMessageListener(firstConsumer);\n    return messageListenerContainer;\n}\n\n// 实现手动确认 实现ChannelAwareMessageListener接口，basicAck方法为成功确认\n\n@Component\npublic class FirstConsumer implements ChannelAwareMessageListener {\n    @Override\n    public void onMessage(Message message, Channel channel) throws Exception {\n        try {\n            String msg = new String(message.getBody());\n            System.out.println(\"ack>>>>>>>接收到消息:\"+msg);\n            try {\n                channel.basicAck(message.getMessageProperties().getDeliveryTag(),\n                        false);\n                System.out.println(\"ack>>>>>>消息已消费\");\n            } catch (Exception e) {\n                // 第一false 是否批量拒绝 第二个是否重新放入队列\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(),\n                        false,false);\n                System.out.println(\"UserReceiver>>>>>>拒绝消息，要求Mq重新派发\");\n                throw e;\n            }\n\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```\n\n#### 消息的拒绝\n\n> Nack 可以批量拒绝 第一false是否批量拒绝 第二个是否重新放入队列 重新放入队列容易产生死循环  \n\n    channel.basicNack(message.getMessageProperties().getDeliveryTag(),\n                        false,false);\n\n> Reject 单条拒绝  \n\n    channel.basicReject(message.getMessageProperties().getDeliveryTag(),false);\n\n#### 死信交换器DLX(消息生产者的备用交换器类似)\n\n> 将拒绝的消息可以投放至自定义的队列处理,重新定义一个队列绑定主交换机,设置参数\"x-dead-letter-exchange\",也可以添加死信路由\"x-dead-letter-routing-key\",这样不同业务拒绝的消息可以投递至不同的队列。\n\n```java\n\n// 死信交换器\n@Bean\npublic Queue topicQueueDlxBak(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    // 死信交换器\n    map.put(\"x-dead-letter-exchange\",\"dlx.exchange\");\n    return new Queue(\"dlx.queue\",false,false,false,map);\n}\n@Bean\npublic TopicExchange topicExchangeDlxBak(){\n    return new TopicExchange(\"dlx.exchange\");\n}\n@Bean\npublic Binding topicBindingDlxBak(){\n    return BindingBuilder.bind(topicQueueDlxBak()).to(topicExchangeBak()).with(\"#\");\n}\n\n// 死信交换器 + 死信路由\n@Bean\npublic Queue topicQueueDlxKeyBak(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    map.put(\"x-dead-letter-exchange\",\"dlx.key.exchange\");\n    map.put(\"x-dead-letter-routing-key\",\"dlx.key.bind\");\n    return new Queue(\"dlx.key.queue\",false,false,false,map);\n}\n@Bean\npublic TopicExchange topicExchangeDlxKeyBak(){\n    return new TopicExchange(\"dlx.key.exchange\");\n}\n@Bean\npublic Binding topicBindingDlxKeyBak(){\n    return BindingBuilder.bind(topicQueueDlxKeyBak()).to(topicExchangeBak()).with(\"dlx.key.bind\");\n}\n```\n\n\n\n","slug":"rabbitmq-04","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15au001p9gj70qoxuarv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMq消费者消息确认</p>\n<h2 id=\"RabbitMq-消费者消息确认\"><a href=\"#RabbitMq-消费者消息确认\" class=\"headerlink\" title=\"RabbitMq 消费者消息确认\"></a>RabbitMq 消费者消息确认</h2><h3 id=\"消费者权衡\"><a href=\"#消费者权衡\" class=\"headerlink\" title=\"消费者权衡\"></a>消费者权衡</h3><ul>\n<li>获取消息方式<ul>\n<li>拉取get</li>\n<li>自动推送</li>\n</ul>\n</li>\n<li>消息应答方式<ul>\n<li>自动确认</li>\n<li>手动确认</li>\n</ul>\n</li>\n<li>Qos预取模式</li>\n<li>可靠性<ul>\n<li>Qos 批量2500事务(高)</li>\n<li>拉取事务(低)</li>\n</ul>\n</li>\n<li>性能 <ul>\n<li>总量2500Qos(高)</li>\n<li>少量Qos 批量2500事务</li>\n<li>事务</li>\n<li>拉取(低)</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"获取消息方式\"><a href=\"#获取消息方式\" class=\"headerlink\" title=\"获取消息方式\"></a>获取消息方式</h4><h5 id=\"拉取get\"><a href=\"#拉取get\" class=\"headerlink\" title=\"拉取get\"></a>拉取get</h5><blockquote>\n<p>channel.basicGet(String queueName, boolean autoAck) 效率低不常用</p>\n</blockquote>\n<h5 id=\"自动推送\"><a href=\"#自动推送\" class=\"headerlink\" title=\"自动推送\"></a>自动推送</h5><blockquote>\n<p>springBoot监听队列注解:@RabbitListener(queues = “queueName”),处理方法注解:@RabbitHandler,默认是自动确认。(注解情况下手动确认?)</p>\n</blockquote>\n<h4 id=\"消息应答方式、Qos模式、批量确认、单条确认\"><a href=\"#消息应答方式、Qos模式、批量确认、单条确认\" class=\"headerlink\" title=\"消息应答方式、Qos模式、批量确认、单条确认\"></a>消息应答方式、Qos模式、批量确认、单条确认</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SimpleMessageListenerContainer <span class=\"title\">messageListenerContainer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    SimpleMessageListenerContainer messageListenerContainer = <span class=\"keyword\">new</span> SimpleMessageListenerContainer(connectionFactory());</span><br><span class=\"line\">    <span class=\"comment\">// 开启Qos</span></span><br><span class=\"line\">    <span class=\"comment\">//messageListenerContainer.setPrefetchCount(2500);</span></span><br><span class=\"line\">    messageListenerContainer.setQueues(topicQueueBak());</span><br><span class=\"line\">    <span class=\"comment\">// 开启手动确认 MANUAL  </span></span><br><span class=\"line\">    messageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class=\"line\">    messageListenerContainer.setMessageListener(firstConsumer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> messageListenerContainer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现手动确认 实现ChannelAwareMessageListener接口，basicAck方法为成功确认</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstConsumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"ack&gt;&gt;&gt;&gt;&gt;&gt;&gt;接收到消息:\"</span>+msg);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                channel.basicAck(message.getMessageProperties().getDeliveryTag(),</span><br><span class=\"line\">                        <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"ack&gt;&gt;&gt;&gt;&gt;&gt;消息已消费\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一false 是否批量拒绝 第二个是否重新放入队列</span></span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(),</span><br><span class=\"line\">                        <span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"UserReceiver&gt;&gt;&gt;&gt;&gt;&gt;拒绝消息，要求Mq重新派发\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息的拒绝\"><a href=\"#消息的拒绝\" class=\"headerlink\" title=\"消息的拒绝\"></a>消息的拒绝</h4><blockquote>\n<p>Nack 可以批量拒绝 第一false是否批量拒绝 第二个是否重新放入队列 重新放入队列容易产生死循环  </p>\n</blockquote>\n<pre><code>channel.basicNack(message.getMessageProperties().getDeliveryTag(),\n                    false,false);\n</code></pre><blockquote>\n<p>Reject 单条拒绝  </p>\n</blockquote>\n<pre><code>channel.basicReject(message.getMessageProperties().getDeliveryTag(),false);\n</code></pre><h4 id=\"死信交换器DLX-消息生产者的备用交换器类似\"><a href=\"#死信交换器DLX-消息生产者的备用交换器类似\" class=\"headerlink\" title=\"死信交换器DLX(消息生产者的备用交换器类似)\"></a>死信交换器DLX(消息生产者的备用交换器类似)</h4><blockquote>\n<p>将拒绝的消息可以投放至自定义的队列处理,重新定义一个队列绑定主交换机,设置参数”x-dead-letter-exchange”,也可以添加死信路由”x-dead-letter-routing-key”,这样不同业务拒绝的消息可以投递至不同的队列。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 死信交换器</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueDlxBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String,Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 死信交换器</span></span><br><span class=\"line\">    map.put(<span class=\"string\">\"x-dead-letter-exchange\"</span>,<span class=\"string\">\"dlx.exchange\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"dlx.queue\"</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchangeDlxBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"dlx.exchange\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBindingDlxBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueueDlxBak()).to(topicExchangeBak()).with(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 死信交换器 + 死信路由</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueDlxKeyBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String,Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">    map.put(<span class=\"string\">\"x-dead-letter-exchange\"</span>,<span class=\"string\">\"dlx.key.exchange\"</span>);</span><br><span class=\"line\">    map.put(<span class=\"string\">\"x-dead-letter-routing-key\"</span>,<span class=\"string\">\"dlx.key.bind\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"dlx.key.queue\"</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchangeDlxKeyBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"dlx.key.exchange\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBindingDlxKeyBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueueDlxKeyBak()).to(topicExchangeBak()).with(<span class=\"string\">\"dlx.key.bind\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>RabbitMq消费者消息确认</p>\n<h2 id=\"RabbitMq-消费者消息确认\"><a href=\"#RabbitMq-消费者消息确认\" class=\"headerlink\" title=\"RabbitMq 消费者消息确认\"></a>RabbitMq 消费者消息确认</h2><h3 id=\"消费者权衡\"><a href=\"#消费者权衡\" class=\"headerlink\" title=\"消费者权衡\"></a>消费者权衡</h3><ul>\n<li>获取消息方式<ul>\n<li>拉取get</li>\n<li>自动推送</li>\n</ul>\n</li>\n<li>消息应答方式<ul>\n<li>自动确认</li>\n<li>手动确认</li>\n</ul>\n</li>\n<li>Qos预取模式</li>\n<li>可靠性<ul>\n<li>Qos 批量2500事务(高)</li>\n<li>拉取事务(低)</li>\n</ul>\n</li>\n<li>性能 <ul>\n<li>总量2500Qos(高)</li>\n<li>少量Qos 批量2500事务</li>\n<li>事务</li>\n<li>拉取(低)</li>\n</ul>\n</li>\n</ul>","more":"<h4 id=\"获取消息方式\"><a href=\"#获取消息方式\" class=\"headerlink\" title=\"获取消息方式\"></a>获取消息方式</h4><h5 id=\"拉取get\"><a href=\"#拉取get\" class=\"headerlink\" title=\"拉取get\"></a>拉取get</h5><blockquote>\n<p>channel.basicGet(String queueName, boolean autoAck) 效率低不常用</p>\n</blockquote>\n<h5 id=\"自动推送\"><a href=\"#自动推送\" class=\"headerlink\" title=\"自动推送\"></a>自动推送</h5><blockquote>\n<p>springBoot监听队列注解:@RabbitListener(queues = “queueName”),处理方法注解:@RabbitHandler,默认是自动确认。(注解情况下手动确认?)</p>\n</blockquote>\n<h4 id=\"消息应答方式、Qos模式、批量确认、单条确认\"><a href=\"#消息应答方式、Qos模式、批量确认、单条确认\" class=\"headerlink\" title=\"消息应答方式、Qos模式、批量确认、单条确认\"></a>消息应答方式、Qos模式、批量确认、单条确认</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SimpleMessageListenerContainer <span class=\"title\">messageListenerContainer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    SimpleMessageListenerContainer messageListenerContainer = <span class=\"keyword\">new</span> SimpleMessageListenerContainer(connectionFactory());</span><br><span class=\"line\">    <span class=\"comment\">// 开启Qos</span></span><br><span class=\"line\">    <span class=\"comment\">//messageListenerContainer.setPrefetchCount(2500);</span></span><br><span class=\"line\">    messageListenerContainer.setQueues(topicQueueBak());</span><br><span class=\"line\">    <span class=\"comment\">// 开启手动确认 MANUAL  </span></span><br><span class=\"line\">    messageListenerContainer.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class=\"line\">    messageListenerContainer.setMessageListener(firstConsumer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> messageListenerContainer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现手动确认 实现ChannelAwareMessageListener接口，basicAck方法为成功确认</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstConsumer</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessage</span><span class=\"params\">(Message message, Channel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String msg = <span class=\"keyword\">new</span> String(message.getBody());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"ack&gt;&gt;&gt;&gt;&gt;&gt;&gt;接收到消息:\"</span>+msg);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                channel.basicAck(message.getMessageProperties().getDeliveryTag(),</span><br><span class=\"line\">                        <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"ack&gt;&gt;&gt;&gt;&gt;&gt;消息已消费\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一false 是否批量拒绝 第二个是否重新放入队列</span></span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(),</span><br><span class=\"line\">                        <span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"UserReceiver&gt;&gt;&gt;&gt;&gt;&gt;拒绝消息，要求Mq重新派发\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息的拒绝\"><a href=\"#消息的拒绝\" class=\"headerlink\" title=\"消息的拒绝\"></a>消息的拒绝</h4><blockquote>\n<p>Nack 可以批量拒绝 第一false是否批量拒绝 第二个是否重新放入队列 重新放入队列容易产生死循环  </p>\n</blockquote>\n<pre><code>channel.basicNack(message.getMessageProperties().getDeliveryTag(),\n                    false,false);\n</code></pre><blockquote>\n<p>Reject 单条拒绝  </p>\n</blockquote>\n<pre><code>channel.basicReject(message.getMessageProperties().getDeliveryTag(),false);\n</code></pre><h4 id=\"死信交换器DLX-消息生产者的备用交换器类似\"><a href=\"#死信交换器DLX-消息生产者的备用交换器类似\" class=\"headerlink\" title=\"死信交换器DLX(消息生产者的备用交换器类似)\"></a>死信交换器DLX(消息生产者的备用交换器类似)</h4><blockquote>\n<p>将拒绝的消息可以投放至自定义的队列处理,重新定义一个队列绑定主交换机,设置参数”x-dead-letter-exchange”,也可以添加死信路由”x-dead-letter-routing-key”,这样不同业务拒绝的消息可以投递至不同的队列。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 死信交换器</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueDlxBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String,Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 死信交换器</span></span><br><span class=\"line\">    map.put(<span class=\"string\">\"x-dead-letter-exchange\"</span>,<span class=\"string\">\"dlx.exchange\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"dlx.queue\"</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchangeDlxBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"dlx.exchange\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBindingDlxBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueueDlxBak()).to(topicExchangeBak()).with(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 死信交换器 + 死信路由</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueDlxKeyBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String,Object&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">    map.put(<span class=\"string\">\"x-dead-letter-exchange\"</span>,<span class=\"string\">\"dlx.key.exchange\"</span>);</span><br><span class=\"line\">    map.put(<span class=\"string\">\"x-dead-letter-routing-key\"</span>,<span class=\"string\">\"dlx.key.bind\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"dlx.key.queue\"</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchangeDlxKeyBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"dlx.key.exchange\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBindingDlxKeyBak</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueueDlxKeyBak()).to(topicExchangeBak()).with(<span class=\"string\">\"dlx.key.bind\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RabbitMq - 定义队列,消息的其它属性(定义时最后的一个Map)","_content":"\nRabbitMq其它属性(定义时最后的一个Map)\n\n## RabbitMq 其它属性(定义时最后的一个Map)\n\n#### 队列\n\n![队列](http://image.tupelo.top/queue.png)\n\n<!-- more -->\n\n```\n@Bean\npublic Queue topicQueueDlxKeyBak(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    // 定义属性 ..\n    map.put(\"x-dead-letter-exchange\",\"dlx.key.exchange\");\n    map.put(\"x-dead-letter-routing-key\",\"dlx.key.bind\");\n    return new Queue(\"dlx.key.queue\",false,false,false,map);\n}\n```\n\n#### 消息\n\n![消息](http://image.tupelo.top/rabbitMessage.png)\n\n\n```\n// 设置消息属性\nMessage message = MessageBuilder.withBody(\"测试\".toString().getBytes())\n                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)\n                .setCorrelationId(msgId).build();\nrabbitTemplateConfirm.send(\"exchange\",\"routing\",message);\n```\n\n\n\n\n\n\n","source":"_posts/rabbitmq-05.md","raw":"---\ntitle: RabbitMq - 定义队列,消息的其它属性(定义时最后的一个Map)\ntags:\n  - RabbitMq\n---\n\nRabbitMq其它属性(定义时最后的一个Map)\n\n## RabbitMq 其它属性(定义时最后的一个Map)\n\n#### 队列\n\n![队列](http://image.tupelo.top/queue.png)\n\n<!-- more -->\n\n```\n@Bean\npublic Queue topicQueueDlxKeyBak(){\n    Map<String,Object> map = new HashMap<String,Object>(16);\n    // 定义属性 ..\n    map.put(\"x-dead-letter-exchange\",\"dlx.key.exchange\");\n    map.put(\"x-dead-letter-routing-key\",\"dlx.key.bind\");\n    return new Queue(\"dlx.key.queue\",false,false,false,map);\n}\n```\n\n#### 消息\n\n![消息](http://image.tupelo.top/rabbitMessage.png)\n\n\n```\n// 设置消息属性\nMessage message = MessageBuilder.withBody(\"测试\".toString().getBytes())\n                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)\n                .setCorrelationId(msgId).build();\nrabbitTemplateConfirm.send(\"exchange\",\"routing\",message);\n```\n\n\n\n\n\n\n","slug":"rabbitmq-05","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15av001r9gj7zcyzi49u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMq其它属性(定义时最后的一个Map)</p>\n<h2 id=\"RabbitMq-其它属性-定义时最后的一个Map\"><a href=\"#RabbitMq-其它属性-定义时最后的一个Map\" class=\"headerlink\" title=\"RabbitMq 其它属性(定义时最后的一个Map)\"></a>RabbitMq 其它属性(定义时最后的一个Map)</h2><h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p><img src=\"http://image.tupelo.top/queue.png\" alt=\"队列\"></p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public Queue topicQueueDlxKeyBak()&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(16);</span><br><span class=\"line\">    // 定义属性 ..</span><br><span class=\"line\">    map.put(&quot;x-dead-letter-exchange&quot;,&quot;dlx.key.exchange&quot;);</span><br><span class=\"line\">    map.put(&quot;x-dead-letter-routing-key&quot;,&quot;dlx.key.bind&quot;);</span><br><span class=\"line\">    return new Queue(&quot;dlx.key.queue&quot;,false,false,false,map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h4><p><img src=\"http://image.tupelo.top/rabbitMessage.png\" alt=\"消息\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置消息属性</span><br><span class=\"line\">Message message = MessageBuilder.withBody(&quot;测试&quot;.toString().getBytes())</span><br><span class=\"line\">                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class=\"line\">                .setCorrelationId(msgId).build();</span><br><span class=\"line\">rabbitTemplateConfirm.send(&quot;exchange&quot;,&quot;routing&quot;,message);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>RabbitMq其它属性(定义时最后的一个Map)</p>\n<h2 id=\"RabbitMq-其它属性-定义时最后的一个Map\"><a href=\"#RabbitMq-其它属性-定义时最后的一个Map\" class=\"headerlink\" title=\"RabbitMq 其它属性(定义时最后的一个Map)\"></a>RabbitMq 其它属性(定义时最后的一个Map)</h2><h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><p><img src=\"http://image.tupelo.top/queue.png\" alt=\"队列\"></p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public Queue topicQueueDlxKeyBak()&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(16);</span><br><span class=\"line\">    // 定义属性 ..</span><br><span class=\"line\">    map.put(&quot;x-dead-letter-exchange&quot;,&quot;dlx.key.exchange&quot;);</span><br><span class=\"line\">    map.put(&quot;x-dead-letter-routing-key&quot;,&quot;dlx.key.bind&quot;);</span><br><span class=\"line\">    return new Queue(&quot;dlx.key.queue&quot;,false,false,false,map);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h4><p><img src=\"http://image.tupelo.top/rabbitMessage.png\" alt=\"消息\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置消息属性</span><br><span class=\"line\">Message message = MessageBuilder.withBody(&quot;测试&quot;.toString().getBytes())</span><br><span class=\"line\">                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class=\"line\">                .setCorrelationId(msgId).build();</span><br><span class=\"line\">rabbitTemplateConfirm.send(&quot;exchange&quot;,&quot;routing&quot;,message);</span><br></pre></td></tr></table></figure>"},{"title":"RabbitMq - 集群","_content":"\nRabbitMq集群\n\n## RabbitMq 集群(局域网/网络速度快)\n\n### 目标\n\n实现某一台机器挂了 程序还能运行 并不是为了保证消息万无一失  \n> 交换器全局复制 队列只有元数据复制 \n\n#### 相关命令\n\n- rabbitmqctl join_culster [rabbit@node] 加入集群  \n- rabbitmqctl status   集群状态  \n- rabbitmqctl reset    \n\n<!-- more -->\n#### 加入集群\n\n- /etc/host 各节点一直\n- /var/lib/rabbitmq/.erlang.cookie各节点一致(修改时可能要改权限777,修改完记得把权限改400回来,否则会报错)\n- 启动各节点mq rabbitmq-server\n- 要加入节点 先停止 rabbitmqctl stop_app\n- 情况集群情况 rabbitmqctl reset\n- 加入 rabbitmqctl join_cluster rabbit@node1(重命名方法:修改/etc/rabbitmq/rabbitmq-env.conf,加入 NODENAME=rabbit2@node2),默认是磁盘节点,单参数 --ram 则是内存节点(rabbitmqctl join_cluster rabbit@node1 --ram)\n- 启动 rabbitmqctl start_app\n- rabbitmqctl status 查看状况\n\n#### 离开集群\n\n- 停止 rabbitmqctl stop_app\n- 清空 rabbitmqctl reset\n- 启动 rabbitmqctl start_app\n\n#### 镜像队列\n\n> 在定义队列加入相关参数\n\n```java\nMap<String, Object> map = new HashMap<String, Object>();\n// 是否是在所有节点添加镜像 all是所有\nmap.put(\"x-ha-policy\",\"nodes\");\n// 在指定节点添加镜像\nmap.put(\"x-ha-nodes\",\"[rabbit@node1]\");\nchannel.queueDeclare(queueName,false,false,false,map);\n```\n###### 命令行添加镜像策略\n\n> rabbitmqctl set policy [-p vhost] name pattern Definition 例:queue开头的队列进行镜像处理,节点数1个 \n\nDefinition包含三个参数:ha-mode、ha-params、ha-sync-mode  \nha-mode[all、nodes、exactly] //exactly是指个数  \nha-sync-mode[automatic、manual] // 确认方式(自动、手动)  \n\n\n```\nrabbitmqctl set ha_queue \"^queue\" '{\"hamode\":\"exactly\",\"ha-params\":1,\"ha-sync-mode\":\"automatic\"}'\n```\n\n#### 第三方插件\n\n> 待学习(HAProxy) 类似Nginx\n\n\n\n\n\n\n\n","source":"_posts/rabbitmq-06.md","raw":"---\ntitle: RabbitMq - 集群\ntags:\n  - RabbitMq\n---\n\nRabbitMq集群\n\n## RabbitMq 集群(局域网/网络速度快)\n\n### 目标\n\n实现某一台机器挂了 程序还能运行 并不是为了保证消息万无一失  \n> 交换器全局复制 队列只有元数据复制 \n\n#### 相关命令\n\n- rabbitmqctl join_culster [rabbit@node] 加入集群  \n- rabbitmqctl status   集群状态  \n- rabbitmqctl reset    \n\n<!-- more -->\n#### 加入集群\n\n- /etc/host 各节点一直\n- /var/lib/rabbitmq/.erlang.cookie各节点一致(修改时可能要改权限777,修改完记得把权限改400回来,否则会报错)\n- 启动各节点mq rabbitmq-server\n- 要加入节点 先停止 rabbitmqctl stop_app\n- 情况集群情况 rabbitmqctl reset\n- 加入 rabbitmqctl join_cluster rabbit@node1(重命名方法:修改/etc/rabbitmq/rabbitmq-env.conf,加入 NODENAME=rabbit2@node2),默认是磁盘节点,单参数 --ram 则是内存节点(rabbitmqctl join_cluster rabbit@node1 --ram)\n- 启动 rabbitmqctl start_app\n- rabbitmqctl status 查看状况\n\n#### 离开集群\n\n- 停止 rabbitmqctl stop_app\n- 清空 rabbitmqctl reset\n- 启动 rabbitmqctl start_app\n\n#### 镜像队列\n\n> 在定义队列加入相关参数\n\n```java\nMap<String, Object> map = new HashMap<String, Object>();\n// 是否是在所有节点添加镜像 all是所有\nmap.put(\"x-ha-policy\",\"nodes\");\n// 在指定节点添加镜像\nmap.put(\"x-ha-nodes\",\"[rabbit@node1]\");\nchannel.queueDeclare(queueName,false,false,false,map);\n```\n###### 命令行添加镜像策略\n\n> rabbitmqctl set policy [-p vhost] name pattern Definition 例:queue开头的队列进行镜像处理,节点数1个 \n\nDefinition包含三个参数:ha-mode、ha-params、ha-sync-mode  \nha-mode[all、nodes、exactly] //exactly是指个数  \nha-sync-mode[automatic、manual] // 确认方式(自动、手动)  \n\n\n```\nrabbitmqctl set ha_queue \"^queue\" '{\"hamode\":\"exactly\",\"ha-params\":1,\"ha-sync-mode\":\"automatic\"}'\n```\n\n#### 第三方插件\n\n> 待学习(HAProxy) 类似Nginx\n\n\n\n\n\n\n\n","slug":"rabbitmq-06","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15aw001t9gj7u9vzubs1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMq集群</p>\n<h2 id=\"RabbitMq-集群-局域网-网络速度快\"><a href=\"#RabbitMq-集群-局域网-网络速度快\" class=\"headerlink\" title=\"RabbitMq 集群(局域网/网络速度快)\"></a>RabbitMq 集群(局域网/网络速度快)</h2><h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><p>实现某一台机器挂了 程序还能运行 并不是为了保证消息万无一失  </p>\n<blockquote>\n<p>交换器全局复制 队列只有元数据复制 </p>\n</blockquote>\n<h4 id=\"相关命令\"><a href=\"#相关命令\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h4><ul>\n<li>rabbitmqctl join_culster [rabbit@node] 加入集群  </li>\n<li>rabbitmqctl status   集群状态  </li>\n<li>rabbitmqctl reset    </li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"加入集群\"><a href=\"#加入集群\" class=\"headerlink\" title=\"加入集群\"></a>加入集群</h4><ul>\n<li>/etc/host 各节点一直</li>\n<li>/var/lib/rabbitmq/.erlang.cookie各节点一致(修改时可能要改权限777,修改完记得把权限改400回来,否则会报错)</li>\n<li>启动各节点mq rabbitmq-server</li>\n<li>要加入节点 先停止 rabbitmqctl stop_app</li>\n<li>情况集群情况 rabbitmqctl reset</li>\n<li>加入 rabbitmqctl join_cluster rabbit@node1(重命名方法:修改/etc/rabbitmq/rabbitmq-env.conf,加入 NODENAME=rabbit2@node2),默认是磁盘节点,单参数 –ram 则是内存节点(rabbitmqctl join_cluster rabbit@node1 –ram)</li>\n<li>启动 rabbitmqctl start_app</li>\n<li>rabbitmqctl status 查看状况</li>\n</ul>\n<h4 id=\"离开集群\"><a href=\"#离开集群\" class=\"headerlink\" title=\"离开集群\"></a>离开集群</h4><ul>\n<li>停止 rabbitmqctl stop_app</li>\n<li>清空 rabbitmqctl reset</li>\n<li>启动 rabbitmqctl start_app</li>\n</ul>\n<h4 id=\"镜像队列\"><a href=\"#镜像队列\" class=\"headerlink\" title=\"镜像队列\"></a>镜像队列</h4><blockquote>\n<p>在定义队列加入相关参数</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 是否是在所有节点添加镜像 all是所有</span></span><br><span class=\"line\">map.put(<span class=\"string\">\"x-ha-policy\"</span>,<span class=\"string\">\"nodes\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 在指定节点添加镜像</span></span><br><span class=\"line\">map.put(<span class=\"string\">\"x-ha-nodes\"</span>,<span class=\"string\">\"[rabbit@node1]\"</span>);</span><br><span class=\"line\">channel.queueDeclare(queueName,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br></pre></td></tr></table></figure>\n<h6 id=\"命令行添加镜像策略\"><a href=\"#命令行添加镜像策略\" class=\"headerlink\" title=\"命令行添加镜像策略\"></a>命令行添加镜像策略</h6><blockquote>\n<p>rabbitmqctl set policy [-p vhost] name pattern Definition 例:queue开头的队列进行镜像处理,节点数1个 </p>\n</blockquote>\n<p>Definition包含三个参数:ha-mode、ha-params、ha-sync-mode<br>ha-mode[all、nodes、exactly] //exactly是指个数<br>ha-sync-mode[automatic、manual] // 确认方式(自动、手动)  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set ha_queue &quot;^queue&quot; &apos;&#123;&quot;hamode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:1,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方插件\"><a href=\"#第三方插件\" class=\"headerlink\" title=\"第三方插件\"></a>第三方插件</h4><blockquote>\n<p>待学习(HAProxy) 类似Nginx</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>RabbitMq集群</p>\n<h2 id=\"RabbitMq-集群-局域网-网络速度快\"><a href=\"#RabbitMq-集群-局域网-网络速度快\" class=\"headerlink\" title=\"RabbitMq 集群(局域网/网络速度快)\"></a>RabbitMq 集群(局域网/网络速度快)</h2><h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><p>实现某一台机器挂了 程序还能运行 并不是为了保证消息万无一失  </p>\n<blockquote>\n<p>交换器全局复制 队列只有元数据复制 </p>\n</blockquote>\n<h4 id=\"相关命令\"><a href=\"#相关命令\" class=\"headerlink\" title=\"相关命令\"></a>相关命令</h4><ul>\n<li>rabbitmqctl join_culster [rabbit@node] 加入集群  </li>\n<li>rabbitmqctl status   集群状态  </li>\n<li>rabbitmqctl reset    </li>\n</ul>","more":"<h4 id=\"加入集群\"><a href=\"#加入集群\" class=\"headerlink\" title=\"加入集群\"></a>加入集群</h4><ul>\n<li>/etc/host 各节点一直</li>\n<li>/var/lib/rabbitmq/.erlang.cookie各节点一致(修改时可能要改权限777,修改完记得把权限改400回来,否则会报错)</li>\n<li>启动各节点mq rabbitmq-server</li>\n<li>要加入节点 先停止 rabbitmqctl stop_app</li>\n<li>情况集群情况 rabbitmqctl reset</li>\n<li>加入 rabbitmqctl join_cluster rabbit@node1(重命名方法:修改/etc/rabbitmq/rabbitmq-env.conf,加入 NODENAME=rabbit2@node2),默认是磁盘节点,单参数 –ram 则是内存节点(rabbitmqctl join_cluster rabbit@node1 –ram)</li>\n<li>启动 rabbitmqctl start_app</li>\n<li>rabbitmqctl status 查看状况</li>\n</ul>\n<h4 id=\"离开集群\"><a href=\"#离开集群\" class=\"headerlink\" title=\"离开集群\"></a>离开集群</h4><ul>\n<li>停止 rabbitmqctl stop_app</li>\n<li>清空 rabbitmqctl reset</li>\n<li>启动 rabbitmqctl start_app</li>\n</ul>\n<h4 id=\"镜像队列\"><a href=\"#镜像队列\" class=\"headerlink\" title=\"镜像队列\"></a>镜像队列</h4><blockquote>\n<p>在定义队列加入相关参数</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 是否是在所有节点添加镜像 all是所有</span></span><br><span class=\"line\">map.put(<span class=\"string\">\"x-ha-policy\"</span>,<span class=\"string\">\"nodes\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 在指定节点添加镜像</span></span><br><span class=\"line\">map.put(<span class=\"string\">\"x-ha-nodes\"</span>,<span class=\"string\">\"[rabbit@node1]\"</span>);</span><br><span class=\"line\">channel.queueDeclare(queueName,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,<span class=\"keyword\">false</span>,map);</span><br></pre></td></tr></table></figure>\n<h6 id=\"命令行添加镜像策略\"><a href=\"#命令行添加镜像策略\" class=\"headerlink\" title=\"命令行添加镜像策略\"></a>命令行添加镜像策略</h6><blockquote>\n<p>rabbitmqctl set policy [-p vhost] name pattern Definition 例:queue开头的队列进行镜像处理,节点数1个 </p>\n</blockquote>\n<p>Definition包含三个参数:ha-mode、ha-params、ha-sync-mode<br>ha-mode[all、nodes、exactly] //exactly是指个数<br>ha-sync-mode[automatic、manual] // 确认方式(自动、手动)  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set ha_queue &quot;^queue&quot; &apos;&#123;&quot;hamode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:1,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方插件\"><a href=\"#第三方插件\" class=\"headerlink\" title=\"第三方插件\"></a>第三方插件</h4><blockquote>\n<p>待学习(HAProxy) 类似Nginx</p>\n</blockquote>"},{"title":"Spring学习01 - 工程从XML配置到注解","_content":"\nspring基础学习\n\n## Spring 基础及组件使用01\n\n\n### 工程从XML配置到注解\n\n- 创建配置类 加上@Configuration注解 加上@ComponentScan注解 扫描指定的包 加载到IOC容器\n\n```java\n\t@Configuration\n\t@ComponentScan(value = \"com.tupelo\",useDefaultFilters = true,excludeFilters = {\n\t        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})\n\t})\n\t@EnableAspectJAutoProxy\n\tpublic class MainConfig {\n\n\t    @Bean\n\t    public Person person(){\n\t        return new Person(\"jack\",20);\n\t    }\n\n\t}\n```\n<!-- more -->\n\n- 启动时加载配置类\n\n```java\n\tpublic static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);\n    }\n```\n\n### scop扫描规则\n\n- prototype  多实例 IOC初始化的时候不会创建类 使用的时候才创建(懒加载也是 懒加载是针对单实例bean)\n- singleton  单实例\n- request    一次请求创建一个类\n- session    同一个session创建一个类\n\n```java\n\t@Lazy\n \t// @Scope(\"prototype\")\n\t@Bean\n    public Person person(){\n        return new Person(\"jack\",20);\n    }\n\n```\n\n\n\n","source":"_posts/spring-01.md","raw":"---\ntitle: Spring学习01 - 工程从XML配置到注解\ntags:\n  - Java\n  - Spring\n---\n\nspring基础学习\n\n## Spring 基础及组件使用01\n\n\n### 工程从XML配置到注解\n\n- 创建配置类 加上@Configuration注解 加上@ComponentScan注解 扫描指定的包 加载到IOC容器\n\n```java\n\t@Configuration\n\t@ComponentScan(value = \"com.tupelo\",useDefaultFilters = true,excludeFilters = {\n\t        @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})\n\t})\n\t@EnableAspectJAutoProxy\n\tpublic class MainConfig {\n\n\t    @Bean\n\t    public Person person(){\n\t        return new Person(\"jack\",20);\n\t    }\n\n\t}\n```\n<!-- more -->\n\n- 启动时加载配置类\n\n```java\n\tpublic static void main(String[] args) {\n        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);\n    }\n```\n\n### scop扫描规则\n\n- prototype  多实例 IOC初始化的时候不会创建类 使用的时候才创建(懒加载也是 懒加载是针对单实例bean)\n- singleton  单实例\n- request    一次请求创建一个类\n- session    同一个session创建一个类\n\n```java\n\t@Lazy\n \t// @Scope(\"prototype\")\n\t@Bean\n    public Person person(){\n        return new Person(\"jack\",20);\n    }\n\n```\n\n\n\n","slug":"spring-01","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15ax001u9gj79b1zlxpj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>spring基础学习</p>\n<h2 id=\"Spring-基础及组件使用01\"><a href=\"#Spring-基础及组件使用01\" class=\"headerlink\" title=\"Spring 基础及组件使用01\"></a>Spring 基础及组件使用01</h2><h3 id=\"工程从XML配置到注解\"><a href=\"#工程从XML配置到注解\" class=\"headerlink\" title=\"工程从XML配置到注解\"></a>工程从XML配置到注解</h3><ul>\n<li>创建配置类 加上@Configuration注解 加上@ComponentScan注解 扫描指定的包 加载到IOC容器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value = <span class=\"string\">\"com.tupelo\"</span>,useDefaultFilters = <span class=\"keyword\">true</span>,excludeFilters = &#123;</span><br><span class=\"line\">        <span class=\"meta\">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">person</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(<span class=\"string\">\"jack\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li>启动时加载配置类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       AnnotationConfigApplicationContext applicationContext = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"scop扫描规则\"><a href=\"#scop扫描规则\" class=\"headerlink\" title=\"scop扫描规则\"></a>scop扫描规则</h3><ul>\n<li>prototype  多实例 IOC初始化的时候不会创建类 使用的时候才创建(懒加载也是 懒加载是针对单实例bean)</li>\n<li>singleton  单实例</li>\n<li>request    一次请求创建一个类</li>\n<li>session    同一个session创建一个类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\">\t<span class=\"comment\">// @Scope(\"prototype\")</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">person</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(<span class=\"string\">\"jack\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>spring基础学习</p>\n<h2 id=\"Spring-基础及组件使用01\"><a href=\"#Spring-基础及组件使用01\" class=\"headerlink\" title=\"Spring 基础及组件使用01\"></a>Spring 基础及组件使用01</h2><h3 id=\"工程从XML配置到注解\"><a href=\"#工程从XML配置到注解\" class=\"headerlink\" title=\"工程从XML配置到注解\"></a>工程从XML配置到注解</h3><ul>\n<li>创建配置类 加上@Configuration注解 加上@ComponentScan注解 扫描指定的包 加载到IOC容器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(value = <span class=\"string\">\"com.tupelo\"</span>,useDefaultFilters = <span class=\"keyword\">true</span>,excludeFilters = &#123;</span><br><span class=\"line\">        <span class=\"meta\">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;Controller.class&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">person</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(<span class=\"string\">\"jack\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<ul>\n<li>启动时加载配置类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       AnnotationConfigApplicationContext applicationContext = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"scop扫描规则\"><a href=\"#scop扫描规则\" class=\"headerlink\" title=\"scop扫描规则\"></a>scop扫描规则</h3><ul>\n<li>prototype  多实例 IOC初始化的时候不会创建类 使用的时候才创建(懒加载也是 懒加载是针对单实例bean)</li>\n<li>singleton  单实例</li>\n<li>request    一次请求创建一个类</li>\n<li>session    同一个session创建一个类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\">\t<span class=\"comment\">// @Scope(\"prototype\")</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">person</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(<span class=\"string\">\"jack\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>"},{"title":"redis","_content":"\n\n\n#### redis持久化策略\n\nredis持久化策略主要有RDB和AOF两种。\n\n##### RDB\n\n- RDB：在指定的时间间隔能对数据进行快照储存\n\n触发方式\n\n1. 手动触发\n\nSAVE 和 BGSAVE 两个命令都可以手动触发生产RDB文件\n\n - SAVE: 阻塞当前redis服务，应该禁止该命令。  \n\n - BGSAVE: 主进程fork出一个子进程进行rdb操作，主线程继续响应其它的操作，为了保证RDB文件的完整性，子进程在操作时会先生成一个临时文件，操作完成之后再将临时文件重新命名为xxx.rdb(配置文件配置)，其中forkv操作时会阻塞redis服务。\n\n COW写时复制：当子线程和主线程都需要操作同一块内存的情况，主线程会先进行复制再进行操作复制。\n\n\n2. redis.conf配置\n\n在配置文件中配置 ```save m n``` 规则自动触发 m秒内有n次操作就会进行一次备份，执行SHOTDOWN命令时，如果没有开启AOF,也会触发RDB操作。\n\n```sh\n\n# 时间策略  900秒内有一个key的值变化就会触发rdb\nsave 900 1\n\n# rdb 文件的名称\ndbfilename dum.rdb\n\n# rdb文件保存的路径\ndir ./\n\n# rdb文件是否进行压缩\nrdbcompression yes\n\n\n```\n\n###### 总结\n\n- 优点\n\n执行效率高，适合大规模数据备份，不会影响主线程工作，备份文件占用空间小。\n\n- 缺点\n\n在执行RDB间隔间的数据可能会丢失，fork操作时会阻塞主线程。\n\n\n\n\n##### AOF\n\n\n- AOF:记录每次对服务器写的操作，当服务重启时执行这些命令来恢复数据。（默认不开启）\n\n\nAOF持久化的实现\n\n\n```sh\n命令写入 ->  AOF缓冲  ->  AOF文件\n\n\n# redis.conf配置\n\n# 开启aof\nappendonly yes\n# 命名\nappendfilename \"appendonly.aof\"\n\n# 同步策略\nappendfsync always  # 执行一次命令 立刻同步到aof文件 消耗大 最安全\nappendfsync everysec  # 每一秒同步一次\nappendfsync no  # 有操作系统同步\n```\n\n先放入AOF缓冲区，不让磁盘IO成为redis性能瓶颈。当redis重启时，会重新加载AOF文件。\n\n\n- AOF问题\n\n    - AOF文件体积膨胀? 解决： redis提供了AOF文件重写策略，FORK出子线程进行重写\n    \n    重写触发：\n\n    1. 手动触发，bgrewriteaof命令\n    2. 配置文件\n\n    ```sh\n    # 当前AOF文件的大小是上次AOF文件的100% 并且体积达到64M 满足两者才会触发\n    auto-aof-rewrite-percentage 100\n    auto-aof-min-size 64mb\n\n    ```\n\n\n##### RDB和AOF优先级\n\n优先AOF\n\n\n\n##### redis持久化总结\n\n1. RDB和AOF都会FORK子线程，会阻塞主线测，所以应该降低FORK触发频率，\n2. 控制redis最大使用内存，防止FORK时间太长\n3. RDB和AOF可以同时存在，配合使用\n\n\n\n#### redis过期删除策略&内存淘汰策略\n\n设置redis键过期时间\n\n```sh\n\nexpire key ttl  # 过期 秒\npexpire key ttl  # 过期 毫秒\nexpireat key timestamp  # 过期 秒时间戳\npexpireat key timestamp # 过期 毫秒时间戳\npersitt key # 移除过期时间\nttl key # 查看过期时间 秒\npttl key # 查看过期时间 毫秒\n```\n\n##### redis过期删除策略\n\n1. 惰性删除： 获取的时候判断如果过期了就删除\n2. 定期删除： 每隔一段时间随机选出一定数量的键，删除其中过期的键，默认随机选出10个。\n\n\n##### redis内存淘汰策略\n\nredis.conf设置最大内存\n\n```sh\nmaxmemory bytes # 通常设定物理内存的3/4\nmaxmemory-policy volatile-lru  # 设置淘汰策略\n```\n\n换成内存淘汰策略中有 ```FIFO```,```LRU``` ,```LFU```三种，redis在使用的有```LRU``` 和```LFU```\n\n```FIFO```: 先进先出。\n```LRU``` : 最近最少使用，核心思想，如果最近被使用，那么将来会被用到的概率变高，如果key最近被访问了，则移动到链表头部，redis中随机取出5个数据，选择时间最早的进行淘汰，存在一种情况：热点数据最近很少访问有可能被删除。\n```LFU``` : 最不经常使用，过去访问的次数越多，将来被访问的概率也越高。\n\n\n淘汰策略\n\n1. ```noeviction``` : 默认策略，内存到达最大值，所有写操作都报错。\n2. ```volatile-ttl``` : 过期时间越早被淘汰\n3. ```allkeys-random``` : 随机\n4. ```volatile-random``` : 有过期时间的key随机\n5. ```xxx-lru``` : ```LRU```算法\n6. ```xxx-lfu ```: ```LFU```算法\n\n\n\n#### 性能压测\n\n```redis-benchmark```\n\n\n#### redis高可用\n\n\n##### 主从架构\n\n1. 全量复制\n\n```master```将自己的```RDB```文件发送给```slave```,进行数据同步，记录同步期间的其它写入，再发送给```slave```。\n\n2. 增量复制\n\n```master```和```slave```短时间断开，```salve```发送```offset```，```master```根据偏移量发送偏移数据给```slave```，如果时间太长，则需要全量复制。\n\n\n配置主从配置：\n\n```sh\n\n1、 配置文件 slaveof <masterip><masterport>\n2、 命令执行 redis-server --slaveof <masterip><masterport>\n3、 客户端命令执行 slaveof <masterip><masterport>\n\n```\n\n主节点挂了之后从节点不会自动升级为节点，这时可以加上redis哨兵实现\n\n\n##### sentinel\n\n1. 添加配置文件 ```sentinel.conf```\n\n```sh\nsentinel monitor <名称> <ip> <port> <得票数>\n```\n\n2. 启动 ``` redis-sentinel ./sentinel.conf ```\n\n3. 选举策略 ： 复制进度大的 / ID号小的\n\n\n问题：\n\n- 仍然只有一个master节点处理写请求，并发请求量大时，服务任然压力大。\n- 每个从节点需要保存全量的数据，冗余的数据量大\n\n##### redis cluster\n\nredis clustor 采用多主多从的方式，引入哈希槽（16384）的概念，每个主节点只保存一部分数据，当某个主节点挂了之后从节点自动升级为主节点，\n\n1. 配置文件添加\n\n```sh\ncluster-enabled yes\n```\n\n2. 启动多个服务\n\n3. 构建cluster\n\n```sh\nredis-cli --cluster create <ip:port> <ip:port> <ip:port> --cluster-replicas 1\n```\n\ncluster-replicas表示master节点下需要有几个从节点，这样cluster就会将16384个槽位平均分配到每个节点。\n\n4. 扩容时 先添加节点到cluster中，然后重新分配槽位到新的节点\n\n```sh\n# 添加节点\nredis-cli --cluster add-node <需要添加的节点ip:port> <任意已存在节点 ip:port>\n\n# 查询节点信息\ncluster nodes\n\n# 添加重新分片\nredis-cli --cluster reshard <任意已存在节点ip:port> --cluster-from <已存在节点ID> --cluster-to <新添加节点ID> --cluster-slots <需要分配槽的个数>\n```\n\n\n","source":"_posts/redis.md","raw":"---\ntitle: redis\ntags:\n  - redis\n---\n\n\n\n#### redis持久化策略\n\nredis持久化策略主要有RDB和AOF两种。\n\n##### RDB\n\n- RDB：在指定的时间间隔能对数据进行快照储存\n\n触发方式\n\n1. 手动触发\n\nSAVE 和 BGSAVE 两个命令都可以手动触发生产RDB文件\n\n - SAVE: 阻塞当前redis服务，应该禁止该命令。  \n\n - BGSAVE: 主进程fork出一个子进程进行rdb操作，主线程继续响应其它的操作，为了保证RDB文件的完整性，子进程在操作时会先生成一个临时文件，操作完成之后再将临时文件重新命名为xxx.rdb(配置文件配置)，其中forkv操作时会阻塞redis服务。\n\n COW写时复制：当子线程和主线程都需要操作同一块内存的情况，主线程会先进行复制再进行操作复制。\n\n\n2. redis.conf配置\n\n在配置文件中配置 ```save m n``` 规则自动触发 m秒内有n次操作就会进行一次备份，执行SHOTDOWN命令时，如果没有开启AOF,也会触发RDB操作。\n\n```sh\n\n# 时间策略  900秒内有一个key的值变化就会触发rdb\nsave 900 1\n\n# rdb 文件的名称\ndbfilename dum.rdb\n\n# rdb文件保存的路径\ndir ./\n\n# rdb文件是否进行压缩\nrdbcompression yes\n\n\n```\n\n###### 总结\n\n- 优点\n\n执行效率高，适合大规模数据备份，不会影响主线程工作，备份文件占用空间小。\n\n- 缺点\n\n在执行RDB间隔间的数据可能会丢失，fork操作时会阻塞主线程。\n\n\n\n\n##### AOF\n\n\n- AOF:记录每次对服务器写的操作，当服务重启时执行这些命令来恢复数据。（默认不开启）\n\n\nAOF持久化的实现\n\n\n```sh\n命令写入 ->  AOF缓冲  ->  AOF文件\n\n\n# redis.conf配置\n\n# 开启aof\nappendonly yes\n# 命名\nappendfilename \"appendonly.aof\"\n\n# 同步策略\nappendfsync always  # 执行一次命令 立刻同步到aof文件 消耗大 最安全\nappendfsync everysec  # 每一秒同步一次\nappendfsync no  # 有操作系统同步\n```\n\n先放入AOF缓冲区，不让磁盘IO成为redis性能瓶颈。当redis重启时，会重新加载AOF文件。\n\n\n- AOF问题\n\n    - AOF文件体积膨胀? 解决： redis提供了AOF文件重写策略，FORK出子线程进行重写\n    \n    重写触发：\n\n    1. 手动触发，bgrewriteaof命令\n    2. 配置文件\n\n    ```sh\n    # 当前AOF文件的大小是上次AOF文件的100% 并且体积达到64M 满足两者才会触发\n    auto-aof-rewrite-percentage 100\n    auto-aof-min-size 64mb\n\n    ```\n\n\n##### RDB和AOF优先级\n\n优先AOF\n\n\n\n##### redis持久化总结\n\n1. RDB和AOF都会FORK子线程，会阻塞主线测，所以应该降低FORK触发频率，\n2. 控制redis最大使用内存，防止FORK时间太长\n3. RDB和AOF可以同时存在，配合使用\n\n\n\n#### redis过期删除策略&内存淘汰策略\n\n设置redis键过期时间\n\n```sh\n\nexpire key ttl  # 过期 秒\npexpire key ttl  # 过期 毫秒\nexpireat key timestamp  # 过期 秒时间戳\npexpireat key timestamp # 过期 毫秒时间戳\npersitt key # 移除过期时间\nttl key # 查看过期时间 秒\npttl key # 查看过期时间 毫秒\n```\n\n##### redis过期删除策略\n\n1. 惰性删除： 获取的时候判断如果过期了就删除\n2. 定期删除： 每隔一段时间随机选出一定数量的键，删除其中过期的键，默认随机选出10个。\n\n\n##### redis内存淘汰策略\n\nredis.conf设置最大内存\n\n```sh\nmaxmemory bytes # 通常设定物理内存的3/4\nmaxmemory-policy volatile-lru  # 设置淘汰策略\n```\n\n换成内存淘汰策略中有 ```FIFO```,```LRU``` ,```LFU```三种，redis在使用的有```LRU``` 和```LFU```\n\n```FIFO```: 先进先出。\n```LRU``` : 最近最少使用，核心思想，如果最近被使用，那么将来会被用到的概率变高，如果key最近被访问了，则移动到链表头部，redis中随机取出5个数据，选择时间最早的进行淘汰，存在一种情况：热点数据最近很少访问有可能被删除。\n```LFU``` : 最不经常使用，过去访问的次数越多，将来被访问的概率也越高。\n\n\n淘汰策略\n\n1. ```noeviction``` : 默认策略，内存到达最大值，所有写操作都报错。\n2. ```volatile-ttl``` : 过期时间越早被淘汰\n3. ```allkeys-random``` : 随机\n4. ```volatile-random``` : 有过期时间的key随机\n5. ```xxx-lru``` : ```LRU```算法\n6. ```xxx-lfu ```: ```LFU```算法\n\n\n\n#### 性能压测\n\n```redis-benchmark```\n\n\n#### redis高可用\n\n\n##### 主从架构\n\n1. 全量复制\n\n```master```将自己的```RDB```文件发送给```slave```,进行数据同步，记录同步期间的其它写入，再发送给```slave```。\n\n2. 增量复制\n\n```master```和```slave```短时间断开，```salve```发送```offset```，```master```根据偏移量发送偏移数据给```slave```，如果时间太长，则需要全量复制。\n\n\n配置主从配置：\n\n```sh\n\n1、 配置文件 slaveof <masterip><masterport>\n2、 命令执行 redis-server --slaveof <masterip><masterport>\n3、 客户端命令执行 slaveof <masterip><masterport>\n\n```\n\n主节点挂了之后从节点不会自动升级为节点，这时可以加上redis哨兵实现\n\n\n##### sentinel\n\n1. 添加配置文件 ```sentinel.conf```\n\n```sh\nsentinel monitor <名称> <ip> <port> <得票数>\n```\n\n2. 启动 ``` redis-sentinel ./sentinel.conf ```\n\n3. 选举策略 ： 复制进度大的 / ID号小的\n\n\n问题：\n\n- 仍然只有一个master节点处理写请求，并发请求量大时，服务任然压力大。\n- 每个从节点需要保存全量的数据，冗余的数据量大\n\n##### redis cluster\n\nredis clustor 采用多主多从的方式，引入哈希槽（16384）的概念，每个主节点只保存一部分数据，当某个主节点挂了之后从节点自动升级为主节点，\n\n1. 配置文件添加\n\n```sh\ncluster-enabled yes\n```\n\n2. 启动多个服务\n\n3. 构建cluster\n\n```sh\nredis-cli --cluster create <ip:port> <ip:port> <ip:port> --cluster-replicas 1\n```\n\ncluster-replicas表示master节点下需要有几个从节点，这样cluster就会将16384个槽位平均分配到每个节点。\n\n4. 扩容时 先添加节点到cluster中，然后重新分配槽位到新的节点\n\n```sh\n# 添加节点\nredis-cli --cluster add-node <需要添加的节点ip:port> <任意已存在节点 ip:port>\n\n# 查询节点信息\ncluster nodes\n\n# 添加重新分片\nredis-cli --cluster reshard <任意已存在节点ip:port> --cluster-from <已存在节点ID> --cluster-to <新添加节点ID> --cluster-slots <需要分配槽的个数>\n```\n\n\n","slug":"redis","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15ay001x9gj7fe4q4uvq","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"redis持久化策略\"><a href=\"#redis持久化策略\" class=\"headerlink\" title=\"redis持久化策略\"></a>redis持久化策略</h4><p>redis持久化策略主要有RDB和AOF两种。</p>\n<h5 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h5><ul>\n<li>RDB：在指定的时间间隔能对数据进行快照储存</li>\n</ul>\n<p>触发方式</p>\n<ol>\n<li>手动触发</li>\n</ol>\n<p>SAVE 和 BGSAVE 两个命令都可以手动触发生产RDB文件</p>\n<ul>\n<li><p>SAVE: 阻塞当前redis服务，应该禁止该命令。  </p>\n</li>\n<li><p>BGSAVE: 主进程fork出一个子进程进行rdb操作，主线程继续响应其它的操作，为了保证RDB文件的完整性，子进程在操作时会先生成一个临时文件，操作完成之后再将临时文件重新命名为xxx.rdb(配置文件配置)，其中forkv操作时会阻塞redis服务。</p>\n<p>COW写时复制：当子线程和主线程都需要操作同一块内存的情况，主线程会先进行复制再进行操作复制。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>redis.conf配置</li>\n</ol>\n<p>在配置文件中配置 <figure class=\"highlight plain\"><figcaption><span>m n``` 规则自动触发 m秒内有n次操作就会进行一次备份，执行SHOTDOWN命令时，如果没有开启AOF,也会触发RDB操作。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\"></span><br><span class=\"line\"># 时间策略  900秒内有一个key的值变化就会触发rdb</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"></span><br><span class=\"line\"># rdb 文件的名称</span><br><span class=\"line\">dbfilename dum.rdb</span><br><span class=\"line\"></span><br><span class=\"line\"># rdb文件保存的路径</span><br><span class=\"line\">dir ./</span><br><span class=\"line\"></span><br><span class=\"line\"># rdb文件是否进行压缩</span><br><span class=\"line\">rdbcompression yes</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h6><ul>\n<li>优点</li>\n</ul>\n<p>执行效率高，适合大规模数据备份，不会影响主线程工作，备份文件占用空间小。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>在执行RDB间隔间的数据可能会丢失，fork操作时会阻塞主线程。</p>\n<h5 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h5><ul>\n<li>AOF:记录每次对服务器写的操作，当服务重启时执行这些命令来恢复数据。（默认不开启）</li>\n</ul>\n<p>AOF持久化的实现</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令写入 -&gt;  AOF缓冲  -&gt;  AOF文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis.conf配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启aof</span></span><br><span class=\"line\">appendonly yes</span><br><span class=\"line\"><span class=\"comment\"># 命名</span></span><br><span class=\"line\">appendfilename <span class=\"string\">\"appendonly.aof\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同步策略</span></span><br><span class=\"line\">appendfsync always  <span class=\"comment\"># 执行一次命令 立刻同步到aof文件 消耗大 最安全</span></span><br><span class=\"line\">appendfsync everysec  <span class=\"comment\"># 每一秒同步一次</span></span><br><span class=\"line\">appendfsync no  <span class=\"comment\"># 有操作系统同步</span></span><br></pre></td></tr></table></figure>\n<p>先放入AOF缓冲区，不让磁盘IO成为redis性能瓶颈。当redis重启时，会重新加载AOF文件。</p>\n<ul>\n<li><p>AOF问题</p>\n<ul>\n<li><p>AOF文件体积膨胀? 解决： redis提供了AOF文件重写策略，FORK出子线程进行重写</p>\n<p>重写触发：</p>\n</li>\n</ul>\n<ol>\n<li>手动触发，bgrewriteaof命令</li>\n<li><p>配置文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当前AOF文件的大小是上次AOF文件的100% 并且体积达到64M 满足两者才会触发</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-min-size 64mb</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"RDB和AOF优先级\"><a href=\"#RDB和AOF优先级\" class=\"headerlink\" title=\"RDB和AOF优先级\"></a>RDB和AOF优先级</h5><p>优先AOF</p>\n<h5 id=\"redis持久化总结\"><a href=\"#redis持久化总结\" class=\"headerlink\" title=\"redis持久化总结\"></a>redis持久化总结</h5><ol>\n<li>RDB和AOF都会FORK子线程，会阻塞主线测，所以应该降低FORK触发频率，</li>\n<li>控制redis最大使用内存，防止FORK时间太长</li>\n<li>RDB和AOF可以同时存在，配合使用</li>\n</ol>\n<h4 id=\"redis过期删除策略-amp-内存淘汰策略\"><a href=\"#redis过期删除策略-amp-内存淘汰策略\" class=\"headerlink\" title=\"redis过期删除策略&amp;内存淘汰策略\"></a>redis过期删除策略&amp;内存淘汰策略</h4><p>设置redis键过期时间</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">expire key ttl  <span class=\"comment\"># 过期 秒</span></span><br><span class=\"line\">pexpire key ttl  <span class=\"comment\"># 过期 毫秒</span></span><br><span class=\"line\">expireat key timestamp  <span class=\"comment\"># 过期 秒时间戳</span></span><br><span class=\"line\">pexpireat key timestamp <span class=\"comment\"># 过期 毫秒时间戳</span></span><br><span class=\"line\">persitt key <span class=\"comment\"># 移除过期时间</span></span><br><span class=\"line\">ttl key <span class=\"comment\"># 查看过期时间 秒</span></span><br><span class=\"line\">pttl key <span class=\"comment\"># 查看过期时间 毫秒</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"redis过期删除策略\"><a href=\"#redis过期删除策略\" class=\"headerlink\" title=\"redis过期删除策略\"></a>redis过期删除策略</h5><ol>\n<li>惰性删除： 获取的时候判断如果过期了就删除</li>\n<li>定期删除： 每隔一段时间随机选出一定数量的键，删除其中过期的键，默认随机选出10个。</li>\n</ol>\n<h5 id=\"redis内存淘汰策略\"><a href=\"#redis内存淘汰策略\" class=\"headerlink\" title=\"redis内存淘汰策略\"></a>redis内存淘汰策略</h5><p>redis.conf设置最大内存</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory bytes <span class=\"comment\"># 通常设定物理内存的3/4</span></span><br><span class=\"line\">maxmemory-policy volatile-lru  <span class=\"comment\"># 设置淘汰策略</span></span><br></pre></td></tr></table></figure>\n<p>换成内存淘汰策略中有 <figure class=\"highlight plain\"><figcaption><span>,```LFU```三种，redis在使用的有```LRU``` 和```LFU```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```FIFO```: 先进先出。</span><br><span class=\"line\">```LRU``` : 最近最少使用，核心思想，如果最近被使用，那么将来会被用到的概率变高，如果key最近被访问了，则移动到链表头部，redis中随机取出5个数据，选择时间最早的进行淘汰，存在一种情况：热点数据最近很少访问有可能被删除。</span><br><span class=\"line\">```LFU``` : 最不经常使用，过去访问的次数越多，将来被访问的概率也越高。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">淘汰策略</span><br><span class=\"line\"></span><br><span class=\"line\">1. ```noeviction``` : 默认策略，内存到达最大值，所有写操作都报错。</span><br><span class=\"line\">2. ```volatile-ttl``` : 过期时间越早被淘汰</span><br><span class=\"line\">3. ```allkeys-random``` : 随机</span><br><span class=\"line\">4. ```volatile-random``` : 有过期时间的key随机</span><br><span class=\"line\">5. ```xxx-lru``` : ```LRU```算法</span><br><span class=\"line\">6. ```xxx-lfu ```: ```LFU```算法</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 性能压测</span><br><span class=\"line\"></span><br><span class=\"line\">```redis-benchmark</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h4><h5 id=\"主从架构\"><a href=\"#主从架构\" class=\"headerlink\" title=\"主从架构\"></a>主从架构</h5><ol>\n<li>全量复制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 增量复制</span><br><span class=\"line\"></span><br><span class=\"line\">```master```和```slave```短时间断开，```salve```发送```offset```，```master```根据偏移量发送偏移数据给```slave```，如果时间太长，则需要全量复制。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">配置主从配置：</span><br><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\"></span><br><span class=\"line\">1、 配置文件 slaveof &lt;masterip&gt;&lt;masterport&gt;</span><br><span class=\"line\">2、 命令执行 redis-server --slaveof &lt;masterip&gt;&lt;masterport&gt;</span><br><span class=\"line\">3、 客户端命令执行 slaveof &lt;masterip&gt;&lt;masterport&gt;</span><br></pre></td></tr></table></figure>\n<p>主节点挂了之后从节点不会自动升级为节点，这时可以加上redis哨兵实现</p>\n<h5 id=\"sentinel\"><a href=\"#sentinel\" class=\"headerlink\" title=\"sentinel\"></a>sentinel</h5><ol>\n<li><p>添加配置文件 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\">sentinel monitor &lt;名称&gt; &lt;ip&gt; &lt;port&gt; &lt;得票数&gt;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>启动 <figure class=\"highlight plain\"><figcaption><span>./sentinel.conf ```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 选举策略 ： 复制进度大的 / ID号小的</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">问题：</span><br><span class=\"line\"></span><br><span class=\"line\">- 仍然只有一个master节点处理写请求，并发请求量大时，服务任然压力大。</span><br><span class=\"line\">- 每个从节点需要保存全量的数据，冗余的数据量大</span><br><span class=\"line\"></span><br><span class=\"line\">##### redis cluster</span><br><span class=\"line\"></span><br><span class=\"line\">redis clustor 采用多主多从的方式，引入哈希槽（16384）的概念，每个主节点只保存一部分数据，当某个主节点挂了之后从节点自动升级为主节点，</span><br><span class=\"line\"></span><br><span class=\"line\">1. 配置文件添加</span><br><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\">cluster-enabled yes</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>启动多个服务</p>\n</li>\n<li><p>构建cluster</p>\n</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create &lt;ip:port&gt; &lt;ip:port&gt; &lt;ip:port&gt; --cluster-replicas 1</span><br></pre></td></tr></table></figure>\n<p>cluster-replicas表示master节点下需要有几个从节点，这样cluster就会将16384个槽位平均分配到每个节点。</p>\n<ol start=\"4\">\n<li>扩容时 先添加节点到cluster中，然后重新分配槽位到新的节点</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加节点</span></span><br><span class=\"line\">redis-cli --cluster add-node &lt;需要添加的节点ip:port&gt; &lt;任意已存在节点 ip:port&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询节点信息</span></span><br><span class=\"line\">cluster nodes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加重新分片</span></span><br><span class=\"line\">redis-cli --cluster reshard &lt;任意已存在节点ip:port&gt; --cluster-from &lt;已存在节点ID&gt; --cluster-to &lt;新添加节点ID&gt; --cluster-slots &lt;需要分配槽的个数&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"redis持久化策略\"><a href=\"#redis持久化策略\" class=\"headerlink\" title=\"redis持久化策略\"></a>redis持久化策略</h4><p>redis持久化策略主要有RDB和AOF两种。</p>\n<h5 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h5><ul>\n<li>RDB：在指定的时间间隔能对数据进行快照储存</li>\n</ul>\n<p>触发方式</p>\n<ol>\n<li>手动触发</li>\n</ol>\n<p>SAVE 和 BGSAVE 两个命令都可以手动触发生产RDB文件</p>\n<ul>\n<li><p>SAVE: 阻塞当前redis服务，应该禁止该命令。  </p>\n</li>\n<li><p>BGSAVE: 主进程fork出一个子进程进行rdb操作，主线程继续响应其它的操作，为了保证RDB文件的完整性，子进程在操作时会先生成一个临时文件，操作完成之后再将临时文件重新命名为xxx.rdb(配置文件配置)，其中forkv操作时会阻塞redis服务。</p>\n<p>COW写时复制：当子线程和主线程都需要操作同一块内存的情况，主线程会先进行复制再进行操作复制。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>redis.conf配置</li>\n</ol>\n<p>在配置文件中配置 <figure class=\"highlight plain\"><figcaption><span>m n``` 规则自动触发 m秒内有n次操作就会进行一次备份，执行SHOTDOWN命令时，如果没有开启AOF,也会触发RDB操作。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\"></span><br><span class=\"line\"># 时间策略  900秒内有一个key的值变化就会触发rdb</span><br><span class=\"line\">save 900 1</span><br><span class=\"line\"></span><br><span class=\"line\"># rdb 文件的名称</span><br><span class=\"line\">dbfilename dum.rdb</span><br><span class=\"line\"></span><br><span class=\"line\"># rdb文件保存的路径</span><br><span class=\"line\">dir ./</span><br><span class=\"line\"></span><br><span class=\"line\"># rdb文件是否进行压缩</span><br><span class=\"line\">rdbcompression yes</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h6><ul>\n<li>优点</li>\n</ul>\n<p>执行效率高，适合大规模数据备份，不会影响主线程工作，备份文件占用空间小。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>在执行RDB间隔间的数据可能会丢失，fork操作时会阻塞主线程。</p>\n<h5 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h5><ul>\n<li>AOF:记录每次对服务器写的操作，当服务重启时执行这些命令来恢复数据。（默认不开启）</li>\n</ul>\n<p>AOF持久化的实现</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令写入 -&gt;  AOF缓冲  -&gt;  AOF文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># redis.conf配置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开启aof</span></span><br><span class=\"line\">appendonly yes</span><br><span class=\"line\"><span class=\"comment\"># 命名</span></span><br><span class=\"line\">appendfilename <span class=\"string\">\"appendonly.aof\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同步策略</span></span><br><span class=\"line\">appendfsync always  <span class=\"comment\"># 执行一次命令 立刻同步到aof文件 消耗大 最安全</span></span><br><span class=\"line\">appendfsync everysec  <span class=\"comment\"># 每一秒同步一次</span></span><br><span class=\"line\">appendfsync no  <span class=\"comment\"># 有操作系统同步</span></span><br></pre></td></tr></table></figure>\n<p>先放入AOF缓冲区，不让磁盘IO成为redis性能瓶颈。当redis重启时，会重新加载AOF文件。</p>\n<ul>\n<li><p>AOF问题</p>\n<ul>\n<li><p>AOF文件体积膨胀? 解决： redis提供了AOF文件重写策略，FORK出子线程进行重写</p>\n<p>重写触发：</p>\n</li>\n</ul>\n<ol>\n<li>手动触发，bgrewriteaof命令</li>\n<li><p>配置文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 当前AOF文件的大小是上次AOF文件的100% 并且体积达到64M 满足两者才会触发</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-min-size 64mb</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"RDB和AOF优先级\"><a href=\"#RDB和AOF优先级\" class=\"headerlink\" title=\"RDB和AOF优先级\"></a>RDB和AOF优先级</h5><p>优先AOF</p>\n<h5 id=\"redis持久化总结\"><a href=\"#redis持久化总结\" class=\"headerlink\" title=\"redis持久化总结\"></a>redis持久化总结</h5><ol>\n<li>RDB和AOF都会FORK子线程，会阻塞主线测，所以应该降低FORK触发频率，</li>\n<li>控制redis最大使用内存，防止FORK时间太长</li>\n<li>RDB和AOF可以同时存在，配合使用</li>\n</ol>\n<h4 id=\"redis过期删除策略-amp-内存淘汰策略\"><a href=\"#redis过期删除策略-amp-内存淘汰策略\" class=\"headerlink\" title=\"redis过期删除策略&amp;内存淘汰策略\"></a>redis过期删除策略&amp;内存淘汰策略</h4><p>设置redis键过期时间</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">expire key ttl  <span class=\"comment\"># 过期 秒</span></span><br><span class=\"line\">pexpire key ttl  <span class=\"comment\"># 过期 毫秒</span></span><br><span class=\"line\">expireat key timestamp  <span class=\"comment\"># 过期 秒时间戳</span></span><br><span class=\"line\">pexpireat key timestamp <span class=\"comment\"># 过期 毫秒时间戳</span></span><br><span class=\"line\">persitt key <span class=\"comment\"># 移除过期时间</span></span><br><span class=\"line\">ttl key <span class=\"comment\"># 查看过期时间 秒</span></span><br><span class=\"line\">pttl key <span class=\"comment\"># 查看过期时间 毫秒</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"redis过期删除策略\"><a href=\"#redis过期删除策略\" class=\"headerlink\" title=\"redis过期删除策略\"></a>redis过期删除策略</h5><ol>\n<li>惰性删除： 获取的时候判断如果过期了就删除</li>\n<li>定期删除： 每隔一段时间随机选出一定数量的键，删除其中过期的键，默认随机选出10个。</li>\n</ol>\n<h5 id=\"redis内存淘汰策略\"><a href=\"#redis内存淘汰策略\" class=\"headerlink\" title=\"redis内存淘汰策略\"></a>redis内存淘汰策略</h5><p>redis.conf设置最大内存</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxmemory bytes <span class=\"comment\"># 通常设定物理内存的3/4</span></span><br><span class=\"line\">maxmemory-policy volatile-lru  <span class=\"comment\"># 设置淘汰策略</span></span><br></pre></td></tr></table></figure>\n<p>换成内存淘汰策略中有 <figure class=\"highlight plain\"><figcaption><span>,```LFU```三种，redis在使用的有```LRU``` 和```LFU```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```FIFO```: 先进先出。</span><br><span class=\"line\">```LRU``` : 最近最少使用，核心思想，如果最近被使用，那么将来会被用到的概率变高，如果key最近被访问了，则移动到链表头部，redis中随机取出5个数据，选择时间最早的进行淘汰，存在一种情况：热点数据最近很少访问有可能被删除。</span><br><span class=\"line\">```LFU``` : 最不经常使用，过去访问的次数越多，将来被访问的概率也越高。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">淘汰策略</span><br><span class=\"line\"></span><br><span class=\"line\">1. ```noeviction``` : 默认策略，内存到达最大值，所有写操作都报错。</span><br><span class=\"line\">2. ```volatile-ttl``` : 过期时间越早被淘汰</span><br><span class=\"line\">3. ```allkeys-random``` : 随机</span><br><span class=\"line\">4. ```volatile-random``` : 有过期时间的key随机</span><br><span class=\"line\">5. ```xxx-lru``` : ```LRU```算法</span><br><span class=\"line\">6. ```xxx-lfu ```: ```LFU```算法</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### 性能压测</span><br><span class=\"line\"></span><br><span class=\"line\">```redis-benchmark</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h4><h5 id=\"主从架构\"><a href=\"#主从架构\" class=\"headerlink\" title=\"主从架构\"></a>主从架构</h5><ol>\n<li>全量复制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 增量复制</span><br><span class=\"line\"></span><br><span class=\"line\">```master```和```slave```短时间断开，```salve```发送```offset```，```master```根据偏移量发送偏移数据给```slave```，如果时间太长，则需要全量复制。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">配置主从配置：</span><br><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\"></span><br><span class=\"line\">1、 配置文件 slaveof &lt;masterip&gt;&lt;masterport&gt;</span><br><span class=\"line\">2、 命令执行 redis-server --slaveof &lt;masterip&gt;&lt;masterport&gt;</span><br><span class=\"line\">3、 客户端命令执行 slaveof &lt;masterip&gt;&lt;masterport&gt;</span><br></pre></td></tr></table></figure>\n<p>主节点挂了之后从节点不会自动升级为节点，这时可以加上redis哨兵实现</p>\n<h5 id=\"sentinel\"><a href=\"#sentinel\" class=\"headerlink\" title=\"sentinel\"></a>sentinel</h5><ol>\n<li><p>添加配置文件 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\">sentinel monitor &lt;名称&gt; &lt;ip&gt; &lt;port&gt; &lt;得票数&gt;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>启动 <figure class=\"highlight plain\"><figcaption><span>./sentinel.conf ```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 选举策略 ： 复制进度大的 / ID号小的</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">问题：</span><br><span class=\"line\"></span><br><span class=\"line\">- 仍然只有一个master节点处理写请求，并发请求量大时，服务任然压力大。</span><br><span class=\"line\">- 每个从节点需要保存全量的数据，冗余的数据量大</span><br><span class=\"line\"></span><br><span class=\"line\">##### redis cluster</span><br><span class=\"line\"></span><br><span class=\"line\">redis clustor 采用多主多从的方式，引入哈希槽（16384）的概念，每个主节点只保存一部分数据，当某个主节点挂了之后从节点自动升级为主节点，</span><br><span class=\"line\"></span><br><span class=\"line\">1. 配置文件添加</span><br><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\">cluster-enabled yes</span><br></pre></td></tr></table></figure></p>\n</li>\n<li><p>启动多个服务</p>\n</li>\n<li><p>构建cluster</p>\n</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create &lt;ip:port&gt; &lt;ip:port&gt; &lt;ip:port&gt; --cluster-replicas 1</span><br></pre></td></tr></table></figure>\n<p>cluster-replicas表示master节点下需要有几个从节点，这样cluster就会将16384个槽位平均分配到每个节点。</p>\n<ol start=\"4\">\n<li>扩容时 先添加节点到cluster中，然后重新分配槽位到新的节点</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加节点</span></span><br><span class=\"line\">redis-cli --cluster add-node &lt;需要添加的节点ip:port&gt; &lt;任意已存在节点 ip:port&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询节点信息</span></span><br><span class=\"line\">cluster nodes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加重新分片</span></span><br><span class=\"line\">redis-cli --cluster reshard &lt;任意已存在节点ip:port&gt; --cluster-from &lt;已存在节点ID&gt; --cluster-to &lt;新添加节点ID&gt; --cluster-slots &lt;需要分配槽的个数&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"Spring学习03 - bean的生命周期","_content":"\nspring基础学习\n\n### bean的生命周期\n\nbean的生命周期:指   bean创建---初始化---销毁  的过程\n\nbean的生命周期是由容器进行管理的.我们可以自定义 bean初始化和销毁方法: 容器在bean进行到当前生命周期的时候, 来调用自定义的初始化和销毁方法\n\n#### 自定义 bean初始化和销毁方法\n\n\n- 指定初始化和销毁方法 init-method和destory-mothod\n\n```java\n\t@Bean(initMethod=\"init\",destoryMothod=\"destroy\")\n\tpublic Person lison(){\n\t\treturn new Person();\n\t}\n```\n\n容器关闭时，只有单实例Bean会调用distory方法，多实例容器只负责初始化,但不会管理bean, 容器关闭不会调用销毁方法。\n\n<!-- more -->\n\n- 让Bean实现 InitializingBean 和 DisposableBean接口\n\nafterPropertiesSet()方法:当beanFactory创建好对象,且把bean所有属性设置好之后,会调这个方法,相当于初始化方法\ndestory()方法,当bean销毁时,会把单实例bean进行销毁\n\n```java\n\t@Component\n\tpublic class People implements InitializingBean,DisposableBean {\n\t    @Override\n\t    public void destroy() throws Exception {\n\t        System.out.println(\"销毁\");\n\t    }\n\n\t    @Override\n\t    public void afterPropertiesSet() throws Exception {\n\t        System.out.println(\"初始化\");\n\t    }\n\t}\n```\n\n- JSR250规则定义的注解 @PostConstruct和@PreDestroy\n\n@PostConstruct: 在Bean创建完成,且属于赋值完成后进行初始化,属于JDK规范的注解\n@PreDestroy: 在bean将被移除之前进行通知, 在容器销毁之前进行清理工作\n\n```java\n\t@Component\n\tpublic class People {\n\t    @PostConstruct\n\t    public void init(){\n\t        System.out.println(\"初始化\");\n\t    }\n\t    @PreDestroy\n\t    public void distory(){\n\t        System.out.println(\"销毁\");\n\t    }\n\t}\n```\n\n- 后置处理器BeanPostProcessor,在bean初始化之前调用进行拦截\n\n\t- postProcessBeforeInitialization():在初始化之前进行后置处理工作(在init-method之前),    \n\t- postProcessAfterInitialization():在初始化之后进行后置处理工作\n\n```java\n\t@Component\n\tpublic class People implements BeanPostProcessor {\n\t    @Nullable\n\t    @Override\n\t    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t        System.out.println(\"初始化\");\n\t        return null;\n\t    }\n\n\t    @Nullable\n\t    @Override\n\t    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t        System.out.println(\"销毁\");\n\t        return null;\n\t    }\n\t}\n```\n\n","source":"_posts/spring-03.md","raw":"---\ntitle: Spring学习03 - bean的生命周期\ntags:\n  - Java\n  - Spring\n---\n\nspring基础学习\n\n### bean的生命周期\n\nbean的生命周期:指   bean创建---初始化---销毁  的过程\n\nbean的生命周期是由容器进行管理的.我们可以自定义 bean初始化和销毁方法: 容器在bean进行到当前生命周期的时候, 来调用自定义的初始化和销毁方法\n\n#### 自定义 bean初始化和销毁方法\n\n\n- 指定初始化和销毁方法 init-method和destory-mothod\n\n```java\n\t@Bean(initMethod=\"init\",destoryMothod=\"destroy\")\n\tpublic Person lison(){\n\t\treturn new Person();\n\t}\n```\n\n容器关闭时，只有单实例Bean会调用distory方法，多实例容器只负责初始化,但不会管理bean, 容器关闭不会调用销毁方法。\n\n<!-- more -->\n\n- 让Bean实现 InitializingBean 和 DisposableBean接口\n\nafterPropertiesSet()方法:当beanFactory创建好对象,且把bean所有属性设置好之后,会调这个方法,相当于初始化方法\ndestory()方法,当bean销毁时,会把单实例bean进行销毁\n\n```java\n\t@Component\n\tpublic class People implements InitializingBean,DisposableBean {\n\t    @Override\n\t    public void destroy() throws Exception {\n\t        System.out.println(\"销毁\");\n\t    }\n\n\t    @Override\n\t    public void afterPropertiesSet() throws Exception {\n\t        System.out.println(\"初始化\");\n\t    }\n\t}\n```\n\n- JSR250规则定义的注解 @PostConstruct和@PreDestroy\n\n@PostConstruct: 在Bean创建完成,且属于赋值完成后进行初始化,属于JDK规范的注解\n@PreDestroy: 在bean将被移除之前进行通知, 在容器销毁之前进行清理工作\n\n```java\n\t@Component\n\tpublic class People {\n\t    @PostConstruct\n\t    public void init(){\n\t        System.out.println(\"初始化\");\n\t    }\n\t    @PreDestroy\n\t    public void distory(){\n\t        System.out.println(\"销毁\");\n\t    }\n\t}\n```\n\n- 后置处理器BeanPostProcessor,在bean初始化之前调用进行拦截\n\n\t- postProcessBeforeInitialization():在初始化之前进行后置处理工作(在init-method之前),    \n\t- postProcessAfterInitialization():在初始化之后进行后置处理工作\n\n```java\n\t@Component\n\tpublic class People implements BeanPostProcessor {\n\t    @Nullable\n\t    @Override\n\t    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n\t        System.out.println(\"初始化\");\n\t        return null;\n\t    }\n\n\t    @Nullable\n\t    @Override\n\t    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\t        System.out.println(\"销毁\");\n\t        return null;\n\t    }\n\t}\n```\n\n","slug":"spring-03","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15az001y9gj7ij5zbbcn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>spring基础学习</p>\n<h3 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h3><p>bean的生命周期:指   bean创建—初始化—销毁  的过程</p>\n<p>bean的生命周期是由容器进行管理的.我们可以自定义 bean初始化和销毁方法: 容器在bean进行到当前生命周期的时候, 来调用自定义的初始化和销毁方法</p>\n<h4 id=\"自定义-bean初始化和销毁方法\"><a href=\"#自定义-bean初始化和销毁方法\" class=\"headerlink\" title=\"自定义 bean初始化和销毁方法\"></a>自定义 bean初始化和销毁方法</h4><ul>\n<li>指定初始化和销毁方法 init-method和destory-mothod</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span>(initMethod=<span class=\"string\">\"init\"</span>,destoryMothod=<span class=\"string\">\"destroy\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">lison</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>容器关闭时，只有单实例Bean会调用distory方法，多实例容器只负责初始化,但不会管理bean, 容器关闭不会调用销毁方法。</p>\n<a id=\"more\"></a>\n<ul>\n<li>让Bean实现 InitializingBean 和 DisposableBean接口</li>\n</ul>\n<p>afterPropertiesSet()方法:当beanFactory创建好对象,且把bean所有属性设置好之后,会调这个方法,相当于初始化方法<br>destory()方法,当bean销毁时,会把单实例bean进行销毁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>,<span class=\"title\">DisposableBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"销毁\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>JSR250规则定义的注解 @PostConstruct和@PreDestroy</li>\n</ul>\n<p>@PostConstruct: 在Bean创建完成,且属于赋值完成后进行初始化,属于JDK规范的注解<br>@PreDestroy: 在bean将被移除之前进行通知, 在容器销毁之前进行清理工作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">distory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"销毁\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>后置处理器BeanPostProcessor,在bean初始化之前调用进行拦截</p>\n<ul>\n<li>postProcessBeforeInitialization():在初始化之前进行后置处理工作(在init-method之前),    </li>\n<li>postProcessAfterInitialization():在初始化之后进行后置处理工作</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanPostProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"销毁\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>spring基础学习</p>\n<h3 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h3><p>bean的生命周期:指   bean创建—初始化—销毁  的过程</p>\n<p>bean的生命周期是由容器进行管理的.我们可以自定义 bean初始化和销毁方法: 容器在bean进行到当前生命周期的时候, 来调用自定义的初始化和销毁方法</p>\n<h4 id=\"自定义-bean初始化和销毁方法\"><a href=\"#自定义-bean初始化和销毁方法\" class=\"headerlink\" title=\"自定义 bean初始化和销毁方法\"></a>自定义 bean初始化和销毁方法</h4><ul>\n<li>指定初始化和销毁方法 init-method和destory-mothod</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span>(initMethod=<span class=\"string\">\"init\"</span>,destoryMothod=<span class=\"string\">\"destroy\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">lison</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>容器关闭时，只有单实例Bean会调用distory方法，多实例容器只负责初始化,但不会管理bean, 容器关闭不会调用销毁方法。</p>","more":"<ul>\n<li>让Bean实现 InitializingBean 和 DisposableBean接口</li>\n</ul>\n<p>afterPropertiesSet()方法:当beanFactory创建好对象,且把bean所有属性设置好之后,会调这个方法,相当于初始化方法<br>destory()方法,当bean销毁时,会把单实例bean进行销毁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>,<span class=\"title\">DisposableBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"销毁\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>JSR250规则定义的注解 @PostConstruct和@PreDestroy</li>\n</ul>\n<p>@PostConstruct: 在Bean创建完成,且属于赋值完成后进行初始化,属于JDK规范的注解<br>@PreDestroy: 在bean将被移除之前进行通知, 在容器销毁之前进行清理工作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">distory</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"销毁\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>后置处理器BeanPostProcessor,在bean初始化之前调用进行拦截</p>\n<ul>\n<li>postProcessBeforeInitialization():在初始化之前进行后置处理工作(在init-method之前),    </li>\n<li>postProcessAfterInitialization():在初始化之后进行后置处理工作</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanPostProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"销毁\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Spring学习02 - 常用注解","_content":"\nspring基础学习\n\n## Spring 基础及组件使用02\n\n\n### @Conditional条件注册Bean\n```java\n\t\tpackage com.enjoy.cap5.config;\n\n\t\timport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n\t\timport org.springframework.context.annotation.Condition;\n\t\timport org.springframework.context.annotation.ConditionContext;\n\t\timport org.springframework.core.env.Environment;\n\t\timport org.springframework.core.type.AnnotatedTypeMetadata;\n\n\t\tpublic class LinCondition implements Condition{\n\t\t\t/*\n\t\t\t*ConditionContext: 判断条件可以使用的上下文(环境)\n\t\t\t*AnnotatedTypeMetadata: 注解的信息\n\t\t\t*\n\t\t\t*/\n\t\t\t@Override\n\t\t\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t\t\t// 业务逻辑\n\t\t\t\t//能获取到IOC容器正在使用的beanFactory\n\t\t\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\t\t\t//获取当前环境变量(包括我们操作系统是WIN还是LINUX??)\n\t\t\t\tEnvironment environment = context.getEnvironment();\n\t\t\t\tString os_name = environment.getProperty(\"os.name\");\n\t\t\t\tif(os_name.contains(\"linux\")){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n```\n\n定义Bean时加上注解\n```java\n\t@Conditional(WinCondition.class)\n\t@Bean(\"lison\")\n\tpublic Person lison(){\n\t\treturn new Person();\n\t}\n```\n\n\n\n### BeanFactory 和 FactoryBean 的区别\n\n\n- FactoryBean ： 把我们的JAVA实例Bean通过FactoryBean注入到容器中\n- BeanFactory ： 从容器中获取我们实例化的Bean\n\n<!-- more -->\n\n\n### 向IOC容器中注册Bean实例的方法\n\n- @Bean注解: [导入第三方的类或包的组件],比如Person为第三方的类, 需要在我们的IOC容器中使用\n- 包扫描+组件的标注注解(@ComponentScan:  @Controller, @Service  @Reponsitory  @ Componet),一般是针对 我们自己写的类,使用这个\n- @Import:[快速给容器导入一个组件]\n    * @Import(要导入到容器中的组件):容器会自动注册这个组件,bean 的 id为全类名\n    ```java\n\t@Import(value = { Dog.class,Cat.class})\n    ```\n    * 实现ImportSelector接口:返回需要导入到容器的组件的全类名数组 \n    ```java\n\timport org.springframework.context.annotation.ImportSelector;\n\timport org.springframework.core.type.AnnotationMetadata;\n\n\tpublic class CaiImportSelector implements ImportSelector{\n\t\t@Override\n\t\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata){\n\t\t\t//返回全类名的bean\n\t\t\treturn new String[]{\"com.enjoy.cap6.bean.Fish\",\"com.enjoy.cap6.bean.Tiger\"};\n\t\t}\n\t}\n    ```\n    * 实现ImportBeanDefinitionRegistrar接口:可以手动添加组件到IOC容器\n    ```java\n\n\tpublic class CaiImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n\t\t/*\n\t\t*AnnotationMetadata:当前类的注解信息\n\t\t*BeanDefinitionRegistry:BeanDefinition注册类\n\t\t*    把所有需要添加到容器中的bean加入;\n\t\t*    @Scope\n\t\t*/\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\t\t\tboolean bean1 = registry.containsBeanDefinition(\"com.enjoy.cap6.bean.Dog\");\n\t\t\tboolean bean2 = registry.containsBeanDefinition(\"com.enjoy.cap6.bean.Cat\");\n\t\t\t//如果Dog和Cat同时存在于我们IOC容器中,那么创建Pig类, 加入到容器\n\t\t\t//对于我们要注册的bean, 给bean进行封装,\n\t\t\tif(bean1 && bean2){\n\t\t\t\tRootBeanDefinition beanDefinition = new RootBeanDefinition(Pig.class);\n\t\t\t\tregistry.registerBeanDefinition(\"pig\", beanDefinition);\n\t\t\t}\n\t\t}\n\n\t}\n\n    ```\n\n- 使用Spring提供的FactoryBean(工厂bean)进行注册 实现FactoryBean接口\n\n```java\nimport org.springframework.beans.factory.FactoryBean;\n\n// 注入Monkey类\npublic class CaiFactoryBean implements FactoryBean<Monkey>{\n\n\t@Override\n\tpublic Monkey getObject() throws Exception {\n\t\treturn new Monkey();\n\t}\n\n\t@Override\n\tpublic Class<?> getObjectType() {\n\t\treturn Monkey.class;\n\t}\n\t\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n}\n```\n\n","source":"_posts/spring-02.md","raw":"---\ntitle: Spring学习02 - 常用注解\ntags:\n  - Java\n  - Spring\n---\n\nspring基础学习\n\n## Spring 基础及组件使用02\n\n\n### @Conditional条件注册Bean\n```java\n\t\tpackage com.enjoy.cap5.config;\n\n\t\timport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n\t\timport org.springframework.context.annotation.Condition;\n\t\timport org.springframework.context.annotation.ConditionContext;\n\t\timport org.springframework.core.env.Environment;\n\t\timport org.springframework.core.type.AnnotatedTypeMetadata;\n\n\t\tpublic class LinCondition implements Condition{\n\t\t\t/*\n\t\t\t*ConditionContext: 判断条件可以使用的上下文(环境)\n\t\t\t*AnnotatedTypeMetadata: 注解的信息\n\t\t\t*\n\t\t\t*/\n\t\t\t@Override\n\t\t\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t\t\t// 业务逻辑\n\t\t\t\t//能获取到IOC容器正在使用的beanFactory\n\t\t\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n\t\t\t\t//获取当前环境变量(包括我们操作系统是WIN还是LINUX??)\n\t\t\t\tEnvironment environment = context.getEnvironment();\n\t\t\t\tString os_name = environment.getProperty(\"os.name\");\n\t\t\t\tif(os_name.contains(\"linux\")){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n```\n\n定义Bean时加上注解\n```java\n\t@Conditional(WinCondition.class)\n\t@Bean(\"lison\")\n\tpublic Person lison(){\n\t\treturn new Person();\n\t}\n```\n\n\n\n### BeanFactory 和 FactoryBean 的区别\n\n\n- FactoryBean ： 把我们的JAVA实例Bean通过FactoryBean注入到容器中\n- BeanFactory ： 从容器中获取我们实例化的Bean\n\n<!-- more -->\n\n\n### 向IOC容器中注册Bean实例的方法\n\n- @Bean注解: [导入第三方的类或包的组件],比如Person为第三方的类, 需要在我们的IOC容器中使用\n- 包扫描+组件的标注注解(@ComponentScan:  @Controller, @Service  @Reponsitory  @ Componet),一般是针对 我们自己写的类,使用这个\n- @Import:[快速给容器导入一个组件]\n    * @Import(要导入到容器中的组件):容器会自动注册这个组件,bean 的 id为全类名\n    ```java\n\t@Import(value = { Dog.class,Cat.class})\n    ```\n    * 实现ImportSelector接口:返回需要导入到容器的组件的全类名数组 \n    ```java\n\timport org.springframework.context.annotation.ImportSelector;\n\timport org.springframework.core.type.AnnotationMetadata;\n\n\tpublic class CaiImportSelector implements ImportSelector{\n\t\t@Override\n\t\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata){\n\t\t\t//返回全类名的bean\n\t\t\treturn new String[]{\"com.enjoy.cap6.bean.Fish\",\"com.enjoy.cap6.bean.Tiger\"};\n\t\t}\n\t}\n    ```\n    * 实现ImportBeanDefinitionRegistrar接口:可以手动添加组件到IOC容器\n    ```java\n\n\tpublic class CaiImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n\t\t/*\n\t\t*AnnotationMetadata:当前类的注解信息\n\t\t*BeanDefinitionRegistry:BeanDefinition注册类\n\t\t*    把所有需要添加到容器中的bean加入;\n\t\t*    @Scope\n\t\t*/\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\t\t\tboolean bean1 = registry.containsBeanDefinition(\"com.enjoy.cap6.bean.Dog\");\n\t\t\tboolean bean2 = registry.containsBeanDefinition(\"com.enjoy.cap6.bean.Cat\");\n\t\t\t//如果Dog和Cat同时存在于我们IOC容器中,那么创建Pig类, 加入到容器\n\t\t\t//对于我们要注册的bean, 给bean进行封装,\n\t\t\tif(bean1 && bean2){\n\t\t\t\tRootBeanDefinition beanDefinition = new RootBeanDefinition(Pig.class);\n\t\t\t\tregistry.registerBeanDefinition(\"pig\", beanDefinition);\n\t\t\t}\n\t\t}\n\n\t}\n\n    ```\n\n- 使用Spring提供的FactoryBean(工厂bean)进行注册 实现FactoryBean接口\n\n```java\nimport org.springframework.beans.factory.FactoryBean;\n\n// 注入Monkey类\npublic class CaiFactoryBean implements FactoryBean<Monkey>{\n\n\t@Override\n\tpublic Monkey getObject() throws Exception {\n\t\treturn new Monkey();\n\t}\n\n\t@Override\n\tpublic Class<?> getObjectType() {\n\t\treturn Monkey.class;\n\t}\n\t\n\t@Override\n\tpublic boolean isSingleton() {\n\t\treturn true;\n\t}\n}\n```\n\n","slug":"spring-02","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15b000219gj7damf1c7w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>spring基础学习</p>\n<h2 id=\"Spring-基础及组件使用02\"><a href=\"#Spring-基础及组件使用02\" class=\"headerlink\" title=\"Spring 基础及组件使用02\"></a>Spring 基础及组件使用02</h2><h3 id=\"Conditional条件注册Bean\"><a href=\"#Conditional条件注册Bean\" class=\"headerlink\" title=\"@Conditional条件注册Bean\"></a>@Conditional条件注册Bean</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.enjoy.cap5.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.env.Environment;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t*ConditionContext: 判断条件可以使用的上下文(环境)</span></span><br><span class=\"line\"><span class=\"comment\">\t*AnnotatedTypeMetadata: 注解的信息</span></span><br><span class=\"line\"><span class=\"comment\">\t*</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//能获取到IOC容器正在使用的beanFactory</span></span><br><span class=\"line\">\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取当前环境变量(包括我们操作系统是WIN还是LINUX??)</span></span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\tString os_name = environment.getProperty(<span class=\"string\">\"os.name\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(os_name.contains(<span class=\"string\">\"linux\"</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义Bean时加上注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Conditional</span>(WinCondition.class)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(<span class=\"string\">\"lison\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">lison</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"BeanFactory-和-FactoryBean-的区别\"><a href=\"#BeanFactory-和-FactoryBean-的区别\" class=\"headerlink\" title=\"BeanFactory 和 FactoryBean 的区别\"></a>BeanFactory 和 FactoryBean 的区别</h3><ul>\n<li>FactoryBean ： 把我们的JAVA实例Bean通过FactoryBean注入到容器中</li>\n<li>BeanFactory ： 从容器中获取我们实例化的Bean</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"向IOC容器中注册Bean实例的方法\"><a href=\"#向IOC容器中注册Bean实例的方法\" class=\"headerlink\" title=\"向IOC容器中注册Bean实例的方法\"></a>向IOC容器中注册Bean实例的方法</h3><ul>\n<li>@Bean注解: [导入第三方的类或包的组件],比如Person为第三方的类, 需要在我们的IOC容器中使用</li>\n<li>包扫描+组件的标注注解(@ComponentScan:  @Controller, @Service  @Reponsitory  @ Componet),一般是针对 我们自己写的类,使用这个</li>\n<li><p>@Import:[快速给容器导入一个组件]</p>\n<ul>\n<li><p>@Import(要导入到容器中的组件):容器会自动注册这个组件,bean 的 id为全类名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Import</span>(value = &#123; Dog.class,Cat.class&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现ImportSelector接口:返回需要导入到容器的组件的全类名数组 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaiImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportSelector</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//返回全类名的bean</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"com.enjoy.cap6.bean.Fish\"</span>,<span class=\"string\">\"com.enjoy.cap6.bean.Tiger\"</span>&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现ImportBeanDefinitionRegistrar接口:可以手动添加组件到IOC容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaiImportBeanDefinitionRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t*AnnotationMetadata:当前类的注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t*BeanDefinitionRegistry:BeanDefinition注册类</span></span><br><span class=\"line\"><span class=\"comment\">\t*    把所有需要添加到容器中的bean加入;</span></span><br><span class=\"line\"><span class=\"comment\">\t*    @Scope</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> bean1 = registry.containsBeanDefinition(<span class=\"string\">\"com.enjoy.cap6.bean.Dog\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> bean2 = registry.containsBeanDefinition(<span class=\"string\">\"com.enjoy.cap6.bean.Cat\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果Dog和Cat同时存在于我们IOC容器中,那么创建Pig类, 加入到容器</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//对于我们要注册的bean, 给bean进行封装,</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(bean1 &amp;&amp; bean2)&#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition beanDefinition = <span class=\"keyword\">new</span> RootBeanDefinition(Pig.class);</span><br><span class=\"line\">\t\t\tregistry.registerBeanDefinition(<span class=\"string\">\"pig\"</span>, beanDefinition);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>使用Spring提供的FactoryBean(工厂bean)进行注册 实现FactoryBean接口</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注入Monkey类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaiFactoryBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">Monkey</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Monkey <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Monkey();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Monkey.class;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>spring基础学习</p>\n<h2 id=\"Spring-基础及组件使用02\"><a href=\"#Spring-基础及组件使用02\" class=\"headerlink\" title=\"Spring 基础及组件使用02\"></a>Spring 基础及组件使用02</h2><h3 id=\"Conditional条件注册Bean\"><a href=\"#Conditional条件注册Bean\" class=\"headerlink\" title=\"@Conditional条件注册Bean\"></a>@Conditional条件注册Bean</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.enjoy.cap5.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.env.Environment;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t*ConditionContext: 判断条件可以使用的上下文(环境)</span></span><br><span class=\"line\"><span class=\"comment\">\t*AnnotatedTypeMetadata: 注解的信息</span></span><br><span class=\"line\"><span class=\"comment\">\t*</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 业务逻辑</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//能获取到IOC容器正在使用的beanFactory</span></span><br><span class=\"line\">\t\tConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取当前环境变量(包括我们操作系统是WIN还是LINUX??)</span></span><br><span class=\"line\">\t\tEnvironment environment = context.getEnvironment();</span><br><span class=\"line\">\t\tString os_name = environment.getProperty(<span class=\"string\">\"os.name\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(os_name.contains(<span class=\"string\">\"linux\"</span>))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义Bean时加上注解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Conditional</span>(WinCondition.class)</span><br><span class=\"line\"><span class=\"meta\">@Bean</span>(<span class=\"string\">\"lison\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">lison</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"BeanFactory-和-FactoryBean-的区别\"><a href=\"#BeanFactory-和-FactoryBean-的区别\" class=\"headerlink\" title=\"BeanFactory 和 FactoryBean 的区别\"></a>BeanFactory 和 FactoryBean 的区别</h3><ul>\n<li>FactoryBean ： 把我们的JAVA实例Bean通过FactoryBean注入到容器中</li>\n<li>BeanFactory ： 从容器中获取我们实例化的Bean</li>\n</ul>","more":"<h3 id=\"向IOC容器中注册Bean实例的方法\"><a href=\"#向IOC容器中注册Bean实例的方法\" class=\"headerlink\" title=\"向IOC容器中注册Bean实例的方法\"></a>向IOC容器中注册Bean实例的方法</h3><ul>\n<li>@Bean注解: [导入第三方的类或包的组件],比如Person为第三方的类, 需要在我们的IOC容器中使用</li>\n<li>包扫描+组件的标注注解(@ComponentScan:  @Controller, @Service  @Reponsitory  @ Componet),一般是针对 我们自己写的类,使用这个</li>\n<li><p>@Import:[快速给容器导入一个组件]</p>\n<ul>\n<li><p>@Import(要导入到容器中的组件):容器会自动注册这个组件,bean 的 id为全类名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Import</span>(value = &#123; Dog.class,Cat.class&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现ImportSelector接口:返回需要导入到容器的组件的全类名数组 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ImportSelector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaiImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportSelector</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata)&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//返回全类名的bean</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"com.enjoy.cap6.bean.Fish\"</span>,<span class=\"string\">\"com.enjoy.cap6.bean.Tiger\"</span>&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现ImportBeanDefinitionRegistrar接口:可以手动添加组件到IOC容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaiImportBeanDefinitionRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t*AnnotationMetadata:当前类的注解信息</span></span><br><span class=\"line\"><span class=\"comment\">\t*BeanDefinitionRegistry:BeanDefinition注册类</span></span><br><span class=\"line\"><span class=\"comment\">\t*    把所有需要添加到容器中的bean加入;</span></span><br><span class=\"line\"><span class=\"comment\">\t*    @Scope</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> bean1 = registry.containsBeanDefinition(<span class=\"string\">\"com.enjoy.cap6.bean.Dog\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> bean2 = registry.containsBeanDefinition(<span class=\"string\">\"com.enjoy.cap6.bean.Cat\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果Dog和Cat同时存在于我们IOC容器中,那么创建Pig类, 加入到容器</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//对于我们要注册的bean, 给bean进行封装,</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(bean1 &amp;&amp; bean2)&#123;</span><br><span class=\"line\">\t\t\tRootBeanDefinition beanDefinition = <span class=\"keyword\">new</span> RootBeanDefinition(Pig.class);</span><br><span class=\"line\">\t\t\tregistry.registerBeanDefinition(<span class=\"string\">\"pig\"</span>, beanDefinition);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>使用Spring提供的FactoryBean(工厂bean)进行注册 实现FactoryBean接口</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注入Monkey类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaiFactoryBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">Monkey</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Monkey <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Monkey();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Monkey.class;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"SpringIOC - IOC源码分析","_content":"\nIOC源码分析\n\n### IOC流程\n\n#### IOC源码入口\n\n```java\n\n\t// Spring启动入口\n\tAnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(Cap12MainConfig.class);\n\tapp.close();\n\n\n\t// Spring容器的refresh()【创建刷新】\n\tpublic void refresh() throws BeansException, IllegalStateException {\n        Object var1 = this.startupShutdownMonitor;\n        synchronized(this.startupShutdownMonitor) {\n            this.prepareRefresh();\n            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n            this.prepareBeanFactory(beanFactory);\n\n            try {\n                this.postProcessBeanFactory(beanFactory);\n                this.invokeBeanFactoryPostProcessors(beanFactory);\n                this.registerBeanPostProcessors(beanFactory);\n                this.initMessageSource();\n                this.initApplicationEventMulticaster();\n                this.onRefresh();\n                this.registerListeners();\n                this.finishBeanFactoryInitialization(beanFactory);\n                this.finishRefresh();\n            } catch (BeansException var9) {\n                if (this.logger.isWarnEnabled()) {\n                    this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9);\n                }\n\n                this.destroyBeans();\n                this.cancelRefresh(var9);\n                throw var9;\n            } finally {\n                this.resetCommonCaches();\n            }\n\n        }\n    }\n```\n\n<!-- more -->\n\n\n#### IOC流程详解\n\nSpring容器的refresh()【创建刷新】;\n\n* prepareRefresh() 刷新前的预处理\n\t- initPropertySources() 初始化一些属性设置;子类自定义个性化的属性设置方法\n\t- getEnvironment().validateRequiredProperties() 检验属性的合法等\n\t- earlyApplicationEvents= new LinkedHashSet<ApplicationEvent>() 保存容器中的一些早期的事件\n\n* obtainFreshBeanFactory() 获取BeanFactory\n\t- refreshBeanFactory();刷新【创建】BeanFactory;110行:创建了一个this.beanFactory = new DefaultListableBeanFactory();设置id;\n\t- getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象;\n\t- 将创建的BeanFactory【DefaultListableBeanFactory】返回;\n\n* prepareBeanFactory(beanFactory) BeanFactory的预准备工作（以上创建了beanFactory,现在对BeanFactory对象进行一些设置属性）\n\t- 设置BeanFactory的类加载器、支持表达式解析器...\n\t- 添加部分BeanPostProcessor【ApplicationContextAwareProcessor】\n\t- 设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx;\n\t- 注册可以解析的自动装配;我们能直接在任何组件中自动注入:BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext\n\t- 添加BeanPostProcessor【ApplicationListenerDetector】\n\t- 添加编译时的AspectJ;\n\t- 给BeanFactory中注册一些能用的组件; \n\t\tenvironment【ConfigurableEnvironment】、systemProperties【Map<String, Object>】、systemEnvironment【Map<String, Object>】\n\n* postProcessBeanFactory(beanFactory) BeanFactory准备工作完成后进行的后置处理工作\n\t- 子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\n\n\n> 以上是BeanFactory的创建及预准备工作\n\n---\n\n\n* invokeBeanFactoryPostProcessors(beanFactory) 执行BeanFactoryPostProcessor的方法\n\n\t> BeanFactoryPostProcessor:BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的,两个接口:BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor\n\n\t- 执行BeanFactoryPostProcessor的方法\n\t\t先执行BeanDefinitionRegistryPostProcessor\n\t\t- 83行:获取所有的BeanDefinitionRegistryPostProcessor;\n\t\t- 86行:看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry)\n\t\t- 99行:在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor;\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry)\n\t\t- 109行:最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors;\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry)\n\t- 再执行BeanFactoryPostProcessor的方法\n\t\t- 139行:获取所有的BeanFactoryPostProcessor\n\t\t- 147行:看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、\n\t\t\tpostProcessor.postProcessBeanFactory()\n\t\t- 167行:在执行实现了Ordered顺序接口的BeanFactoryPostProcessor;\n\t\t\tpostProcessor.postProcessBeanFactory()\n\t\t- 175行:最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor;\n\t\t\tpostProcessor.postProcessBeanFactory()\n\n\n* registerBeanPostProcessors(beanFactory) 注册BeanPostProcessor（Bean的后置处理器）\n\t```\n\t不同接口类型的BeanPostProcessor;在Bean创建前后的执行时机是不一样的\n\tBeanPostProcessor、\n\tDestructionAwareBeanPostProcessor、\n\tInstantiationAwareBeanPostProcessor、\n\tSmartInstantiationAwareBeanPostProcessor、\n\tMergedBeanDefinitionPostProcessor【internalPostProcessors】\n\t```\n\t- 189行:获取所有的BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级\n\t- 204行:先注册PriorityOrdered优先级接口的BeanPostProcessor,把每一个BeanPostProcessor添加到BeanFactory中,beanFactory.addBeanPostProcessor(postProcessor);\n\t- 224行:再注册Ordered接口的\n\t- 236行:最后注册没有实现任何优先级接口的\n\t- 最终注册MergedBeanDefinitionPostProcessor;\n\t- 注册一个ApplicationListenerDetector;来在Bean创建完成后检查是否是ApplicationListener,如果是:applicationContext.addApplicationListener((ApplicationListener<?>) bean);\n\n\n* initMessageSource() 初始化MessageSource组件（做国际化功能;消息绑定,消息解析）\n\n\t- 718行:获取BeanFactory\n\t- 719行:看容器中是否有id为messageSource的,类型是MessageSource的组件,如果有赋值给messageSource,如果没有自己创建一个DelegatingMessageSource;MessageSource:取出国际化配置文件中的某个key的值,能按照区域信息获取\n\t- 739行:把创建好的MessageSource注册在容器中,以后获取国际化配置文件的值的时候,可以自动注入MessageSource;\n\n\t```java\n\tbeanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\t\n\tMessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);\n\t//以后可通过getMessage获取 \n\t```\n\t\n\n\n* initApplicationEventMulticaster() 初始化事件派发器\n\n\t- 753行:获取BeanFactory\n\t- 754行:从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster\n\t- 762行:如果上一步没有配置;创建一个SimpleApplicationEventMulticaster\n\t- 763行:将创建的ApplicationEventMulticaster添加到BeanFactory中,以后其他组件直接自动注入\n\n\n* onRefresh() 留给子容器（子类）\n\n\t- 子类重写这个方法,在容器刷新的时候可以自定义逻辑;\n\n\n* registerListeners() 给容器中将所有项目里面的ApplicationListener注册进来\n\n\t- 822行:从容器中拿到所有的ApplicationListener\n\t- 824行:将每个监听器添加到事件派发器中\n\t```java\n\tgetApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName)\n\t```\n\t- 832行:派发之前步骤产生的事件;\n\n\n* finishBeanFactoryInitialization(beanFactory) 初始化所有剩下的单实例bean \n\n\t- 867行:beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean,跟进\n\t\t- 734行:获取容器中的所有Bean,依次进行初始化和创建对象\n\t\t- 738行:获取Bean的定义信息;RootBeanDefinition\n\t\t- 739行:Bean不是抽象的,是单实例的,是懒加载;\n\t\t\t- 740行:判断是否是FactoryBean;是否是实现FactoryBean接口的Bean;\n\t\t\t- 760行:不是工厂Bean。利用getBean(beanName);创建对象\n\t\t\t\t- 199行:getBean(beanName); ioc.getBean();\n\t\t\t\t- doGetBean(name, null, null, false);\n\t\t\t\t- 246行: getSingleton(beanName)先获取缓存中保存的单实例Bean《跟进去其实就是从MAP中拿》。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）\n\t\t\t\t```java\n\t\t\t\t// 从这个中获取的\n\t\t\t\tprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n\t\t\t\t```\n\t\t\t\t- 缓存中获取不到,开始Bean的创建对象流程;\n\t\t\t\t- 287行:标记当前bean已经被创建（防止多线程同时创建,使用synchronized）\n\t\t\t\t- 291行:获取Bean的定义信息;\n\t\t\t\t- 295行:getDependsOn(),bean.xml里创建person时,加depend-on=\"jeep,moon\"是先把jeep和moon创建出来,【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来;】\n\t\t\t\t- 启动单实例Bean的创建流程;\n\t\t\t\t\t- 462行:createBean(beanName, mbd, args);\n\t\t\t\t\t- 490行:Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象;\n\t\t\t\t\t\t【InstantiationAwareBeanPostProcessor】:提前执行;\n\t\t\t\t\t\t先触发:postProcessBeforeInstantiation();\n\t\t\t\t\t\t如果有返回值:触发postProcessAfterInitialization();\n\t\t\t\t\t- 如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象;调用下面\n\t\t\t\t\t- 501行:Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean\n\t\t\t\t\t\t - 541行:【创建Bean实例】;createBeanInstance(beanName, mbd, args);\n\t\t\t\t\t\t \t利用工厂方法或者对象的构造器创建出Bean实例;\n\t\t\t\t\t\t - applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t\t\t \t调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t\t\t\t\t - 578行:【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);\n\t\t\t\t\t\t \t赋值之前:\n\t\t\t\t\t\t \t- 拿到InstantiationAwareBeanPostProcessor后置处理器;\n\t\t\t\t\t\t \t\t1305行:postProcessAfterInstantiation();\n\t\t\t\t\t\t \t- 拿到InstantiationAwareBeanPostProcessor后置处理器;\n\t\t\t\t\t\t \t\t1348行:postProcessPropertyValues();\n\t\t\t\t\t\t \t=====赋值之前:===\n\t\t\t\t\t\t \t- 应用Bean属性的值;为属性利用setter方法等进行赋值;\n\t\t\t\t\t\t \t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t\t\t\t\t - 【Bean初始化】initializeBean(beanName, exposedObject, mbd);\n\t\t\t\t\t\t \t- 1693行:【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法\n\t\t\t\t\t\t \t\tBeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware\n\t\t\t\t\t\t \t- 1698行:【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t\t\t\t\t \t\tBeanPostProcessor.postProcessBeforeInitialization（）;\n\t\t\t\t\t\t \t- 1702行:【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);\n\t\t\t\t\t\t \t\t- 是否是InitializingBean接口的实现;执行接口规定的初始化;\n\t\t\t\t\t\t \t\t- 是否自定义初始化方法;\n\t\t\t\t\t\t \t- 1710行:【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization\n\t\t\t\t\t\t \t\tBeanPostProcessor.postProcessAfterInitialization();\n\t\t\t\t\t\t\n\t\t\t\t\t- 将创建的Bean添加到缓存中singletonObjects;sharedInstance = getSingleton(beanName, ()跟进去\n\t\t\t\t\t     254行:addSingleton（）,放到MAP中\n\t\t\t\tioc容器就是这些Map;很多的Map里面保存了单实例Bean,环境信息。。。。;\n\t\t所有Bean都利用getBean创建完成以后;\n\t\t\t检查所有的Bean是否是SmartInitializingSingleton接口的;如果是;就执行afterSingletonsInstantiated();\n\n\n* finishRefresh() 完成BeanFactory的初始化创建工作,IOC容器就创建完成\n\n\t- 882行:initLifecycleProcessor() 初始化和生命周期有关的后置处理器:LifecycleProcessor,默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】;如果没有new DefaultLifecycleProcessor()加入到容器;\n\t```\n\t自己也可以尝试写一个LifecycleProcessor的实现类,可以在BeanFactory\n\t\tvoid onRefresh();\n\t\tvoid onClose();\t\n\t```\n\t- 885行:getLifecycleProcessor().onRefresh() 拿到前面定义的生命周期处理器（BeanFactory） 回调onRefresh()\n\t- 888行:publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件;\n\t- 891行:liveBeansView.registerApplicationContext(this);\n\t\n","source":"_posts/spring-IOC.md","raw":"---\ntitle: SpringIOC - IOC源码分析\ntags:\n  - Java\n  - Spring\n---\n\nIOC源码分析\n\n### IOC流程\n\n#### IOC源码入口\n\n```java\n\n\t// Spring启动入口\n\tAnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(Cap12MainConfig.class);\n\tapp.close();\n\n\n\t// Spring容器的refresh()【创建刷新】\n\tpublic void refresh() throws BeansException, IllegalStateException {\n        Object var1 = this.startupShutdownMonitor;\n        synchronized(this.startupShutdownMonitor) {\n            this.prepareRefresh();\n            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();\n            this.prepareBeanFactory(beanFactory);\n\n            try {\n                this.postProcessBeanFactory(beanFactory);\n                this.invokeBeanFactoryPostProcessors(beanFactory);\n                this.registerBeanPostProcessors(beanFactory);\n                this.initMessageSource();\n                this.initApplicationEventMulticaster();\n                this.onRefresh();\n                this.registerListeners();\n                this.finishBeanFactoryInitialization(beanFactory);\n                this.finishRefresh();\n            } catch (BeansException var9) {\n                if (this.logger.isWarnEnabled()) {\n                    this.logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt: \" + var9);\n                }\n\n                this.destroyBeans();\n                this.cancelRefresh(var9);\n                throw var9;\n            } finally {\n                this.resetCommonCaches();\n            }\n\n        }\n    }\n```\n\n<!-- more -->\n\n\n#### IOC流程详解\n\nSpring容器的refresh()【创建刷新】;\n\n* prepareRefresh() 刷新前的预处理\n\t- initPropertySources() 初始化一些属性设置;子类自定义个性化的属性设置方法\n\t- getEnvironment().validateRequiredProperties() 检验属性的合法等\n\t- earlyApplicationEvents= new LinkedHashSet<ApplicationEvent>() 保存容器中的一些早期的事件\n\n* obtainFreshBeanFactory() 获取BeanFactory\n\t- refreshBeanFactory();刷新【创建】BeanFactory;110行:创建了一个this.beanFactory = new DefaultListableBeanFactory();设置id;\n\t- getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象;\n\t- 将创建的BeanFactory【DefaultListableBeanFactory】返回;\n\n* prepareBeanFactory(beanFactory) BeanFactory的预准备工作（以上创建了beanFactory,现在对BeanFactory对象进行一些设置属性）\n\t- 设置BeanFactory的类加载器、支持表达式解析器...\n\t- 添加部分BeanPostProcessor【ApplicationContextAwareProcessor】\n\t- 设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx;\n\t- 注册可以解析的自动装配;我们能直接在任何组件中自动注入:BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext\n\t- 添加BeanPostProcessor【ApplicationListenerDetector】\n\t- 添加编译时的AspectJ;\n\t- 给BeanFactory中注册一些能用的组件; \n\t\tenvironment【ConfigurableEnvironment】、systemProperties【Map<String, Object>】、systemEnvironment【Map<String, Object>】\n\n* postProcessBeanFactory(beanFactory) BeanFactory准备工作完成后进行的后置处理工作\n\t- 子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\n\n\n> 以上是BeanFactory的创建及预准备工作\n\n---\n\n\n* invokeBeanFactoryPostProcessors(beanFactory) 执行BeanFactoryPostProcessor的方法\n\n\t> BeanFactoryPostProcessor:BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的,两个接口:BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor\n\n\t- 执行BeanFactoryPostProcessor的方法\n\t\t先执行BeanDefinitionRegistryPostProcessor\n\t\t- 83行:获取所有的BeanDefinitionRegistryPostProcessor;\n\t\t- 86行:看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry)\n\t\t- 99行:在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor;\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry)\n\t\t- 109行:最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors;\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry)\n\t- 再执行BeanFactoryPostProcessor的方法\n\t\t- 139行:获取所有的BeanFactoryPostProcessor\n\t\t- 147行:看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、\n\t\t\tpostProcessor.postProcessBeanFactory()\n\t\t- 167行:在执行实现了Ordered顺序接口的BeanFactoryPostProcessor;\n\t\t\tpostProcessor.postProcessBeanFactory()\n\t\t- 175行:最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor;\n\t\t\tpostProcessor.postProcessBeanFactory()\n\n\n* registerBeanPostProcessors(beanFactory) 注册BeanPostProcessor（Bean的后置处理器）\n\t```\n\t不同接口类型的BeanPostProcessor;在Bean创建前后的执行时机是不一样的\n\tBeanPostProcessor、\n\tDestructionAwareBeanPostProcessor、\n\tInstantiationAwareBeanPostProcessor、\n\tSmartInstantiationAwareBeanPostProcessor、\n\tMergedBeanDefinitionPostProcessor【internalPostProcessors】\n\t```\n\t- 189行:获取所有的BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级\n\t- 204行:先注册PriorityOrdered优先级接口的BeanPostProcessor,把每一个BeanPostProcessor添加到BeanFactory中,beanFactory.addBeanPostProcessor(postProcessor);\n\t- 224行:再注册Ordered接口的\n\t- 236行:最后注册没有实现任何优先级接口的\n\t- 最终注册MergedBeanDefinitionPostProcessor;\n\t- 注册一个ApplicationListenerDetector;来在Bean创建完成后检查是否是ApplicationListener,如果是:applicationContext.addApplicationListener((ApplicationListener<?>) bean);\n\n\n* initMessageSource() 初始化MessageSource组件（做国际化功能;消息绑定,消息解析）\n\n\t- 718行:获取BeanFactory\n\t- 719行:看容器中是否有id为messageSource的,类型是MessageSource的组件,如果有赋值给messageSource,如果没有自己创建一个DelegatingMessageSource;MessageSource:取出国际化配置文件中的某个key的值,能按照区域信息获取\n\t- 739行:把创建好的MessageSource注册在容器中,以后获取国际化配置文件的值的时候,可以自动注入MessageSource;\n\n\t```java\n\tbeanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\t\n\tMessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);\n\t//以后可通过getMessage获取 \n\t```\n\t\n\n\n* initApplicationEventMulticaster() 初始化事件派发器\n\n\t- 753行:获取BeanFactory\n\t- 754行:从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster\n\t- 762行:如果上一步没有配置;创建一个SimpleApplicationEventMulticaster\n\t- 763行:将创建的ApplicationEventMulticaster添加到BeanFactory中,以后其他组件直接自动注入\n\n\n* onRefresh() 留给子容器（子类）\n\n\t- 子类重写这个方法,在容器刷新的时候可以自定义逻辑;\n\n\n* registerListeners() 给容器中将所有项目里面的ApplicationListener注册进来\n\n\t- 822行:从容器中拿到所有的ApplicationListener\n\t- 824行:将每个监听器添加到事件派发器中\n\t```java\n\tgetApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName)\n\t```\n\t- 832行:派发之前步骤产生的事件;\n\n\n* finishBeanFactoryInitialization(beanFactory) 初始化所有剩下的单实例bean \n\n\t- 867行:beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean,跟进\n\t\t- 734行:获取容器中的所有Bean,依次进行初始化和创建对象\n\t\t- 738行:获取Bean的定义信息;RootBeanDefinition\n\t\t- 739行:Bean不是抽象的,是单实例的,是懒加载;\n\t\t\t- 740行:判断是否是FactoryBean;是否是实现FactoryBean接口的Bean;\n\t\t\t- 760行:不是工厂Bean。利用getBean(beanName);创建对象\n\t\t\t\t- 199行:getBean(beanName); ioc.getBean();\n\t\t\t\t- doGetBean(name, null, null, false);\n\t\t\t\t- 246行: getSingleton(beanName)先获取缓存中保存的单实例Bean《跟进去其实就是从MAP中拿》。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）\n\t\t\t\t```java\n\t\t\t\t// 从这个中获取的\n\t\t\t\tprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n\t\t\t\t```\n\t\t\t\t- 缓存中获取不到,开始Bean的创建对象流程;\n\t\t\t\t- 287行:标记当前bean已经被创建（防止多线程同时创建,使用synchronized）\n\t\t\t\t- 291行:获取Bean的定义信息;\n\t\t\t\t- 295行:getDependsOn(),bean.xml里创建person时,加depend-on=\"jeep,moon\"是先把jeep和moon创建出来,【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来;】\n\t\t\t\t- 启动单实例Bean的创建流程;\n\t\t\t\t\t- 462行:createBean(beanName, mbd, args);\n\t\t\t\t\t- 490行:Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象;\n\t\t\t\t\t\t【InstantiationAwareBeanPostProcessor】:提前执行;\n\t\t\t\t\t\t先触发:postProcessBeforeInstantiation();\n\t\t\t\t\t\t如果有返回值:触发postProcessAfterInitialization();\n\t\t\t\t\t- 如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象;调用下面\n\t\t\t\t\t- 501行:Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean\n\t\t\t\t\t\t - 541行:【创建Bean实例】;createBeanInstance(beanName, mbd, args);\n\t\t\t\t\t\t \t利用工厂方法或者对象的构造器创建出Bean实例;\n\t\t\t\t\t\t - applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t\t\t \t调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);\n\t\t\t\t\t\t - 578行:【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);\n\t\t\t\t\t\t \t赋值之前:\n\t\t\t\t\t\t \t- 拿到InstantiationAwareBeanPostProcessor后置处理器;\n\t\t\t\t\t\t \t\t1305行:postProcessAfterInstantiation();\n\t\t\t\t\t\t \t- 拿到InstantiationAwareBeanPostProcessor后置处理器;\n\t\t\t\t\t\t \t\t1348行:postProcessPropertyValues();\n\t\t\t\t\t\t \t=====赋值之前:===\n\t\t\t\t\t\t \t- 应用Bean属性的值;为属性利用setter方法等进行赋值;\n\t\t\t\t\t\t \t\tapplyPropertyValues(beanName, mbd, bw, pvs);\n\t\t\t\t\t\t - 【Bean初始化】initializeBean(beanName, exposedObject, mbd);\n\t\t\t\t\t\t \t- 1693行:【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法\n\t\t\t\t\t\t \t\tBeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware\n\t\t\t\t\t\t \t- 1698行:【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t\t\t\t\t \t\tBeanPostProcessor.postProcessBeforeInitialization（）;\n\t\t\t\t\t\t \t- 1702行:【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);\n\t\t\t\t\t\t \t\t- 是否是InitializingBean接口的实现;执行接口规定的初始化;\n\t\t\t\t\t\t \t\t- 是否自定义初始化方法;\n\t\t\t\t\t\t \t- 1710行:【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization\n\t\t\t\t\t\t \t\tBeanPostProcessor.postProcessAfterInitialization();\n\t\t\t\t\t\t\n\t\t\t\t\t- 将创建的Bean添加到缓存中singletonObjects;sharedInstance = getSingleton(beanName, ()跟进去\n\t\t\t\t\t     254行:addSingleton（）,放到MAP中\n\t\t\t\tioc容器就是这些Map;很多的Map里面保存了单实例Bean,环境信息。。。。;\n\t\t所有Bean都利用getBean创建完成以后;\n\t\t\t检查所有的Bean是否是SmartInitializingSingleton接口的;如果是;就执行afterSingletonsInstantiated();\n\n\n* finishRefresh() 完成BeanFactory的初始化创建工作,IOC容器就创建完成\n\n\t- 882行:initLifecycleProcessor() 初始化和生命周期有关的后置处理器:LifecycleProcessor,默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】;如果没有new DefaultLifecycleProcessor()加入到容器;\n\t```\n\t自己也可以尝试写一个LifecycleProcessor的实现类,可以在BeanFactory\n\t\tvoid onRefresh();\n\t\tvoid onClose();\t\n\t```\n\t- 885行:getLifecycleProcessor().onRefresh() 拿到前面定义的生命周期处理器（BeanFactory） 回调onRefresh()\n\t- 888行:publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件;\n\t- 891行:liveBeansView.registerApplicationContext(this);\n\t\n","slug":"spring-IOC","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15b000229gj7vtdk6wnf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>IOC源码分析</p>\n<h3 id=\"IOC流程\"><a href=\"#IOC流程\" class=\"headerlink\" title=\"IOC流程\"></a>IOC流程</h3><h4 id=\"IOC源码入口\"><a href=\"#IOC源码入口\" class=\"headerlink\" title=\"IOC源码入口\"></a>IOC源码入口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Spring启动入口</span></span><br><span class=\"line\">AnnotationConfigApplicationContext app = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(Cap12MainConfig.class);</span><br><span class=\"line\">app.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Spring容器的refresh()【创建刷新】</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class=\"line\">       Object var1 = <span class=\"keyword\">this</span>.startupShutdownMonitor;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.prepareRefresh();</span><br><span class=\"line\">           ConfigurableListableBeanFactory beanFactory = <span class=\"keyword\">this</span>.obtainFreshBeanFactory();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.initMessageSource();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.initApplicationEventMulticaster();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.onRefresh();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.registerListeners();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.finishRefresh();</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (BeansException var9) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">this</span>.logger.warn(<span class=\"string\">\"Exception encountered during context initialization - cancelling refresh attempt: \"</span> + var9);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">this</span>.destroyBeans();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.cancelRefresh(var9);</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> var9;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.resetCommonCaches();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"IOC流程详解\"><a href=\"#IOC流程详解\" class=\"headerlink\" title=\"IOC流程详解\"></a>IOC流程详解</h4><p>Spring容器的refresh()【创建刷新】;</p>\n<ul>\n<li><p>prepareRefresh() 刷新前的预处理</p>\n<ul>\n<li>initPropertySources() 初始化一些属性设置;子类自定义个性化的属性设置方法</li>\n<li>getEnvironment().validateRequiredProperties() 检验属性的合法等</li>\n<li>earlyApplicationEvents= new LinkedHashSet<applicationevent>() 保存容器中的一些早期的事件</applicationevent></li>\n</ul>\n</li>\n<li><p>obtainFreshBeanFactory() 获取BeanFactory</p>\n<ul>\n<li>refreshBeanFactory();刷新【创建】BeanFactory;110行:创建了一个this.beanFactory = new DefaultListableBeanFactory();设置id;</li>\n<li>getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象;</li>\n<li>将创建的BeanFactory【DefaultListableBeanFactory】返回;</li>\n</ul>\n</li>\n<li><p>prepareBeanFactory(beanFactory) BeanFactory的预准备工作（以上创建了beanFactory,现在对BeanFactory对象进行一些设置属性）</p>\n<ul>\n<li>设置BeanFactory的类加载器、支持表达式解析器…</li>\n<li>添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</li>\n<li>设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx;</li>\n<li>注册可以解析的自动装配;我们能直接在任何组件中自动注入:BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</li>\n<li>添加BeanPostProcessor【ApplicationListenerDetector】</li>\n<li>添加编译时的AspectJ;</li>\n<li>给BeanFactory中注册一些能用的组件;<br>  environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</li>\n</ul>\n</li>\n<li><p>postProcessBeanFactory(beanFactory) BeanFactory准备工作完成后进行的后置处理工作</p>\n<ul>\n<li>子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上是BeanFactory的创建及预准备工作</p>\n</blockquote>\n<hr>\n<ul>\n<li><p>invokeBeanFactoryPostProcessors(beanFactory) 执行BeanFactoryPostProcessor的方法</p>\n<blockquote>\n<p>BeanFactoryPostProcessor:BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的,两个接口:BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</p>\n</blockquote>\n<ul>\n<li>执行BeanFactoryPostProcessor的方法<br>  先执行BeanDefinitionRegistryPostProcessor<ul>\n<li>83行:获取所有的BeanDefinitionRegistryPostProcessor;</li>\n<li>86行:看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、<br>  postProcessor.postProcessBeanDefinitionRegistry(registry)</li>\n<li>99行:在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor;<br>  postProcessor.postProcessBeanDefinitionRegistry(registry)</li>\n<li>109行:最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors;<br>  postProcessor.postProcessBeanDefinitionRegistry(registry)</li>\n</ul>\n</li>\n<li>再执行BeanFactoryPostProcessor的方法<ul>\n<li>139行:获取所有的BeanFactoryPostProcessor</li>\n<li>147行:看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、<br>  postProcessor.postProcessBeanFactory()</li>\n<li>167行:在执行实现了Ordered顺序接口的BeanFactoryPostProcessor;<br>  postProcessor.postProcessBeanFactory()</li>\n<li>175行:最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor;<br>  postProcessor.postProcessBeanFactory()</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>registerBeanPostProcessors(beanFactory) 注册BeanPostProcessor（Bean的后置处理器）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不同接口类型的BeanPostProcessor;在Bean创建前后的执行时机是不一样的</span><br><span class=\"line\">BeanPostProcessor、</span><br><span class=\"line\">DestructionAwareBeanPostProcessor、</span><br><span class=\"line\">InstantiationAwareBeanPostProcessor、</span><br><span class=\"line\">SmartInstantiationAwareBeanPostProcessor、</span><br><span class=\"line\">MergedBeanDefinitionPostProcessor【internalPostProcessors】</span><br></pre></td></tr></table></figure>\n<ul>\n<li>189行:获取所有的BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级</li>\n<li>204行:先注册PriorityOrdered优先级接口的BeanPostProcessor,把每一个BeanPostProcessor添加到BeanFactory中,beanFactory.addBeanPostProcessor(postProcessor);</li>\n<li>224行:再注册Ordered接口的</li>\n<li>236行:最后注册没有实现任何优先级接口的</li>\n<li>最终注册MergedBeanDefinitionPostProcessor;</li>\n<li>注册一个ApplicationListenerDetector;来在Bean创建完成后检查是否是ApplicationListener,如果是:applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>initMessageSource() 初始化MessageSource组件（做国际化功能;消息绑定,消息解析）</p>\n<ul>\n<li>718行:获取BeanFactory</li>\n<li>719行:看容器中是否有id为messageSource的,类型是MessageSource的组件,如果有赋值给messageSource,如果没有自己创建一个DelegatingMessageSource;MessageSource:取出国际化配置文件中的某个key的值,能按照区域信息获取</li>\n<li><p>739行:把创建好的MessageSource注册在容器中,以后获取国际化配置文件的值的时候,可以自动注入MessageSource;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class=\"keyword\">this</span>.messageSource);\t</span><br><span class=\"line\">MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);</span><br><span class=\"line\"><span class=\"comment\">//以后可通过getMessage获取</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>initApplicationEventMulticaster() 初始化事件派发器</p>\n<ul>\n<li>753行:获取BeanFactory</li>\n<li>754行:从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</li>\n<li>762行:如果上一步没有配置;创建一个SimpleApplicationEventMulticaster</li>\n<li>763行:将创建的ApplicationEventMulticaster添加到BeanFactory中,以后其他组件直接自动注入</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>onRefresh() 留给子容器（子类）</p>\n<ul>\n<li>子类重写这个方法,在容器刷新的时候可以自定义逻辑;</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>registerListeners() 给容器中将所有项目里面的ApplicationListener注册进来</p>\n<ul>\n<li>822行:从容器中拿到所有的ApplicationListener</li>\n<li><p>824行:将每个监听器添加到事件派发器中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>832行:派发之前步骤产生的事件;</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>finishBeanFactoryInitialization(beanFactory) 初始化所有剩下的单实例bean </p>\n<ul>\n<li><p>867行:beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean,跟进</p>\n<ul>\n<li>734行:获取容器中的所有Bean,依次进行初始化和创建对象</li>\n<li>738行:获取Bean的定义信息;RootBeanDefinition</li>\n<li><p>739行:Bean不是抽象的,是单实例的,是懒加载;</p>\n<ul>\n<li>740行:判断是否是FactoryBean;是否是实现FactoryBean接口的Bean;</li>\n<li><p>760行:不是工厂Bean。利用getBean(beanName);创建对象</p>\n<ul>\n<li>199行:getBean(beanName); ioc.getBean();</li>\n<li>doGetBean(name, null, null, false);</li>\n<li><p>246行: getSingleton(beanName)先获取缓存中保存的单实例Bean《跟进去其实就是从MAP中拿》。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从这个中获取的</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">256</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缓存中获取不到,开始Bean的创建对象流程;</p>\n</li>\n<li>287行:标记当前bean已经被创建（防止多线程同时创建,使用synchronized）</li>\n<li>291行:获取Bean的定义信息;</li>\n<li>295行:getDependsOn(),bean.xml里创建person时,加depend-on=”jeep,moon”是先把jeep和moon创建出来,【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来;】</li>\n<li><p>启动单实例Bean的创建流程;</p>\n<ul>\n<li>462行:createBean(beanName, mbd, args);</li>\n<li>490行:Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象;<br>  【InstantiationAwareBeanPostProcessor】:提前执行;<br>  先触发:postProcessBeforeInstantiation();<br>  如果有返回值:触发postProcessAfterInitialization();</li>\n<li>如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象;调用下面</li>\n<li><p>501行:Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</p>\n<ul>\n<li>541行:【创建Bean实例】;createBeanInstance(beanName, mbd, args);<br>  利用工厂方法或者对象的构造器创建出Bean实例;</li>\n<li>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>  调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</li>\n<li>578行:【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);<br>  赋值之前:<ul>\n<li>拿到InstantiationAwareBeanPostProcessor后置处理器;<br>  1305行:postProcessAfterInstantiation();</li>\n<li>拿到InstantiationAwareBeanPostProcessor后置处理器;<br>  1348行:postProcessPropertyValues();<br>=====赋值之前:===</li>\n<li>应用Bean属性的值;为属性利用setter方法等进行赋值;<br>  applyPropertyValues(beanName, mbd, bw, pvs);</li>\n</ul>\n</li>\n<li>【Bean初始化】initializeBean(beanName, exposedObject, mbd);<ul>\n<li>1693行:【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法<br>  BeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware</li>\n<li>1698行:【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>  BeanPostProcessor.postProcessBeforeInitialization（）;</li>\n<li>1702行:【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);<ul>\n<li>是否是InitializingBean接口的实现;执行接口规定的初始化;</li>\n<li>是否自定义初始化方法;</li>\n</ul>\n</li>\n<li>1710行:【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization<br>  BeanPostProcessor.postProcessAfterInitialization();</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>将创建的Bean添加到缓存中singletonObjects;sharedInstance = getSingleton(beanName, ()跟进去<br>   254行:addSingleton（）,放到MAP中<br>ioc容器就是这些Map;很多的Map里面保存了单实例Bean,环境信息。。。。;<br>所有Bean都利用getBean创建完成以后;<br>检查所有的Bean是否是SmartInitializingSingleton接口的;如果是;就执行afterSingletonsInstantiated();</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>finishRefresh() 完成BeanFactory的初始化创建工作,IOC容器就创建完成</p>\n<ul>\n<li><p>882行:initLifecycleProcessor() 初始化和生命周期有关的后置处理器:LifecycleProcessor,默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】;如果没有new DefaultLifecycleProcessor()加入到容器;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自己也可以尝试写一个LifecycleProcessor的实现类,可以在BeanFactory</span><br><span class=\"line\">\tvoid onRefresh();</span><br><span class=\"line\">\tvoid onClose();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>885行:getLifecycleProcessor().onRefresh() 拿到前面定义的生命周期处理器（BeanFactory） 回调onRefresh()</p>\n</li>\n<li>888行:publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件;</li>\n<li>891行:liveBeansView.registerApplicationContext(this);</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>IOC源码分析</p>\n<h3 id=\"IOC流程\"><a href=\"#IOC流程\" class=\"headerlink\" title=\"IOC流程\"></a>IOC流程</h3><h4 id=\"IOC源码入口\"><a href=\"#IOC源码入口\" class=\"headerlink\" title=\"IOC源码入口\"></a>IOC源码入口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Spring启动入口</span></span><br><span class=\"line\">AnnotationConfigApplicationContext app = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(Cap12MainConfig.class);</span><br><span class=\"line\">app.close();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Spring容器的refresh()【创建刷新】</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class=\"line\">       Object var1 = <span class=\"keyword\">this</span>.startupShutdownMonitor;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.prepareRefresh();</span><br><span class=\"line\">           ConfigurableListableBeanFactory beanFactory = <span class=\"keyword\">this</span>.obtainFreshBeanFactory();</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.initMessageSource();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.initApplicationEventMulticaster();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.onRefresh();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.registerListeners();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.finishRefresh();</span><br><span class=\"line\">           &#125; <span class=\"keyword\">catch</span> (BeansException var9) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">this</span>.logger.warn(<span class=\"string\">\"Exception encountered during context initialization - cancelling refresh attempt: \"</span> + var9);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">this</span>.destroyBeans();</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.cancelRefresh(var9);</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> var9;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">               <span class=\"keyword\">this</span>.resetCommonCaches();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"IOC流程详解\"><a href=\"#IOC流程详解\" class=\"headerlink\" title=\"IOC流程详解\"></a>IOC流程详解</h4><p>Spring容器的refresh()【创建刷新】;</p>\n<ul>\n<li><p>prepareRefresh() 刷新前的预处理</p>\n<ul>\n<li>initPropertySources() 初始化一些属性设置;子类自定义个性化的属性设置方法</li>\n<li>getEnvironment().validateRequiredProperties() 检验属性的合法等</li>\n<li>earlyApplicationEvents= new LinkedHashSet<applicationevent>() 保存容器中的一些早期的事件</applicationevent></li>\n</ul>\n</li>\n<li><p>obtainFreshBeanFactory() 获取BeanFactory</p>\n<ul>\n<li>refreshBeanFactory();刷新【创建】BeanFactory;110行:创建了一个this.beanFactory = new DefaultListableBeanFactory();设置id;</li>\n<li>getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象;</li>\n<li>将创建的BeanFactory【DefaultListableBeanFactory】返回;</li>\n</ul>\n</li>\n<li><p>prepareBeanFactory(beanFactory) BeanFactory的预准备工作（以上创建了beanFactory,现在对BeanFactory对象进行一些设置属性）</p>\n<ul>\n<li>设置BeanFactory的类加载器、支持表达式解析器…</li>\n<li>添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</li>\n<li>设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx;</li>\n<li>注册可以解析的自动装配;我们能直接在任何组件中自动注入:BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</li>\n<li>添加BeanPostProcessor【ApplicationListenerDetector】</li>\n<li>添加编译时的AspectJ;</li>\n<li>给BeanFactory中注册一些能用的组件;<br>  environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</li>\n</ul>\n</li>\n<li><p>postProcessBeanFactory(beanFactory) BeanFactory准备工作完成后进行的后置处理工作</p>\n<ul>\n<li>子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上是BeanFactory的创建及预准备工作</p>\n</blockquote>\n<hr>\n<ul>\n<li><p>invokeBeanFactoryPostProcessors(beanFactory) 执行BeanFactoryPostProcessor的方法</p>\n<blockquote>\n<p>BeanFactoryPostProcessor:BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的,两个接口:BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</p>\n</blockquote>\n<ul>\n<li>执行BeanFactoryPostProcessor的方法<br>  先执行BeanDefinitionRegistryPostProcessor<ul>\n<li>83行:获取所有的BeanDefinitionRegistryPostProcessor;</li>\n<li>86行:看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、<br>  postProcessor.postProcessBeanDefinitionRegistry(registry)</li>\n<li>99行:在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor;<br>  postProcessor.postProcessBeanDefinitionRegistry(registry)</li>\n<li>109行:最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors;<br>  postProcessor.postProcessBeanDefinitionRegistry(registry)</li>\n</ul>\n</li>\n<li>再执行BeanFactoryPostProcessor的方法<ul>\n<li>139行:获取所有的BeanFactoryPostProcessor</li>\n<li>147行:看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、<br>  postProcessor.postProcessBeanFactory()</li>\n<li>167行:在执行实现了Ordered顺序接口的BeanFactoryPostProcessor;<br>  postProcessor.postProcessBeanFactory()</li>\n<li>175行:最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor;<br>  postProcessor.postProcessBeanFactory()</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>registerBeanPostProcessors(beanFactory) 注册BeanPostProcessor（Bean的后置处理器）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不同接口类型的BeanPostProcessor;在Bean创建前后的执行时机是不一样的</span><br><span class=\"line\">BeanPostProcessor、</span><br><span class=\"line\">DestructionAwareBeanPostProcessor、</span><br><span class=\"line\">InstantiationAwareBeanPostProcessor、</span><br><span class=\"line\">SmartInstantiationAwareBeanPostProcessor、</span><br><span class=\"line\">MergedBeanDefinitionPostProcessor【internalPostProcessors】</span><br></pre></td></tr></table></figure>\n<ul>\n<li>189行:获取所有的BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级</li>\n<li>204行:先注册PriorityOrdered优先级接口的BeanPostProcessor,把每一个BeanPostProcessor添加到BeanFactory中,beanFactory.addBeanPostProcessor(postProcessor);</li>\n<li>224行:再注册Ordered接口的</li>\n<li>236行:最后注册没有实现任何优先级接口的</li>\n<li>最终注册MergedBeanDefinitionPostProcessor;</li>\n<li>注册一个ApplicationListenerDetector;来在Bean创建完成后检查是否是ApplicationListener,如果是:applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>initMessageSource() 初始化MessageSource组件（做国际化功能;消息绑定,消息解析）</p>\n<ul>\n<li>718行:获取BeanFactory</li>\n<li>719行:看容器中是否有id为messageSource的,类型是MessageSource的组件,如果有赋值给messageSource,如果没有自己创建一个DelegatingMessageSource;MessageSource:取出国际化配置文件中的某个key的值,能按照区域信息获取</li>\n<li><p>739行:把创建好的MessageSource注册在容器中,以后获取国际化配置文件的值的时候,可以自动注入MessageSource;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class=\"keyword\">this</span>.messageSource);\t</span><br><span class=\"line\">MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);</span><br><span class=\"line\"><span class=\"comment\">//以后可通过getMessage获取</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>initApplicationEventMulticaster() 初始化事件派发器</p>\n<ul>\n<li>753行:获取BeanFactory</li>\n<li>754行:从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster</li>\n<li>762行:如果上一步没有配置;创建一个SimpleApplicationEventMulticaster</li>\n<li>763行:将创建的ApplicationEventMulticaster添加到BeanFactory中,以后其他组件直接自动注入</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>onRefresh() 留给子容器（子类）</p>\n<ul>\n<li>子类重写这个方法,在容器刷新的时候可以自定义逻辑;</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>registerListeners() 给容器中将所有项目里面的ApplicationListener注册进来</p>\n<ul>\n<li>822行:从容器中拿到所有的ApplicationListener</li>\n<li><p>824行:将每个监听器添加到事件派发器中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>832行:派发之前步骤产生的事件;</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>finishBeanFactoryInitialization(beanFactory) 初始化所有剩下的单实例bean </p>\n<ul>\n<li><p>867行:beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean,跟进</p>\n<ul>\n<li>734行:获取容器中的所有Bean,依次进行初始化和创建对象</li>\n<li>738行:获取Bean的定义信息;RootBeanDefinition</li>\n<li><p>739行:Bean不是抽象的,是单实例的,是懒加载;</p>\n<ul>\n<li>740行:判断是否是FactoryBean;是否是实现FactoryBean接口的Bean;</li>\n<li><p>760行:不是工厂Bean。利用getBean(beanName);创建对象</p>\n<ul>\n<li>199行:getBean(beanName); ioc.getBean();</li>\n<li>doGetBean(name, null, null, false);</li>\n<li><p>246行: getSingleton(beanName)先获取缓存中保存的单实例Bean《跟进去其实就是从MAP中拿》。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从这个中获取的</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">256</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>缓存中获取不到,开始Bean的创建对象流程;</p>\n</li>\n<li>287行:标记当前bean已经被创建（防止多线程同时创建,使用synchronized）</li>\n<li>291行:获取Bean的定义信息;</li>\n<li>295行:getDependsOn(),bean.xml里创建person时,加depend-on=”jeep,moon”是先把jeep和moon创建出来,【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来;】</li>\n<li><p>启动单实例Bean的创建流程;</p>\n<ul>\n<li>462行:createBean(beanName, mbd, args);</li>\n<li>490行:Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象;<br>  【InstantiationAwareBeanPostProcessor】:提前执行;<br>  先触发:postProcessBeforeInstantiation();<br>  如果有返回值:触发postProcessAfterInitialization();</li>\n<li>如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象;调用下面</li>\n<li><p>501行:Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</p>\n<ul>\n<li>541行:【创建Bean实例】;createBeanInstance(beanName, mbd, args);<br>  利用工厂方法或者对象的构造器创建出Bean实例;</li>\n<li>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>  调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</li>\n<li>578行:【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);<br>  赋值之前:<ul>\n<li>拿到InstantiationAwareBeanPostProcessor后置处理器;<br>  1305行:postProcessAfterInstantiation();</li>\n<li>拿到InstantiationAwareBeanPostProcessor后置处理器;<br>  1348行:postProcessPropertyValues();<br>=====赋值之前:===</li>\n<li>应用Bean属性的值;为属性利用setter方法等进行赋值;<br>  applyPropertyValues(beanName, mbd, bw, pvs);</li>\n</ul>\n</li>\n<li>【Bean初始化】initializeBean(beanName, exposedObject, mbd);<ul>\n<li>1693行:【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法<br>  BeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware</li>\n<li>1698行:【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>  BeanPostProcessor.postProcessBeforeInitialization（）;</li>\n<li>1702行:【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);<ul>\n<li>是否是InitializingBean接口的实现;执行接口规定的初始化;</li>\n<li>是否自定义初始化方法;</li>\n</ul>\n</li>\n<li>1710行:【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization<br>  BeanPostProcessor.postProcessAfterInitialization();</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>将创建的Bean添加到缓存中singletonObjects;sharedInstance = getSingleton(beanName, ()跟进去<br>   254行:addSingleton（）,放到MAP中<br>ioc容器就是这些Map;很多的Map里面保存了单实例Bean,环境信息。。。。;<br>所有Bean都利用getBean创建完成以后;<br>检查所有的Bean是否是SmartInitializingSingleton接口的;如果是;就执行afterSingletonsInstantiated();</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>finishRefresh() 完成BeanFactory的初始化创建工作,IOC容器就创建完成</p>\n<ul>\n<li><p>882行:initLifecycleProcessor() 初始化和生命周期有关的后置处理器:LifecycleProcessor,默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】;如果没有new DefaultLifecycleProcessor()加入到容器;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自己也可以尝试写一个LifecycleProcessor的实现类,可以在BeanFactory</span><br><span class=\"line\">\tvoid onRefresh();</span><br><span class=\"line\">\tvoid onClose();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>885行:getLifecycleProcessor().onRefresh() 拿到前面定义的生命周期处理器（BeanFactory） 回调onRefresh()</p>\n</li>\n<li>888行:publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件;</li>\n<li>891行:liveBeansView.registerApplicationContext(this);</li>\n</ul>\n</li>\n</ul>"},{"title":"Spring学习04 - BeanPostProcessor源码分析","_content":"\nspring基础学习\n\n### 容器启动及BeanPostProcessor源码分析\n\nBeanPostProcessor原理:\n可从容器类跟进顺序为:\n```\nAnnotationConfigApplicationContext-->refresh()-->\nfinishBeanFactoryInitialization(beanFactory)--->\nbeanFactory.preInstantiateSingletons()-->\n760行getBean(beanName)--->\n199行doGetBean(name, null, null, false)-->\n317行createBean(beanName, mbd, args)-->\n501行doCreateBean(beanName, mbdToUse, args)-->\n541行createBeanInstance(beanName, mbd, args)(完成bean创建)-->\n578行populateBean(beanName, mbd, instanceWrapper)(属性赋值)-->\n579行initializeBean(beanName, exposedObject, mbd)(Bean初始化)->\n1069行到1710行,后置处理器完成对init方法的前后处理.\n```\n\ninitializeBean方法 对方法前后做处理\n```java\n{\n  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n  invokeInitMethods(beanName, wrappedBean, mbd) //执行自定义初始化\n  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)\n}\n```\n\n\n\n\n\n\n\n\n","source":"_posts/spring-04.md","raw":"---\ntitle: Spring学习04 - BeanPostProcessor源码分析\ntags:\n  - Java\n  - Spring\n---\n\nspring基础学习\n\n### 容器启动及BeanPostProcessor源码分析\n\nBeanPostProcessor原理:\n可从容器类跟进顺序为:\n```\nAnnotationConfigApplicationContext-->refresh()-->\nfinishBeanFactoryInitialization(beanFactory)--->\nbeanFactory.preInstantiateSingletons()-->\n760行getBean(beanName)--->\n199行doGetBean(name, null, null, false)-->\n317行createBean(beanName, mbd, args)-->\n501行doCreateBean(beanName, mbdToUse, args)-->\n541行createBeanInstance(beanName, mbd, args)(完成bean创建)-->\n578行populateBean(beanName, mbd, instanceWrapper)(属性赋值)-->\n579行initializeBean(beanName, exposedObject, mbd)(Bean初始化)->\n1069行到1710行,后置处理器完成对init方法的前后处理.\n```\n\ninitializeBean方法 对方法前后做处理\n```java\n{\n  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n  invokeInitMethods(beanName, wrappedBean, mbd) //执行自定义初始化\n  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)\n}\n```\n\n\n\n\n\n\n\n\n","slug":"spring-04","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15b100249gj7t98ywvlh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>spring基础学习</p>\n<h3 id=\"容器启动及BeanPostProcessor源码分析\"><a href=\"#容器启动及BeanPostProcessor源码分析\" class=\"headerlink\" title=\"容器启动及BeanPostProcessor源码分析\"></a>容器启动及BeanPostProcessor源码分析</h3><p>BeanPostProcessor原理:<br>可从容器类跟进顺序为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnnotationConfigApplicationContext--&gt;refresh()--&gt;</span><br><span class=\"line\">finishBeanFactoryInitialization(beanFactory)---&gt;</span><br><span class=\"line\">beanFactory.preInstantiateSingletons()--&gt;</span><br><span class=\"line\">760行getBean(beanName)---&gt;</span><br><span class=\"line\">199行doGetBean(name, null, null, false)--&gt;</span><br><span class=\"line\">317行createBean(beanName, mbd, args)--&gt;</span><br><span class=\"line\">501行doCreateBean(beanName, mbdToUse, args)--&gt;</span><br><span class=\"line\">541行createBeanInstance(beanName, mbd, args)(完成bean创建)--&gt;</span><br><span class=\"line\">578行populateBean(beanName, mbd, instanceWrapper)(属性赋值)--&gt;</span><br><span class=\"line\">579行initializeBean(beanName, exposedObject, mbd)(Bean初始化)-&gt;</span><br><span class=\"line\">1069行到1710行,后置处理器完成对init方法的前后处理.</span><br></pre></td></tr></table></figure></p>\n<p>initializeBean方法 对方法前后做处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">  invokeInitMethods(beanName, wrappedBean, mbd) <span class=\"comment\">//执行自定义初始化</span></span><br><span class=\"line\">  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>spring基础学习</p>\n<h3 id=\"容器启动及BeanPostProcessor源码分析\"><a href=\"#容器启动及BeanPostProcessor源码分析\" class=\"headerlink\" title=\"容器启动及BeanPostProcessor源码分析\"></a>容器启动及BeanPostProcessor源码分析</h3><p>BeanPostProcessor原理:<br>可从容器类跟进顺序为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnnotationConfigApplicationContext--&gt;refresh()--&gt;</span><br><span class=\"line\">finishBeanFactoryInitialization(beanFactory)---&gt;</span><br><span class=\"line\">beanFactory.preInstantiateSingletons()--&gt;</span><br><span class=\"line\">760行getBean(beanName)---&gt;</span><br><span class=\"line\">199行doGetBean(name, null, null, false)--&gt;</span><br><span class=\"line\">317行createBean(beanName, mbd, args)--&gt;</span><br><span class=\"line\">501行doCreateBean(beanName, mbdToUse, args)--&gt;</span><br><span class=\"line\">541行createBeanInstance(beanName, mbd, args)(完成bean创建)--&gt;</span><br><span class=\"line\">578行populateBean(beanName, mbd, instanceWrapper)(属性赋值)--&gt;</span><br><span class=\"line\">579行initializeBean(beanName, exposedObject, mbd)(Bean初始化)-&gt;</span><br><span class=\"line\">1069行到1710行,后置处理器完成对init方法的前后处理.</span><br></pre></td></tr></table></figure></p>\n<p>initializeBean方法 对方法前后做处理<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=\"line\">  invokeInitMethods(beanName, wrappedBean, mbd) <span class=\"comment\">//执行自定义初始化</span></span><br><span class=\"line\">  applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"SpringBoot自动配置","_content":"\nSpringBoot自动配置\n\n### SpringBoot自动配置\n\n\n入口：\n\n```java\n@SpringBootApplication\npublic class StudyApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(StudyApplication.class, args);\n    }\n\n}\n```\n\n<!-- more -->\n\n@SpringBootApplication:\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n    ...\n}\n```\n\n@EnableAutoConfiguration:\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    ...\n}\n```\n\nAutoConfigurationImportSelector:\n\n```java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n    Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n    return configurations;\n}\n```\n\n\n查看META-INF/spring.factories：\n\n```java\n...\n# Auto Configuration Import Filters\norg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\\norg.springframework.boot.autoconfigure.condition.OnBeanCondition,\\\norg.springframework.boot.autoconfigure.condition.OnClassCondition,\\\norg.springframework.boot.autoconfigure.condition.OnWebApplicationCondition\n\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\n...\n```\n\n查看其中的一个类org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration：\n\n```java\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnClass({RabbitTemplate.class, Channel.class})\n@EnableConfigurationProperties({RabbitProperties.class})\n@Import({RabbitAnnotationDrivenConfiguration.class})\npublic class RabbitAutoConfiguration {\n    .....\n}\n```\n\n查看RabbitProperties 即会配置相关spring.rabbitmq开头的配置：\n\n```java\n@ConfigurationProperties(\n    prefix = \"spring.rabbitmq\"\n)\npublic class RabbitProperties {\n    private static final int DEFAULT_PORT = 5672;\n    private static final int DEFAULT_PORT_SECURE = 5671;\n    private String host = \"localhost\";\n    private Integer port;\n    private String username = \"guest\";\n    private String password = \"guest\";\n    private final RabbitProperties.Ssl ssl = new RabbitProperties.Ssl();\n    private String virtualHost;\n    private String addresses;\n    @DurationUnit(ChronoUnit.SECONDS)\n    private Duration requestedHeartbeat;\n    private int requestedChannelMax = 2047;\n    private boolean publisherReturns;\n    private ConfirmType publisherConfirmType;\n    private Duration connectionTimeout;\n    private final RabbitProperties.Cache cache = new RabbitProperties.Cache();\n    private final RabbitProperties.Listener listener = new RabbitProperties.Listener();\n    private final RabbitProperties.Template template = new RabbitProperties.Template();\n    private List<RabbitProperties.Address> parsedAddresses;\n    ....\n}\n```\n\n\n\n\n\n#### 条件注解\n\n```java\n@ConditionalOnBean：当容器里有指定的bean的条件下。\n\n@ConditionalOnMissingBean：当容器里不存在指定bean的条件下。\n\n@ConditionalOnClass：当类路径下有指定类的条件下。\n\n@ConditionalOnMissingClass：当类路径下不存在指定类的条件下。\n\n@ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix=”xxx.xxx”, value=”enable”, matchIfMissing=true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。\n```\n\n#### 自动配置流程\n\nSpring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。\n\n","source":"_posts/spring-springboot自动配置.md","raw":"---\ntitle: SpringBoot自动配置\ntags:\n  - Java\n  - Spring\n  - SpringBoot\n---\n\nSpringBoot自动配置\n\n### SpringBoot自动配置\n\n\n入口：\n\n```java\n@SpringBootApplication\npublic class StudyApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(StudyApplication.class, args);\n    }\n\n}\n```\n\n<!-- more -->\n\n@SpringBootApplication:\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n    ...\n}\n```\n\n@EnableAutoConfiguration:\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    ...\n}\n```\n\nAutoConfigurationImportSelector:\n\n```java\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n    Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n    return configurations;\n}\n```\n\n\n查看META-INF/spring.factories：\n\n```java\n...\n# Auto Configuration Import Filters\norg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\\norg.springframework.boot.autoconfigure.condition.OnBeanCondition,\\\norg.springframework.boot.autoconfigure.condition.OnClassCondition,\\\norg.springframework.boot.autoconfigure.condition.OnWebApplicationCondition\n\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\n...\n```\n\n查看其中的一个类org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration：\n\n```java\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnClass({RabbitTemplate.class, Channel.class})\n@EnableConfigurationProperties({RabbitProperties.class})\n@Import({RabbitAnnotationDrivenConfiguration.class})\npublic class RabbitAutoConfiguration {\n    .....\n}\n```\n\n查看RabbitProperties 即会配置相关spring.rabbitmq开头的配置：\n\n```java\n@ConfigurationProperties(\n    prefix = \"spring.rabbitmq\"\n)\npublic class RabbitProperties {\n    private static final int DEFAULT_PORT = 5672;\n    private static final int DEFAULT_PORT_SECURE = 5671;\n    private String host = \"localhost\";\n    private Integer port;\n    private String username = \"guest\";\n    private String password = \"guest\";\n    private final RabbitProperties.Ssl ssl = new RabbitProperties.Ssl();\n    private String virtualHost;\n    private String addresses;\n    @DurationUnit(ChronoUnit.SECONDS)\n    private Duration requestedHeartbeat;\n    private int requestedChannelMax = 2047;\n    private boolean publisherReturns;\n    private ConfirmType publisherConfirmType;\n    private Duration connectionTimeout;\n    private final RabbitProperties.Cache cache = new RabbitProperties.Cache();\n    private final RabbitProperties.Listener listener = new RabbitProperties.Listener();\n    private final RabbitProperties.Template template = new RabbitProperties.Template();\n    private List<RabbitProperties.Address> parsedAddresses;\n    ....\n}\n```\n\n\n\n\n\n#### 条件注解\n\n```java\n@ConditionalOnBean：当容器里有指定的bean的条件下。\n\n@ConditionalOnMissingBean：当容器里不存在指定bean的条件下。\n\n@ConditionalOnClass：当类路径下有指定类的条件下。\n\n@ConditionalOnMissingClass：当类路径下不存在指定类的条件下。\n\n@ConditionalOnProperty：指定的属性是否有指定的值，比如@ConditionalOnProperties(prefix=”xxx.xxx”, value=”enable”, matchIfMissing=true)，代表当xxx.xxx为enable时条件的布尔值为true，如果没有设置的情况下也为true。\n```\n\n#### 自动配置流程\n\nSpring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。\n\n","slug":"spring-springboot自动配置","published":1,"date":"2025-02-12T08:28:16.465Z","updated":"2025-02-12T08:28:16.465Z","_id":"clhua15b200269gj7zi340dtx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>SpringBoot自动配置</p>\n<h3 id=\"SpringBoot自动配置\"><a href=\"#SpringBoot自动配置\" class=\"headerlink\" title=\"SpringBoot自动配置\"></a>SpringBoot自动配置</h3><p>入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudyApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(StudyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>@SpringBootApplication:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(</span><br><span class=\"line\">    excludeFilters = &#123;<span class=\"meta\">@Filter</span>(</span><br><span class=\"line\">    type = FilterType.CUSTOM,</span><br><span class=\"line\">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class=\"line\">), <span class=\"meta\">@Filter</span>(</span><br><span class=\"line\">    type = FilterType.CUSTOM,</span><br><span class=\"line\">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@EnableAutoConfiguration:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AutoConfigurationImportSelector:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class=\"keyword\">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class=\"keyword\">this</span>.getBeanClassLoader());</span><br><span class=\"line\">    Assert.notEmpty(configurations, <span class=\"string\">\"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看META-INF/spring.factories：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># Auto Configuration Import Filters</span><br><span class=\"line\">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnClassCondition,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class=\"line\"></span><br><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>查看其中的一个类org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>(</span><br><span class=\"line\">    proxyBeanMethods = <span class=\"keyword\">false</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>(&#123;RabbitTemplate.class, Channel.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span>(&#123;RabbitProperties.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;RabbitAnnotationDrivenConfiguration.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看RabbitProperties 即会配置相关spring.rabbitmq开头的配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(</span><br><span class=\"line\">    prefix = <span class=\"string\">\"spring.rabbitmq\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitProperties</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT = <span class=\"number\">5672</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT_SECURE = <span class=\"number\">5671</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username = <span class=\"string\">\"guest\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password = <span class=\"string\">\"guest\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Ssl ssl = <span class=\"keyword\">new</span> RabbitProperties.Ssl();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String virtualHost;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String addresses;</span><br><span class=\"line\">    <span class=\"meta\">@DurationUnit</span>(ChronoUnit.SECONDS)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration requestedHeartbeat;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> requestedChannelMax = <span class=\"number\">2047</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> publisherReturns;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConfirmType publisherConfirmType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration connectionTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Cache cache = <span class=\"keyword\">new</span> RabbitProperties.Cache();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Listener listener = <span class=\"keyword\">new</span> RabbitProperties.Listener();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Template template = <span class=\"keyword\">new</span> RabbitProperties.Template();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RabbitProperties.Address&gt; parsedAddresses;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConditionalOnBean</span>：当容器里有指定的bean的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span>：当容器里不存在指定bean的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>：当类路径下有指定类的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingClass</span>：当类路径下不存在指定类的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty</span>：指定的属性是否有指定的值，比如<span class=\"meta\">@ConditionalOnProperties</span>(prefix=”xxx.xxx”, value=”enable”, matchIfMissing=<span class=\"keyword\">true</span>)，代表当xxx.xxx为enable时条件的布尔值为<span class=\"keyword\">true</span>，如果没有设置的情况下也为<span class=\"keyword\">true</span>。</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动配置流程\"><a href=\"#自动配置流程\" class=\"headerlink\" title=\"自动配置流程\"></a>自动配置流程</h4><p>Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p>\n","site":{"data":{}},"excerpt":"<p>SpringBoot自动配置</p>\n<h3 id=\"SpringBoot自动配置\"><a href=\"#SpringBoot自动配置\" class=\"headerlink\" title=\"SpringBoot自动配置\"></a>SpringBoot自动配置</h3><p>入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudyApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(StudyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>@SpringBootApplication:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(</span><br><span class=\"line\">    excludeFilters = &#123;<span class=\"meta\">@Filter</span>(</span><br><span class=\"line\">    type = FilterType.CUSTOM,</span><br><span class=\"line\">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class=\"line\">), <span class=\"meta\">@Filter</span>(</span><br><span class=\"line\">    type = FilterType.CUSTOM,</span><br><span class=\"line\">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class=\"line\">)&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>@EnableAutoConfiguration:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AutoConfigurationImportSelector:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class=\"keyword\">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class=\"keyword\">this</span>.getBeanClassLoader());</span><br><span class=\"line\">    Assert.notEmpty(configurations, <span class=\"string\">\"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看META-INF/spring.factories：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"># Auto Configuration Import Filters</span><br><span class=\"line\">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnClassCondition,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class=\"line\"></span><br><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>查看其中的一个类org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>(</span><br><span class=\"line\">    proxyBeanMethods = <span class=\"keyword\">false</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>(&#123;RabbitTemplate.class, Channel.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span>(&#123;RabbitProperties.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;RabbitAnnotationDrivenConfiguration.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看RabbitProperties 即会配置相关spring.rabbitmq开头的配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(</span><br><span class=\"line\">    prefix = <span class=\"string\">\"spring.rabbitmq\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitProperties</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT = <span class=\"number\">5672</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_PORT_SECURE = <span class=\"number\">5671</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username = <span class=\"string\">\"guest\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password = <span class=\"string\">\"guest\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Ssl ssl = <span class=\"keyword\">new</span> RabbitProperties.Ssl();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String virtualHost;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String addresses;</span><br><span class=\"line\">    <span class=\"meta\">@DurationUnit</span>(ChronoUnit.SECONDS)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration requestedHeartbeat;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> requestedChannelMax = <span class=\"number\">2047</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> publisherReturns;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConfirmType publisherConfirmType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration connectionTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Cache cache = <span class=\"keyword\">new</span> RabbitProperties.Cache();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Listener listener = <span class=\"keyword\">new</span> RabbitProperties.Listener();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> RabbitProperties.Template template = <span class=\"keyword\">new</span> RabbitProperties.Template();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;RabbitProperties.Address&gt; parsedAddresses;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"条件注解\"><a href=\"#条件注解\" class=\"headerlink\" title=\"条件注解\"></a>条件注解</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConditionalOnBean</span>：当容器里有指定的bean的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span>：当容器里不存在指定bean的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>：当类路径下有指定类的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingClass</span>：当类路径下不存在指定类的条件下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty</span>：指定的属性是否有指定的值，比如<span class=\"meta\">@ConditionalOnProperties</span>(prefix=”xxx.xxx”, value=”enable”, matchIfMissing=<span class=\"keyword\">true</span>)，代表当xxx.xxx为enable时条件的布尔值为<span class=\"keyword\">true</span>，如果没有设置的情况下也为<span class=\"keyword\">true</span>。</span><br></pre></td></tr></table></figure>\n<h4 id=\"自动配置流程\"><a href=\"#自动配置流程\" class=\"headerlink\" title=\"自动配置流程\"></a>自动配置流程</h4><p>Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p>"},{"title":"Zookeeper应用(服务注册与发现/分布式锁/Master选举/配置中心)","_content":"\n#### 服务注册与发现\n\n注册：\n\n> 服务启动时 在某一个节点下新建一个临时顺序节点将ip+端口保存\n\n```java\n\npublic static  void register(String address,int port) {\n        try {\n            ZooKeeper zooKeeper = new ZooKeeper(\"localhost:2181\",5000,(watchedEvent)->{});\n            logger.warn(\"连接zk\");\n            Stat exists = zooKeeper.exists(BASE_SERVICES + SERVICE_NAME, false);\n            logger.warn(\"判断是否存在\" + exists);\n            if(exists==null) {\n                logger.warn(\"创建路径\" );\n                zooKeeper.create(BASE_SERVICES,\"\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n                zooKeeper.create(BASE_SERVICES + SERVICE_NAME,\"\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            }\n            String server_path = address+\":\"+port;\n            logger.warn(\"server_path:\" + server_path);\n            zooKeeper.create(BASE_SERVICES + SERVICE_NAME+\"/child\",server_path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);\n            logger.warn(\"保存成功\" );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n发现：\n\n> 监听某一个节点，当子节点发生变化时更新ip列表，请求时从列表中获取ip+端口\n\n```java\nprivate void updateServiceList() {\n       try{\n\n           logger.warn(\"ip 改变 开始更新ip地址\");\n           List<String> children = zooKeeper.getChildren(BASE_SERVICES  + SERVICE_NAME, true);\n           List<String> newServerList = new ArrayList<String>();\n           for(String subNode:children) {\n               byte[] data = zooKeeper.getData(BASE_SERVICES  + SERVICE_NAME + \"/\" + subNode, false, null);\n               String host = new String(data, \"utf-8\");\n               System.out.println(\"host:\"+host);\n               newServerList.add(host);\n           }\n           LoadBalance.SERVICE_LIST = newServerList;\n       }catch (Exception e) {\n           e.printStackTrace();\n       }\n    }\n```\n<!-- more --> \n\n#### 分布式锁\n\n- 基于同名节点的分布式锁\n\n思想：都创建同一个临时节点，成功获得锁，失败等待\n\n![分布式锁](http://image.tupelo.top/%E4%B8%B4%E6%97%B6.png)\n\n- 高性能分布式锁\n\n思想：创建临时顺序节点 若为最小节点，获得锁，否则监听上一个节点是否被删除\n\n![分布式锁](http://image.tupelo.top/%E6%80%A7%E8%83%BD.png)\n \n\n#### 自动选举\n\n思想：监听某一个节点，当节点被删除时，创建临时节点写入自己的信息，成功则自己为master节点，否则获取该节点信息为master信息，监听该节点。\n\n\n#### 数据发布与订阅（配置中心）\n\n思想：直接监听某一个节点，当节点内容有修改是，直接修改配置。\n\n\n\n\n\n","source":"_posts/zookeeper应用.md","raw":"---\ntitle: Zookeeper应用(服务注册与发现/分布式锁/Master选举/配置中心)\ntags:\n  - zookeeper\n---\n\n#### 服务注册与发现\n\n注册：\n\n> 服务启动时 在某一个节点下新建一个临时顺序节点将ip+端口保存\n\n```java\n\npublic static  void register(String address,int port) {\n        try {\n            ZooKeeper zooKeeper = new ZooKeeper(\"localhost:2181\",5000,(watchedEvent)->{});\n            logger.warn(\"连接zk\");\n            Stat exists = zooKeeper.exists(BASE_SERVICES + SERVICE_NAME, false);\n            logger.warn(\"判断是否存在\" + exists);\n            if(exists==null) {\n                logger.warn(\"创建路径\" );\n                zooKeeper.create(BASE_SERVICES,\"\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n                zooKeeper.create(BASE_SERVICES + SERVICE_NAME,\"\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            }\n            String server_path = address+\":\"+port;\n            logger.warn(\"server_path:\" + server_path);\n            zooKeeper.create(BASE_SERVICES + SERVICE_NAME+\"/child\",server_path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);\n            logger.warn(\"保存成功\" );\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n发现：\n\n> 监听某一个节点，当子节点发生变化时更新ip列表，请求时从列表中获取ip+端口\n\n```java\nprivate void updateServiceList() {\n       try{\n\n           logger.warn(\"ip 改变 开始更新ip地址\");\n           List<String> children = zooKeeper.getChildren(BASE_SERVICES  + SERVICE_NAME, true);\n           List<String> newServerList = new ArrayList<String>();\n           for(String subNode:children) {\n               byte[] data = zooKeeper.getData(BASE_SERVICES  + SERVICE_NAME + \"/\" + subNode, false, null);\n               String host = new String(data, \"utf-8\");\n               System.out.println(\"host:\"+host);\n               newServerList.add(host);\n           }\n           LoadBalance.SERVICE_LIST = newServerList;\n       }catch (Exception e) {\n           e.printStackTrace();\n       }\n    }\n```\n<!-- more --> \n\n#### 分布式锁\n\n- 基于同名节点的分布式锁\n\n思想：都创建同一个临时节点，成功获得锁，失败等待\n\n![分布式锁](http://image.tupelo.top/%E4%B8%B4%E6%97%B6.png)\n\n- 高性能分布式锁\n\n思想：创建临时顺序节点 若为最小节点，获得锁，否则监听上一个节点是否被删除\n\n![分布式锁](http://image.tupelo.top/%E6%80%A7%E8%83%BD.png)\n \n\n#### 自动选举\n\n思想：监听某一个节点，当节点被删除时，创建临时节点写入自己的信息，成功则自己为master节点，否则获取该节点信息为master信息，监听该节点。\n\n\n#### 数据发布与订阅（配置中心）\n\n思想：直接监听某一个节点，当节点内容有修改是，直接修改配置。\n\n\n\n\n\n","slug":"zookeeper应用","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15b300289gj7jtd1gg0j","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h4><p>注册：</p>\n<blockquote>\n<p>服务启动时 在某一个节点下新建一个临时顺序节点将ip+端口保存</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(String address,<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ZooKeeper zooKeeper = <span class=\"keyword\">new</span> ZooKeeper(<span class=\"string\">\"localhost:2181\"</span>,<span class=\"number\">5000</span>,(watchedEvent)-&gt;&#123;&#125;);</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"连接zk\"</span>);</span><br><span class=\"line\">            Stat exists = zooKeeper.exists(BASE_SERVICES + SERVICE_NAME, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"判断是否存在\"</span> + exists);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(exists==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"创建路径\"</span> );</span><br><span class=\"line\">                zooKeeper.create(BASE_SERVICES,<span class=\"string\">\"\"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class=\"line\">                zooKeeper.create(BASE_SERVICES + SERVICE_NAME,<span class=\"string\">\"\"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String server_path = address+<span class=\"string\">\":\"</span>+port;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"server_path:\"</span> + server_path);</span><br><span class=\"line\">            zooKeeper.create(BASE_SERVICES + SERVICE_NAME+<span class=\"string\">\"/child\"</span>,server_path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"保存成功\"</span> );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>发现：</p>\n<blockquote>\n<p>监听某一个节点，当子节点发生变化时更新ip列表，请求时从列表中获取ip+端口</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateServiceList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           logger.warn(<span class=\"string\">\"ip 改变 开始更新ip地址\"</span>);</span><br><span class=\"line\">           List&lt;String&gt; children = zooKeeper.getChildren(BASE_SERVICES  + SERVICE_NAME, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">           List&lt;String&gt; newServerList = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(String subNode:children) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">byte</span>[] data = zooKeeper.getData(BASE_SERVICES  + SERVICE_NAME + <span class=\"string\">\"/\"</span> + subNode, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">               String host = <span class=\"keyword\">new</span> String(data, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"host:\"</span>+host);</span><br><span class=\"line\">               newServerList.add(host);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           LoadBalance.SERVICE_LIST = newServerList;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n<h4 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h4><ul>\n<li>基于同名节点的分布式锁</li>\n</ul>\n<p>思想：都创建同一个临时节点，成功获得锁，失败等待</p>\n<p><img src=\"http://image.tupelo.top/%E4%B8%B4%E6%97%B6.png\" alt=\"分布式锁\"></p>\n<ul>\n<li>高性能分布式锁</li>\n</ul>\n<p>思想：创建临时顺序节点 若为最小节点，获得锁，否则监听上一个节点是否被删除</p>\n<p><img src=\"http://image.tupelo.top/%E6%80%A7%E8%83%BD.png\" alt=\"分布式锁\"></p>\n<h4 id=\"自动选举\"><a href=\"#自动选举\" class=\"headerlink\" title=\"自动选举\"></a>自动选举</h4><p>思想：监听某一个节点，当节点被删除时，创建临时节点写入自己的信息，成功则自己为master节点，否则获取该节点信息为master信息，监听该节点。</p>\n<h4 id=\"数据发布与订阅（配置中心）\"><a href=\"#数据发布与订阅（配置中心）\" class=\"headerlink\" title=\"数据发布与订阅（配置中心）\"></a>数据发布与订阅（配置中心）</h4><p>思想：直接监听某一个节点，当节点内容有修改是，直接修改配置。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h4><p>注册：</p>\n<blockquote>\n<p>服务启动时 在某一个节点下新建一个临时顺序节点将ip+端口保存</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(String address,<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ZooKeeper zooKeeper = <span class=\"keyword\">new</span> ZooKeeper(<span class=\"string\">\"localhost:2181\"</span>,<span class=\"number\">5000</span>,(watchedEvent)-&gt;&#123;&#125;);</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"连接zk\"</span>);</span><br><span class=\"line\">            Stat exists = zooKeeper.exists(BASE_SERVICES + SERVICE_NAME, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"判断是否存在\"</span> + exists);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(exists==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"创建路径\"</span> );</span><br><span class=\"line\">                zooKeeper.create(BASE_SERVICES,<span class=\"string\">\"\"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class=\"line\">                zooKeeper.create(BASE_SERVICES + SERVICE_NAME,<span class=\"string\">\"\"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String server_path = address+<span class=\"string\">\":\"</span>+port;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"server_path:\"</span> + server_path);</span><br><span class=\"line\">            zooKeeper.create(BASE_SERVICES + SERVICE_NAME+<span class=\"string\">\"/child\"</span>,server_path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"保存成功\"</span> );</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>发现：</p>\n<blockquote>\n<p>监听某一个节点，当子节点发生变化时更新ip列表，请求时从列表中获取ip+端口</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateServiceList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           logger.warn(<span class=\"string\">\"ip 改变 开始更新ip地址\"</span>);</span><br><span class=\"line\">           List&lt;String&gt; children = zooKeeper.getChildren(BASE_SERVICES  + SERVICE_NAME, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">           List&lt;String&gt; newServerList = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(String subNode:children) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">byte</span>[] data = zooKeeper.getData(BASE_SERVICES  + SERVICE_NAME + <span class=\"string\">\"/\"</span> + subNode, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">               String host = <span class=\"keyword\">new</span> String(data, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"host:\"</span>+host);</span><br><span class=\"line\">               newServerList.add(host);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           LoadBalance.SERVICE_LIST = newServerList;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h4><ul>\n<li>基于同名节点的分布式锁</li>\n</ul>\n<p>思想：都创建同一个临时节点，成功获得锁，失败等待</p>\n<p><img src=\"http://image.tupelo.top/%E4%B8%B4%E6%97%B6.png\" alt=\"分布式锁\"></p>\n<ul>\n<li>高性能分布式锁</li>\n</ul>\n<p>思想：创建临时顺序节点 若为最小节点，获得锁，否则监听上一个节点是否被删除</p>\n<p><img src=\"http://image.tupelo.top/%E6%80%A7%E8%83%BD.png\" alt=\"分布式锁\"></p>\n<h4 id=\"自动选举\"><a href=\"#自动选举\" class=\"headerlink\" title=\"自动选举\"></a>自动选举</h4><p>思想：监听某一个节点，当节点被删除时，创建临时节点写入自己的信息，成功则自己为master节点，否则获取该节点信息为master信息，监听该节点。</p>\n<h4 id=\"数据发布与订阅（配置中心）\"><a href=\"#数据发布与订阅（配置中心）\" class=\"headerlink\" title=\"数据发布与订阅（配置中心）\"></a>数据发布与订阅（配置中心）</h4><p>思想：直接监听某一个节点，当节点内容有修改是，直接修改配置。</p>"},{"title":"Zookeeper特性","_content":"\n#### 目标\n\n- 简单的数据结构：共享的树形结构，类似文件系统，存储于内存；\n- 可以构建集群：避免单点故障，3-5台机器就可以组成集群，超过半数正常工作就能对外提供服务；\n- 顺序访问：对于每个读请求，zk会分配一个全局唯一的递增编号，利用这个特性可以实现高级协调服务；\n- 高性能：基于内存操作，服务于非事务请求，适用于读操作为主的业务场景。3台zk集群能达到13w QPS；\n\n#### 使用场景\n\n- 数据发布订阅\n- 负载均衡\n- 命名服务\n- Master选举\n- 集群管理\n- 配置管理\n- 分布式队列\n- 分布式锁\n\n<!-- more -->  \n\n#### 特性\n\n- 会话\n\n\t客户端与服务端的一次会话连接，本质是TCP长连接，通过会话可以进行心跳检测和数据传输\n\n- ZK数据模型\n\n\tZooKeeper的视图结构和标准的Unix文件系统类似，其中每个节点称为“数据节点”或ZNode,每个znode可以存储数据，还可以挂载子节点，因此可以称之为“树”。第二点需要注意的是，每一个znode都必须有值，如果没有值，节点是不能创建成功的。\n\n- Zookeeper节点类型\n\n\t永久/临时/永久顺序/临时顺序\n\n- Zookeeper节点状态属性\n\n\t![节点属性](http://image.tupelo.top/zk%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png)\n\n- ACL保障数据的安全\n\n\tACL机制，表示为scheme:id:permissions，第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。\n\n#### 命令行\n\n服务端：\n\n```sh\nzkServer start/restart/stop/status\n```\n\n客户端：\n\n```sh\n# 默认连本机\nzkCli -server 127.0.0.1:2181\n\n# 查看\nls /\n# 查看详情\nls2 /\n# 创建节点 -e 临时节点 -s 顺序节点\ncreate -e -s /aa\n# 查询/赋值\nget/set /aa a \n# 删除\ndelete /aa\n# 递归删除\nrmr /aa\n```\n\n#### ACL命令常用命令\n\nZookeeper的ACL(Access Control List)，分为三个维度：scheme、id、permission\t\t\n通常表示为：scheme\\:id:permissions,第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。\n\n- schema:代表授权策略\n- id:代表用户\n- permission:代表权限\n\nScheme:\n\n- world：\n\n\t默认方式，相当于全世界都能访问\n\n- auth：\n\n\t代表已经认证通过的用户(可以通过addauth digest user:pwd 来添加授权用户)\n\n- digest：\n\n\t即用户名:密码这种方式认证，这也是业务系统中最常用的\n\n- ip：\n\n\t使用Ip地址认证\n\nid 验证模式，不同的scheme，id的值也不一样:\n\n- scheme为auth时 username:password\n- scheme为digest时 username:BASE64(SHA1(password))\n- scheme为ip时 客户端的ip地址。\n- scheme为world时 anyone。\n\npermission:\n\nCREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)\n\n命令：\n\n```sh\n# 查看权限\ngetAcl /aa\n# 添加权限\nsetAcl /aa world:anyone:crwa\n# 添加用户 断开连接后 用户也退出 二次执行时前一个用户也退出\naddauth digest user1:123456 \n# auth与digest的区别就是，前者使用明文密码进行登录，后者使用密文密码进行登录\nsetAcl /testDir/testAcl auth:user1:123456:crwa\nsetAcl /testDir/testDigest digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:crwa\n\n# 获取密文 直接调用jar包\njava -Djava.ext.dirs=/soft/zookeeper-3.4.12/lib -cp /soft/zookeeper-3.4.12/zookeeper-3.4.12.jar org.apache.zookeeper.server.auth.DigestAuthenticationProvider deer:123456\n```\n\nsetAcl权限的时候由于失误，导致节点无法删除\t\t\n解决方式:启用super权限\t\t\t\t\n使用```DigestAuthenticationProvider.generateDigest(\"super:admin\");``` 获得密码\n修改zkServer启动脚本增加```-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=```\t\t\n启动客户端用管理员登陆进行删除```addauth digest super:admin```\t\n\n#### ZK四字命令\n\nZooKeeper 支持某些特定的四字命令字母与其的交互。用来获取 ZooKeeper 服务的当前状态及相关信息。可通过 telnet 或 nc 向 ZooKeeper 提交相应的命令\n\n- echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader \n- echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。 \n- echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。 \n- echo kill | nc 127.0.0.1 2181 ,关掉server \n- echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。 \n- echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息 \n- echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。 \n- echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。 \n- echo wchs | nc 127.0.0.1 2181 ,列出服务器 watch 的详细信息。 \n- echo wchc | nc 127.0.0.1 2181 ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。 \n- echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。\n\n#### ZooKeeper日志可视化\n\n> 直接调用jar包命令,两个非常重要的配置一个是dataDir，存放的快照数据，一个是dataLogDir，存放的是事务日志文件\n\n\n```sh\n# 事务日志\n/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.LogFormatter log.1\n# 快照日志\n/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.SnapshotFormatter log.1\n```\n","source":"_posts/zookeeper特性.md","raw":"---\ntitle: Zookeeper特性\ntags:\n  - zookeeper\n---\n\n#### 目标\n\n- 简单的数据结构：共享的树形结构，类似文件系统，存储于内存；\n- 可以构建集群：避免单点故障，3-5台机器就可以组成集群，超过半数正常工作就能对外提供服务；\n- 顺序访问：对于每个读请求，zk会分配一个全局唯一的递增编号，利用这个特性可以实现高级协调服务；\n- 高性能：基于内存操作，服务于非事务请求，适用于读操作为主的业务场景。3台zk集群能达到13w QPS；\n\n#### 使用场景\n\n- 数据发布订阅\n- 负载均衡\n- 命名服务\n- Master选举\n- 集群管理\n- 配置管理\n- 分布式队列\n- 分布式锁\n\n<!-- more -->  \n\n#### 特性\n\n- 会话\n\n\t客户端与服务端的一次会话连接，本质是TCP长连接，通过会话可以进行心跳检测和数据传输\n\n- ZK数据模型\n\n\tZooKeeper的视图结构和标准的Unix文件系统类似，其中每个节点称为“数据节点”或ZNode,每个znode可以存储数据，还可以挂载子节点，因此可以称之为“树”。第二点需要注意的是，每一个znode都必须有值，如果没有值，节点是不能创建成功的。\n\n- Zookeeper节点类型\n\n\t永久/临时/永久顺序/临时顺序\n\n- Zookeeper节点状态属性\n\n\t![节点属性](http://image.tupelo.top/zk%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png)\n\n- ACL保障数据的安全\n\n\tACL机制，表示为scheme:id:permissions，第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。\n\n#### 命令行\n\n服务端：\n\n```sh\nzkServer start/restart/stop/status\n```\n\n客户端：\n\n```sh\n# 默认连本机\nzkCli -server 127.0.0.1:2181\n\n# 查看\nls /\n# 查看详情\nls2 /\n# 创建节点 -e 临时节点 -s 顺序节点\ncreate -e -s /aa\n# 查询/赋值\nget/set /aa a \n# 删除\ndelete /aa\n# 递归删除\nrmr /aa\n```\n\n#### ACL命令常用命令\n\nZookeeper的ACL(Access Control List)，分为三个维度：scheme、id、permission\t\t\n通常表示为：scheme\\:id:permissions,第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。\n\n- schema:代表授权策略\n- id:代表用户\n- permission:代表权限\n\nScheme:\n\n- world：\n\n\t默认方式，相当于全世界都能访问\n\n- auth：\n\n\t代表已经认证通过的用户(可以通过addauth digest user:pwd 来添加授权用户)\n\n- digest：\n\n\t即用户名:密码这种方式认证，这也是业务系统中最常用的\n\n- ip：\n\n\t使用Ip地址认证\n\nid 验证模式，不同的scheme，id的值也不一样:\n\n- scheme为auth时 username:password\n- scheme为digest时 username:BASE64(SHA1(password))\n- scheme为ip时 客户端的ip地址。\n- scheme为world时 anyone。\n\npermission:\n\nCREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)\n\n命令：\n\n```sh\n# 查看权限\ngetAcl /aa\n# 添加权限\nsetAcl /aa world:anyone:crwa\n# 添加用户 断开连接后 用户也退出 二次执行时前一个用户也退出\naddauth digest user1:123456 \n# auth与digest的区别就是，前者使用明文密码进行登录，后者使用密文密码进行登录\nsetAcl /testDir/testAcl auth:user1:123456:crwa\nsetAcl /testDir/testDigest digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:crwa\n\n# 获取密文 直接调用jar包\njava -Djava.ext.dirs=/soft/zookeeper-3.4.12/lib -cp /soft/zookeeper-3.4.12/zookeeper-3.4.12.jar org.apache.zookeeper.server.auth.DigestAuthenticationProvider deer:123456\n```\n\nsetAcl权限的时候由于失误，导致节点无法删除\t\t\n解决方式:启用super权限\t\t\t\t\n使用```DigestAuthenticationProvider.generateDigest(\"super:admin\");``` 获得密码\n修改zkServer启动脚本增加```-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=```\t\t\n启动客户端用管理员登陆进行删除```addauth digest super:admin```\t\n\n#### ZK四字命令\n\nZooKeeper 支持某些特定的四字命令字母与其的交互。用来获取 ZooKeeper 服务的当前状态及相关信息。可通过 telnet 或 nc 向 ZooKeeper 提交相应的命令\n\n- echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader \n- echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。 \n- echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。 \n- echo kill | nc 127.0.0.1 2181 ,关掉server \n- echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。 \n- echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息 \n- echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。 \n- echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。 \n- echo wchs | nc 127.0.0.1 2181 ,列出服务器 watch 的详细信息。 \n- echo wchc | nc 127.0.0.1 2181 ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。 \n- echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。\n\n#### ZooKeeper日志可视化\n\n> 直接调用jar包命令,两个非常重要的配置一个是dataDir，存放的快照数据，一个是dataLogDir，存放的是事务日志文件\n\n\n```sh\n# 事务日志\n/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.LogFormatter log.1\n# 快照日志\n/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.SnapshotFormatter log.1\n```\n","slug":"zookeeper特性","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15b4002a9gj7sz7sx4vv","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h4><ul>\n<li>简单的数据结构：共享的树形结构，类似文件系统，存储于内存；</li>\n<li>可以构建集群：避免单点故障，3-5台机器就可以组成集群，超过半数正常工作就能对外提供服务；</li>\n<li>顺序访问：对于每个读请求，zk会分配一个全局唯一的递增编号，利用这个特性可以实现高级协调服务；</li>\n<li>高性能：基于内存操作，服务于非事务请求，适用于读操作为主的业务场景。3台zk集群能达到13w QPS；</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>数据发布订阅</li>\n<li>负载均衡</li>\n<li>命名服务</li>\n<li>Master选举</li>\n<li>集群管理</li>\n<li>配置管理</li>\n<li>分布式队列</li>\n<li>分布式锁</li>\n</ul>\n<a id=\"more\"></a>  \n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ul>\n<li><p>会话</p>\n<p>  客户端与服务端的一次会话连接，本质是TCP长连接，通过会话可以进行心跳检测和数据传输</p>\n</li>\n<li><p>ZK数据模型</p>\n<p>  ZooKeeper的视图结构和标准的Unix文件系统类似，其中每个节点称为“数据节点”或ZNode,每个znode可以存储数据，还可以挂载子节点，因此可以称之为“树”。第二点需要注意的是，每一个znode都必须有值，如果没有值，节点是不能创建成功的。</p>\n</li>\n<li><p>Zookeeper节点类型</p>\n<p>  永久/临时/永久顺序/临时顺序</p>\n</li>\n<li><p>Zookeeper节点状态属性</p>\n<p>  <img src=\"http://image.tupelo.top/zk%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png\" alt=\"节点属性\"></p>\n</li>\n<li><p>ACL保障数据的安全</p>\n<p>  ACL机制，表示为scheme:id:permissions，第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。</p>\n</li>\n</ul>\n<h4 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h4><p>服务端：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zkServer start/restart/stop/status</span><br></pre></td></tr></table></figure>\n<p>客户端：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认连本机</span></span><br><span class=\"line\">zkCli -server 127.0.0.1:2181</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\">ls /</span><br><span class=\"line\"><span class=\"comment\"># 查看详情</span></span><br><span class=\"line\">ls2 /</span><br><span class=\"line\"><span class=\"comment\"># 创建节点 -e 临时节点 -s 顺序节点</span></span><br><span class=\"line\">create -e -s /aa</span><br><span class=\"line\"><span class=\"comment\"># 查询/赋值</span></span><br><span class=\"line\">get/<span class=\"built_in\">set</span> /aa a </span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">delete /aa</span><br><span class=\"line\"><span class=\"comment\"># 递归删除</span></span><br><span class=\"line\">rmr /aa</span><br></pre></td></tr></table></figure>\n<h4 id=\"ACL命令常用命令\"><a href=\"#ACL命令常用命令\" class=\"headerlink\" title=\"ACL命令常用命令\"></a>ACL命令常用命令</h4><p>Zookeeper的ACL(Access Control List)，分为三个维度：scheme、id、permission<br>通常表示为：scheme\\:id:permissions,第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。</p>\n<ul>\n<li>schema:代表授权策略</li>\n<li>id:代表用户</li>\n<li>permission:代表权限</li>\n</ul>\n<p>Scheme:</p>\n<ul>\n<li><p>world：</p>\n<p>  默认方式，相当于全世界都能访问</p>\n</li>\n<li><p>auth：</p>\n<p>  代表已经认证通过的用户(可以通过addauth digest user:pwd 来添加授权用户)</p>\n</li>\n<li><p>digest：</p>\n<p>  即用户名:密码这种方式认证，这也是业务系统中最常用的</p>\n</li>\n<li><p>ip：</p>\n<p>  使用Ip地址认证</p>\n</li>\n</ul>\n<p>id 验证模式，不同的scheme，id的值也不一样:</p>\n<ul>\n<li>scheme为auth时 username:password</li>\n<li>scheme为digest时 username:BASE64(SHA1(password))</li>\n<li>scheme为ip时 客户端的ip地址。</li>\n<li>scheme为world时 anyone。</li>\n</ul>\n<p>permission:</p>\n<p>CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)</p>\n<p>命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看权限</span></span><br><span class=\"line\">getAcl /aa</span><br><span class=\"line\"><span class=\"comment\"># 添加权限</span></span><br><span class=\"line\">setAcl /aa world:anyone:crwa</span><br><span class=\"line\"><span class=\"comment\"># 添加用户 断开连接后 用户也退出 二次执行时前一个用户也退出</span></span><br><span class=\"line\">addauth digest user1:123456 </span><br><span class=\"line\"><span class=\"comment\"># auth与digest的区别就是，前者使用明文密码进行登录，后者使用密文密码进行登录</span></span><br><span class=\"line\">setAcl /testDir/testAcl auth:user1:123456:crwa</span><br><span class=\"line\">setAcl /testDir/testDigest digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:crwa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取密文 直接调用jar包</span></span><br><span class=\"line\">java -Djava.ext.dirs=/soft/zookeeper-3.4.12/lib -cp /soft/zookeeper-3.4.12/zookeeper-3.4.12.jar org.apache.zookeeper.server.auth.DigestAuthenticationProvider deer:123456</span><br></pre></td></tr></table></figure>\n<p>setAcl权限的时候由于失误，导致节点无法删除<br>解决方式:启用super权限<br>使用<figure class=\"highlight plain\"><figcaption><span>获得密码</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修改zkServer启动脚本增加```-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=```\t\t</span><br><span class=\"line\">启动客户端用管理员登陆进行删除```addauth digest super:admin```\t</span><br><span class=\"line\"></span><br><span class=\"line\">#### ZK四字命令</span><br><span class=\"line\"></span><br><span class=\"line\">ZooKeeper 支持某些特定的四字命令字母与其的交互。用来获取 ZooKeeper 服务的当前状态及相关信息。可通过 telnet 或 nc 向 ZooKeeper 提交相应的命令</span><br><span class=\"line\"></span><br><span class=\"line\">- echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader </span><br><span class=\"line\">- echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。 </span><br><span class=\"line\">- echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。 </span><br><span class=\"line\">- echo kill | nc 127.0.0.1 2181 ,关掉server </span><br><span class=\"line\">- echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。 </span><br><span class=\"line\">- echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息 </span><br><span class=\"line\">- echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。 </span><br><span class=\"line\">- echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。 </span><br><span class=\"line\">- echo wchs | nc 127.0.0.1 2181 ,列出服务器 watch 的详细信息。 </span><br><span class=\"line\">- echo wchc | nc 127.0.0.1 2181 ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。 </span><br><span class=\"line\">- echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。</span><br><span class=\"line\"></span><br><span class=\"line\">#### ZooKeeper日志可视化</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 直接调用jar包命令,两个非常重要的配置一个是dataDir，存放的快照数据，一个是dataLogDir，存放的是事务日志文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\"># 事务日志</span><br><span class=\"line\">/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.LogFormatter log.1</span><br><span class=\"line\"># 快照日志</span><br><span class=\"line\">/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.SnapshotFormatter log.1</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h4><ul>\n<li>简单的数据结构：共享的树形结构，类似文件系统，存储于内存；</li>\n<li>可以构建集群：避免单点故障，3-5台机器就可以组成集群，超过半数正常工作就能对外提供服务；</li>\n<li>顺序访问：对于每个读请求，zk会分配一个全局唯一的递增编号，利用这个特性可以实现高级协调服务；</li>\n<li>高性能：基于内存操作，服务于非事务请求，适用于读操作为主的业务场景。3台zk集群能达到13w QPS；</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>数据发布订阅</li>\n<li>负载均衡</li>\n<li>命名服务</li>\n<li>Master选举</li>\n<li>集群管理</li>\n<li>配置管理</li>\n<li>分布式队列</li>\n<li>分布式锁</li>\n</ul>","more":"<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><ul>\n<li><p>会话</p>\n<p>  客户端与服务端的一次会话连接，本质是TCP长连接，通过会话可以进行心跳检测和数据传输</p>\n</li>\n<li><p>ZK数据模型</p>\n<p>  ZooKeeper的视图结构和标准的Unix文件系统类似，其中每个节点称为“数据节点”或ZNode,每个znode可以存储数据，还可以挂载子节点，因此可以称之为“树”。第二点需要注意的是，每一个znode都必须有值，如果没有值，节点是不能创建成功的。</p>\n</li>\n<li><p>Zookeeper节点类型</p>\n<p>  永久/临时/永久顺序/临时顺序</p>\n</li>\n<li><p>Zookeeper节点状态属性</p>\n<p>  <img src=\"http://image.tupelo.top/zk%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7.png\" alt=\"节点属性\"></p>\n</li>\n<li><p>ACL保障数据的安全</p>\n<p>  ACL机制，表示为scheme:id:permissions，第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。</p>\n</li>\n</ul>\n<h4 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h4><p>服务端：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zkServer start/restart/stop/status</span><br></pre></td></tr></table></figure>\n<p>客户端：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认连本机</span></span><br><span class=\"line\">zkCli -server 127.0.0.1:2181</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看</span></span><br><span class=\"line\">ls /</span><br><span class=\"line\"><span class=\"comment\"># 查看详情</span></span><br><span class=\"line\">ls2 /</span><br><span class=\"line\"><span class=\"comment\"># 创建节点 -e 临时节点 -s 顺序节点</span></span><br><span class=\"line\">create -e -s /aa</span><br><span class=\"line\"><span class=\"comment\"># 查询/赋值</span></span><br><span class=\"line\">get/<span class=\"built_in\">set</span> /aa a </span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">delete /aa</span><br><span class=\"line\"><span class=\"comment\"># 递归删除</span></span><br><span class=\"line\">rmr /aa</span><br></pre></td></tr></table></figure>\n<h4 id=\"ACL命令常用命令\"><a href=\"#ACL命令常用命令\" class=\"headerlink\" title=\"ACL命令常用命令\"></a>ACL命令常用命令</h4><p>Zookeeper的ACL(Access Control List)，分为三个维度：scheme、id、permission<br>通常表示为：scheme\\:id:permissions,第一个字段表示采用哪一种机制，第二个id表示用户，permissions表示相关权限（如只读，读写，管理等）。</p>\n<ul>\n<li>schema:代表授权策略</li>\n<li>id:代表用户</li>\n<li>permission:代表权限</li>\n</ul>\n<p>Scheme:</p>\n<ul>\n<li><p>world：</p>\n<p>  默认方式，相当于全世界都能访问</p>\n</li>\n<li><p>auth：</p>\n<p>  代表已经认证通过的用户(可以通过addauth digest user:pwd 来添加授权用户)</p>\n</li>\n<li><p>digest：</p>\n<p>  即用户名:密码这种方式认证，这也是业务系统中最常用的</p>\n</li>\n<li><p>ip：</p>\n<p>  使用Ip地址认证</p>\n</li>\n</ul>\n<p>id 验证模式，不同的scheme，id的值也不一样:</p>\n<ul>\n<li>scheme为auth时 username:password</li>\n<li>scheme为digest时 username:BASE64(SHA1(password))</li>\n<li>scheme为ip时 客户端的ip地址。</li>\n<li>scheme为world时 anyone。</li>\n</ul>\n<p>permission:</p>\n<p>CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)</p>\n<p>命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看权限</span></span><br><span class=\"line\">getAcl /aa</span><br><span class=\"line\"><span class=\"comment\"># 添加权限</span></span><br><span class=\"line\">setAcl /aa world:anyone:crwa</span><br><span class=\"line\"><span class=\"comment\"># 添加用户 断开连接后 用户也退出 二次执行时前一个用户也退出</span></span><br><span class=\"line\">addauth digest user1:123456 </span><br><span class=\"line\"><span class=\"comment\"># auth与digest的区别就是，前者使用明文密码进行登录，后者使用密文密码进行登录</span></span><br><span class=\"line\">setAcl /testDir/testAcl auth:user1:123456:crwa</span><br><span class=\"line\">setAcl /testDir/testDigest digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:crwa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取密文 直接调用jar包</span></span><br><span class=\"line\">java -Djava.ext.dirs=/soft/zookeeper-3.4.12/lib -cp /soft/zookeeper-3.4.12/zookeeper-3.4.12.jar org.apache.zookeeper.server.auth.DigestAuthenticationProvider deer:123456</span><br></pre></td></tr></table></figure>\n<p>setAcl权限的时候由于失误，导致节点无法删除<br>解决方式:启用super权限<br>使用<figure class=\"highlight plain\"><figcaption><span>获得密码</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修改zkServer启动脚本增加```-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=```\t\t</span><br><span class=\"line\">启动客户端用管理员登陆进行删除```addauth digest super:admin```\t</span><br><span class=\"line\"></span><br><span class=\"line\">#### ZK四字命令</span><br><span class=\"line\"></span><br><span class=\"line\">ZooKeeper 支持某些特定的四字命令字母与其的交互。用来获取 ZooKeeper 服务的当前状态及相关信息。可通过 telnet 或 nc 向 ZooKeeper 提交相应的命令</span><br><span class=\"line\"></span><br><span class=\"line\">- echo stat|nc 127.0.0.1 2181 来查看哪个节点被选择作为follower或者leader </span><br><span class=\"line\">- echo ruok|nc 127.0.0.1 2181 测试是否启动了该Server，若回复imok表示已经启动。 </span><br><span class=\"line\">- echo dump| nc 127.0.0.1 2181 ,列出未经处理的会话和临时节点。 </span><br><span class=\"line\">- echo kill | nc 127.0.0.1 2181 ,关掉server </span><br><span class=\"line\">- echo conf | nc 127.0.0.1 2181 ,输出相关服务配置的详细信息。 </span><br><span class=\"line\">- echo cons | nc 127.0.0.1 2181 ,列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息 </span><br><span class=\"line\">- echo envi |nc 127.0.0.1 2181 ,输出关于服务环境的详细信息（区别于 conf 命令）。 </span><br><span class=\"line\">- echo reqs | nc 127.0.0.1 2181 ,列出未经处理的请求。 </span><br><span class=\"line\">- echo wchs | nc 127.0.0.1 2181 ,列出服务器 watch 的详细信息。 </span><br><span class=\"line\">- echo wchc | nc 127.0.0.1 2181 ,通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。 </span><br><span class=\"line\">- echo wchp | nc 127.0.0.1 2181 ,通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。</span><br><span class=\"line\"></span><br><span class=\"line\">#### ZooKeeper日志可视化</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 直接调用jar包命令,两个非常重要的配置一个是dataDir，存放的快照数据，一个是dataLogDir，存放的是事务日志文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```sh</span><br><span class=\"line\"># 事务日志</span><br><span class=\"line\">/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.LogFormatter log.1</span><br><span class=\"line\"># 快照日志</span><br><span class=\"line\">/soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.SnapshotFormatter log.1</span><br></pre></td></tr></table></figure></p>"},{"title":"Spring设计模式","_content":"\nSpring设计模式\n\n### Spring设计模式\n\n\n##### 简单工厂模式\n\nBeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\n\n\n实现原理：\nbean容器的启动阶段：\n\n读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。\n然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。\n将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。\n\n\n简单工厂模式：\n\n- 创建抽象父类\n- 子类继承父类实现抽象方法\n- 工厂类根据条件产生不同的子类\n\n缺点：\n违背了开闭原则,工厂类可能容易成为上帝类。\n\n<!-- more -->\n\n\n代码：\n\n```java\npublic abstract class DaBen{ }\n\npublic class DaBenC extends DaBen{\n    public DaBenC() {\n        System.out.println(\"DaBenC created....\");\n    }\n}\n\npublic class DaBenE extends DaBen{\n    public DaBenE() {\n        System.out.println(\"DaBenE created....\");\n    }\n}\n\npublic class Factory{\n    public DaBen createDaBen(String  type){\n        if(\"C\".equals(type)){\n            return new DaBenC();\n        }\n        if(\"E\".equals(type)){\n            return new DaBenE();\n        }\n        return null;\n    }\n}\n\npublic static void main(String[] args) {\n    Factory factory = new Factory();\n    factory.createDaBen(\"C\");\n    factory.createDaBen(\"E\");\n}\n```\n\n\n##### 工厂方法模式\n\nFactoryBean接口。\n\n实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。\n\n\n工厂方法模式 代码示例：\n```java\npublic class DaBen{ }\npublic class DaBenC extends DaBen{\n    public DaBenC() {\n        System.out.println(\"DaBenC created....\");\n    }\n}\npublic class DaBenE extends DaBen{\n    public DaBenE() {\n        System.out.println(\"DaBenE created....\");\n    }\n}\npublic interface MainFactory{\n    DaBen createDaBen();\n}\npublic class DaBenCCreate implements MainFactory{\n    @Override\n    public DaBen createDaBen() {\n        return new DaBenC();\n    }\n}\npublic class DaBenECreate implements MainFactory{\n    @Override\n    public DaBen createDaBen() {\n        return new DaBenE();\n    }\n}\npublic static void main(String[] args) {\n    MainFactory factoryC = new DaBenCCreate();\n    factoryC.createDaBen();\n    MainFactory factoryE = new DaBenECreate();\n    factoryE.createDaBen();\n}\n```\n\n扩展 抽象工厂模式：\n抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。\n\n\n##### 单例模式\n\nSpring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。使用了 双重判断加锁 的单例模式。\n\n```java\npublic Object getSingleton(String beanName){\n    //参数true设置标识允许早期依赖\n    return getSingleton(beanName,true);\n}\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    //检查缓存中是否存在实例\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        //如果为空，则锁定全局变量并进行处理。\n        synchronized (this.singletonObjects) {\n            //如果此bean正在加载，则不处理\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {  \n                //当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    //调用预先设定的getObject方法\n                    singletonObject = singletonFactory.getObject();\n                    //记录在缓存中，earlysingletonObjects和singletonFactories互斥\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n```\n\n\n\n\n##### 适配器模式\n\nAOP中的AdvisorAdapter是一个适配器接口，它定义了自己支持的Advice类型，并且能把一个Advisor适配成MethodInterceptor（这也是AOP联盟定义的借口）\n\n```java\npublic interface AdvisorAdapter {\n\t// 将一个Advisor适配成MethodInterceptor\n\tMethodInterceptor getInterceptor(Advisor advisor);\n\t// 判断此适配器是否支持特定的Advice\n\tboolean supportsAdvice(Advice advice);\n}\n```\n\n\n\n\n##### 代理模式\n\n\nbean初始化的时候的init方法\naopBean初始化的时候直接创建代理类返回\n\n代码示例：\n\n```java\n// 接口\npublic interface Hello {\n    public void sayHello();\n}\n// 实现\npublic class HelloImpl implements Hello {\n    @Override\n    public void sayHello(){\n        System.out.println(\"hello........\");\n    };\n}\n// JDK代理\npublic class JdkProxy implements InvocationHandler  {\n    private Object object;\n    public JdkProxy(Object object) {\n        this.object = object;\n    }\n    public Object newProxy() {\n        return Proxy.newProxyInstance(object.getClass().getClassLoader(),\n                object.getClass().getInterfaces(), this);\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(\"before...........\");\n        method.invoke(object,args);\n        System.out.println(\"after...........\");\n        return method;\n    }\n}\n// Cglib代理\npublic class CglibProxy implements MethodInterceptor {\n    private Object object;\n    public CglibProxy(Object object) {\n        this.object = object;\n    }\n    public Object createProxyObject() {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(object.getClass());\n        enhancer.setCallback(this);\n        return enhancer.create();\n    }\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"before ................\");\n        method.invoke(object,objects);\n        System.out.println(\"after ................\");\n        return null;\n    }\n}\n// 调用\n@Test\npublic void testJdkProxy() {\n    Hello helloImpl = new HelloImpl();\n    JdkProxy interfaceProxy = new JdkProxy(helloImpl);\n    Hello hello = (Hello) interfaceProxy.newProxy();\n    hello.sayHello();\n}\n\n@Test\npublic void testCglibProxy() {\n    Hello helloImpl = new HelloImpl();\n    CglibProxy interfaceProxy = new CglibProxy(helloImpl);\n    Hello hello = (Hello) interfaceProxy.createProxyObject();\n    hello.sayHello();\n}\n```\n\n\n##### 模板方法模式\n\nspring jdbcTemplate使用了模板方法模式\n\n\n模板方法模式 \n\n优点\n1、封装不变部分，扩展可变部分。\n2、提取公共代码，便于维护。\n3、行为由父类控制，子类实现。\n缺点\n每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n代码：\n\n```java\npublic abstract class OneDay {\n    public abstract void getUp();\n    public abstract void sleep();\n    public void one(){\n        getUp();\n        sleep();\n    }\n}\n\npublic class XiaoMingDay extends OneDay{\n    @Override\n    public void getUp() {\n        System.out.println(\"xiaoming getup ...\");\n    }\n    @Override\n    public void sleep() {\n        System.out.println(\"xiaoming sleep ...\");\n    }\n}\n\n\n\npublic class XiaoWangDay extends OneDay{\n    @Override\n    public void getUp() {\n        System.out.println(\"xiaoWang getup ...\");\n    }\n    @Override\n    public void sleep() {\n        System.out.println(\"xiaoWang sleep ...\");\n    }\n}\npublic static void main(String[] args) {\n        OneDay oneDay = new XiaoMingDay();\n        OneDay oneDay1 = new XiaoWangDay();\n        oneDay.one();\n        oneDay1.one();\n}\n```\n\n\n\n##### 观察者模式\n\nSpring 事件驱动模型就是观察者模式很经典的一个应用。\n\n```java\n\n//注册一个事件\npublic class QuestionEvent extends ApplicationEvent {\n    private String question;\n    public QuestionEvent(String question) {\n        super(question);\n        this.question = question;\n    }\n    public String getQuestion() {\n        return question;\n    }\n    public void setQuestion(String question) {\n        this.question = question;\n    }\n}\n\n// 注册一个观察器\n@Component\npublic class QuestionListener implements ApplicationListener<QuestionEvent> {\n    @Override\n    public void onApplicationEvent(QuestionEvent questionEvent) {\n        System.out.println(\"QuestionListener......................\" + questionEvent.toString());\n    }\n}\n\n// 注册一个发布者\n@Component\npublic class EventPublisher implements ApplicationEventPublisherAware {\n\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n        this.applicationEventPublisher =applicationEventPublisher;\n    }\n\n    public ApplicationEventPublisher getApplicationEventPublisher() {\n        return applicationEventPublisher;\n    }\n}\n\n// 发布消息\n@Test\npublic void testEvent() {\n    String question = \"这是一个问题\";\n    applicationEventPublisher.publishEvent(new QuestionEvent(question));\n}\n```\n\n\n##### 策略模式\n\n代码例子：\n\n```java\n//父类\npublic abstract class Strategy {\n    public abstract void doSomething();\n}\n\n// 实现类\npublic class StrategyA extends Strategy {\n    @Override\n    public void doSomething() {\n        System.out.println(\"A.......\");\n    }\n}\n\npublic class StrategyB extends Strategy {\n    @Override\n    public void doSomething() {\n        System.out.println(\"B.......\");\n    }\n}\n// 策略类\npublic class Context  {\n    private Strategy strategy;\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n    public void contextDoSomething() {\n        strategy.doSomething();\n    }\n}\n// 调用\n@Test\npublic void testEvent() {\n    Context contextA = new Context(new StrategyA());\n    Context contextB = new Context(new StrategyB());\n    contextA.contextDoSomething();\n    contextB.contextDoSomething();\n}\n```","source":"_posts/spring-设计模式.md","raw":"---\ntitle: Spring设计模式\ntags:\n  - Java\n  - Spring\n---\n\nSpring设计模式\n\n### Spring设计模式\n\n\n##### 简单工厂模式\n\nBeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。\n\n\n实现原理：\nbean容器的启动阶段：\n\n读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。\n然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。\n将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。\n\n\n简单工厂模式：\n\n- 创建抽象父类\n- 子类继承父类实现抽象方法\n- 工厂类根据条件产生不同的子类\n\n缺点：\n违背了开闭原则,工厂类可能容易成为上帝类。\n\n<!-- more -->\n\n\n代码：\n\n```java\npublic abstract class DaBen{ }\n\npublic class DaBenC extends DaBen{\n    public DaBenC() {\n        System.out.println(\"DaBenC created....\");\n    }\n}\n\npublic class DaBenE extends DaBen{\n    public DaBenE() {\n        System.out.println(\"DaBenE created....\");\n    }\n}\n\npublic class Factory{\n    public DaBen createDaBen(String  type){\n        if(\"C\".equals(type)){\n            return new DaBenC();\n        }\n        if(\"E\".equals(type)){\n            return new DaBenE();\n        }\n        return null;\n    }\n}\n\npublic static void main(String[] args) {\n    Factory factory = new Factory();\n    factory.createDaBen(\"C\");\n    factory.createDaBen(\"E\");\n}\n```\n\n\n##### 工厂方法模式\n\nFactoryBean接口。\n\n实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。\n\n\n工厂方法模式 代码示例：\n```java\npublic class DaBen{ }\npublic class DaBenC extends DaBen{\n    public DaBenC() {\n        System.out.println(\"DaBenC created....\");\n    }\n}\npublic class DaBenE extends DaBen{\n    public DaBenE() {\n        System.out.println(\"DaBenE created....\");\n    }\n}\npublic interface MainFactory{\n    DaBen createDaBen();\n}\npublic class DaBenCCreate implements MainFactory{\n    @Override\n    public DaBen createDaBen() {\n        return new DaBenC();\n    }\n}\npublic class DaBenECreate implements MainFactory{\n    @Override\n    public DaBen createDaBen() {\n        return new DaBenE();\n    }\n}\npublic static void main(String[] args) {\n    MainFactory factoryC = new DaBenCCreate();\n    factoryC.createDaBen();\n    MainFactory factoryE = new DaBenECreate();\n    factoryE.createDaBen();\n}\n```\n\n扩展 抽象工厂模式：\n抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。\n\n\n##### 单例模式\n\nSpring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。使用了 双重判断加锁 的单例模式。\n\n```java\npublic Object getSingleton(String beanName){\n    //参数true设置标识允许早期依赖\n    return getSingleton(beanName,true);\n}\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    //检查缓存中是否存在实例\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        //如果为空，则锁定全局变量并进行处理。\n        synchronized (this.singletonObjects) {\n            //如果此bean正在加载，则不处理\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {  \n                //当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    //调用预先设定的getObject方法\n                    singletonObject = singletonFactory.getObject();\n                    //记录在缓存中，earlysingletonObjects和singletonFactories互斥\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n```\n\n\n\n\n##### 适配器模式\n\nAOP中的AdvisorAdapter是一个适配器接口，它定义了自己支持的Advice类型，并且能把一个Advisor适配成MethodInterceptor（这也是AOP联盟定义的借口）\n\n```java\npublic interface AdvisorAdapter {\n\t// 将一个Advisor适配成MethodInterceptor\n\tMethodInterceptor getInterceptor(Advisor advisor);\n\t// 判断此适配器是否支持特定的Advice\n\tboolean supportsAdvice(Advice advice);\n}\n```\n\n\n\n\n##### 代理模式\n\n\nbean初始化的时候的init方法\naopBean初始化的时候直接创建代理类返回\n\n代码示例：\n\n```java\n// 接口\npublic interface Hello {\n    public void sayHello();\n}\n// 实现\npublic class HelloImpl implements Hello {\n    @Override\n    public void sayHello(){\n        System.out.println(\"hello........\");\n    };\n}\n// JDK代理\npublic class JdkProxy implements InvocationHandler  {\n    private Object object;\n    public JdkProxy(Object object) {\n        this.object = object;\n    }\n    public Object newProxy() {\n        return Proxy.newProxyInstance(object.getClass().getClassLoader(),\n                object.getClass().getInterfaces(), this);\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n        System.out.println(\"before...........\");\n        method.invoke(object,args);\n        System.out.println(\"after...........\");\n        return method;\n    }\n}\n// Cglib代理\npublic class CglibProxy implements MethodInterceptor {\n    private Object object;\n    public CglibProxy(Object object) {\n        this.object = object;\n    }\n    public Object createProxyObject() {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(object.getClass());\n        enhancer.setCallback(this);\n        return enhancer.create();\n    }\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"before ................\");\n        method.invoke(object,objects);\n        System.out.println(\"after ................\");\n        return null;\n    }\n}\n// 调用\n@Test\npublic void testJdkProxy() {\n    Hello helloImpl = new HelloImpl();\n    JdkProxy interfaceProxy = new JdkProxy(helloImpl);\n    Hello hello = (Hello) interfaceProxy.newProxy();\n    hello.sayHello();\n}\n\n@Test\npublic void testCglibProxy() {\n    Hello helloImpl = new HelloImpl();\n    CglibProxy interfaceProxy = new CglibProxy(helloImpl);\n    Hello hello = (Hello) interfaceProxy.createProxyObject();\n    hello.sayHello();\n}\n```\n\n\n##### 模板方法模式\n\nspring jdbcTemplate使用了模板方法模式\n\n\n模板方法模式 \n\n优点\n1、封装不变部分，扩展可变部分。\n2、提取公共代码，便于维护。\n3、行为由父类控制，子类实现。\n缺点\n每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n代码：\n\n```java\npublic abstract class OneDay {\n    public abstract void getUp();\n    public abstract void sleep();\n    public void one(){\n        getUp();\n        sleep();\n    }\n}\n\npublic class XiaoMingDay extends OneDay{\n    @Override\n    public void getUp() {\n        System.out.println(\"xiaoming getup ...\");\n    }\n    @Override\n    public void sleep() {\n        System.out.println(\"xiaoming sleep ...\");\n    }\n}\n\n\n\npublic class XiaoWangDay extends OneDay{\n    @Override\n    public void getUp() {\n        System.out.println(\"xiaoWang getup ...\");\n    }\n    @Override\n    public void sleep() {\n        System.out.println(\"xiaoWang sleep ...\");\n    }\n}\npublic static void main(String[] args) {\n        OneDay oneDay = new XiaoMingDay();\n        OneDay oneDay1 = new XiaoWangDay();\n        oneDay.one();\n        oneDay1.one();\n}\n```\n\n\n\n##### 观察者模式\n\nSpring 事件驱动模型就是观察者模式很经典的一个应用。\n\n```java\n\n//注册一个事件\npublic class QuestionEvent extends ApplicationEvent {\n    private String question;\n    public QuestionEvent(String question) {\n        super(question);\n        this.question = question;\n    }\n    public String getQuestion() {\n        return question;\n    }\n    public void setQuestion(String question) {\n        this.question = question;\n    }\n}\n\n// 注册一个观察器\n@Component\npublic class QuestionListener implements ApplicationListener<QuestionEvent> {\n    @Override\n    public void onApplicationEvent(QuestionEvent questionEvent) {\n        System.out.println(\"QuestionListener......................\" + questionEvent.toString());\n    }\n}\n\n// 注册一个发布者\n@Component\npublic class EventPublisher implements ApplicationEventPublisherAware {\n\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n        this.applicationEventPublisher =applicationEventPublisher;\n    }\n\n    public ApplicationEventPublisher getApplicationEventPublisher() {\n        return applicationEventPublisher;\n    }\n}\n\n// 发布消息\n@Test\npublic void testEvent() {\n    String question = \"这是一个问题\";\n    applicationEventPublisher.publishEvent(new QuestionEvent(question));\n}\n```\n\n\n##### 策略模式\n\n代码例子：\n\n```java\n//父类\npublic abstract class Strategy {\n    public abstract void doSomething();\n}\n\n// 实现类\npublic class StrategyA extends Strategy {\n    @Override\n    public void doSomething() {\n        System.out.println(\"A.......\");\n    }\n}\n\npublic class StrategyB extends Strategy {\n    @Override\n    public void doSomething() {\n        System.out.println(\"B.......\");\n    }\n}\n// 策略类\npublic class Context  {\n    private Strategy strategy;\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n    public void contextDoSomething() {\n        strategy.doSomething();\n    }\n}\n// 调用\n@Test\npublic void testEvent() {\n    Context contextA = new Context(new StrategyA());\n    Context contextB = new Context(new StrategyB());\n    contextA.contextDoSomething();\n    contextB.contextDoSomething();\n}\n```","slug":"spring-设计模式","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15b5002c9gj7r2w0mdmf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Spring设计模式</p>\n<h3 id=\"Spring设计模式\"><a href=\"#Spring设计模式\" class=\"headerlink\" title=\"Spring设计模式\"></a>Spring设计模式</h3><h5 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h5><p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>\n<p>实现原理：<br>bean容器的启动阶段：</p>\n<p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。</p>\n<p>简单工厂模式：</p>\n<ul>\n<li>创建抽象父类</li>\n<li>子类继承父类实现抽象方法</li>\n<li>工厂类根据条件产生不同的子类</li>\n</ul>\n<p>缺点：<br>违背了开闭原则,工厂类可能容易成为上帝类。</p>\n<a id=\"more\"></a>\n<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBen</span></span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenC</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenC created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenE</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenE</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenE created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaBen <span class=\"title\">createDaBen</span><span class=\"params\">(String  type)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"C\"</span>.equals(type))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenC();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"E\"</span>.equals(type))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenE();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Factory factory = <span class=\"keyword\">new</span> Factory();</span><br><span class=\"line\">    factory.createDaBen(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    factory.createDaBen(<span class=\"string\">\"E\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h5><p>FactoryBean接口。</p>\n<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>\n<p>工厂方法模式 代码示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBen</span></span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenC</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenC created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenE</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenE</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenE created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainFactory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">DaBen <span class=\"title\">createDaBen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenCCreate</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainFactory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaBen <span class=\"title\">createDaBen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenC();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenECreate</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainFactory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaBen <span class=\"title\">createDaBen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenE();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    MainFactory factoryC = <span class=\"keyword\">new</span> DaBenCCreate();</span><br><span class=\"line\">    factoryC.createDaBen();</span><br><span class=\"line\">    MainFactory factoryE = <span class=\"keyword\">new</span> DaBenECreate();</span><br><span class=\"line\">    factoryE.createDaBen();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>扩展 抽象工厂模式：<br>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。</p>\n<h5 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h5><p>Spring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。使用了 双重判断加锁 的单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//参数true设置标识允许早期依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getSingleton(beanName,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, <span class=\"keyword\">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//检查缓存中是否存在实例</span></span><br><span class=\"line\">    Object singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果为空，则锁定全局变量并进行处理。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果此bean正在加载，则不处理</span></span><br><span class=\"line\">            singletonObject = <span class=\"keyword\">this</span>.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; allowEarlyReference) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">//当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories</span></span><br><span class=\"line\">                ObjectFactory&lt;?&gt; singletonFactory = <span class=\"keyword\">this</span>.singletonFactories.get(beanName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singletonFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//调用预先设定的getObject方法</span></span><br><span class=\"line\">                    singletonObject = singletonFactory.getObject();</span><br><span class=\"line\">                    <span class=\"comment\">//记录在缓存中，earlysingletonObjects和singletonFactories互斥</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.singletonFactories.remove(beanName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h5><p>AOP中的AdvisorAdapter是一个适配器接口，它定义了自己支持的Advice类型，并且能把一个Advisor适配成MethodInterceptor（这也是AOP联盟定义的借口）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AdvisorAdapter</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将一个Advisor适配成MethodInterceptor</span></span><br><span class=\"line\">\t<span class=\"function\">MethodInterceptor <span class=\"title\">getInterceptor</span><span class=\"params\">(Advisor advisor)</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断此适配器是否支持特定的Advice</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supportsAdvice</span><span class=\"params\">(Advice advice)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h5><p>bean初始化的时候的init方法<br>aopBean初始化的时候直接创建代理类返回</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello........\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JdkProxy</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">newProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),</span><br><span class=\"line\">                object.getClass().getInterfaces(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before...........\"</span>);</span><br><span class=\"line\">        method.invoke(object,args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after...........\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Cglib代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CglibProxy</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">createProxyObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        enhancer.setSuperclass(object.getClass());</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before ................\"</span>);</span><br><span class=\"line\">        method.invoke(object,objects);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after ................\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testJdkProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Hello helloImpl = <span class=\"keyword\">new</span> HelloImpl();</span><br><span class=\"line\">    JdkProxy interfaceProxy = <span class=\"keyword\">new</span> JdkProxy(helloImpl);</span><br><span class=\"line\">    Hello hello = (Hello) interfaceProxy.newProxy();</span><br><span class=\"line\">    hello.sayHello();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCglibProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Hello helloImpl = <span class=\"keyword\">new</span> HelloImpl();</span><br><span class=\"line\">    CglibProxy interfaceProxy = <span class=\"keyword\">new</span> CglibProxy(helloImpl);</span><br><span class=\"line\">    Hello hello = (Hello) interfaceProxy.createProxyObject();</span><br><span class=\"line\">    hello.sayHello();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h5><p>spring jdbcTemplate使用了模板方法模式</p>\n<p>模板方法模式 </p>\n<p>优点<br>1、封装不变部分，扩展可变部分。<br>2、提取公共代码，便于维护。<br>3、行为由父类控制，子类实现。<br>缺点<br>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>\n<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneDay</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">getUp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">one</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        getUp();</span><br><span class=\"line\">        sleep();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoMingDay</span> <span class=\"keyword\">extends</span> <span class=\"title\">OneDay</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoming getup ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoming sleep ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoWangDay</span> <span class=\"keyword\">extends</span> <span class=\"title\">OneDay</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoWang getup ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoWang sleep ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        OneDay oneDay = <span class=\"keyword\">new</span> XiaoMingDay();</span><br><span class=\"line\">        OneDay oneDay1 = <span class=\"keyword\">new</span> XiaoWangDay();</span><br><span class=\"line\">        oneDay.one();</span><br><span class=\"line\">        oneDay1.one();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h5><p>Spring 事件驱动模型就是观察者模式很经典的一个应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册一个事件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuestionEvent</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationEvent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String question;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuestionEvent</span><span class=\"params\">(String question)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(question);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.question = question;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getQuestion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> question;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setQuestion</span><span class=\"params\">(String question)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.question = question;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个观察器</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuestionListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">QuestionEvent</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(QuestionEvent questionEvent)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"QuestionListener......................\"</span> + questionEvent.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个发布者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventPublisher</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationEventPublisher</span><span class=\"params\">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.applicationEventPublisher =applicationEventPublisher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ApplicationEventPublisher <span class=\"title\">getApplicationEventPublisher</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationEventPublisher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发布消息</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testEvent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String question = <span class=\"string\">\"这是一个问题\"</span>;</span><br><span class=\"line\">    applicationEventPublisher.publishEvent(<span class=\"keyword\">new</span> QuestionEvent(question));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h5><p>代码例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"A.......\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"B.......\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 策略类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Strategy strategy;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Context</span><span class=\"params\">(Strategy strategy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.strategy = strategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        strategy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testEvent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Context contextA = <span class=\"keyword\">new</span> Context(<span class=\"keyword\">new</span> StrategyA());</span><br><span class=\"line\">    Context contextB = <span class=\"keyword\">new</span> Context(<span class=\"keyword\">new</span> StrategyB());</span><br><span class=\"line\">    contextA.contextDoSomething();</span><br><span class=\"line\">    contextB.contextDoSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Spring设计模式</p>\n<h3 id=\"Spring设计模式\"><a href=\"#Spring设计模式\" class=\"headerlink\" title=\"Spring设计模式\"></a>Spring设计模式</h3><h5 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h5><p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>\n<p>实现原理：<br>bean容器的启动阶段：</p>\n<p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。<br>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。<br>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。</p>\n<p>简单工厂模式：</p>\n<ul>\n<li>创建抽象父类</li>\n<li>子类继承父类实现抽象方法</li>\n<li>工厂类根据条件产生不同的子类</li>\n</ul>\n<p>缺点：<br>违背了开闭原则,工厂类可能容易成为上帝类。</p>","more":"<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBen</span></span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenC</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenC created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenE</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenE</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenE created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaBen <span class=\"title\">createDaBen</span><span class=\"params\">(String  type)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"C\"</span>.equals(type))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenC();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"E\"</span>.equals(type))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenE();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Factory factory = <span class=\"keyword\">new</span> Factory();</span><br><span class=\"line\">    factory.createDaBen(<span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    factory.createDaBen(<span class=\"string\">\"E\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h5><p>FactoryBean接口。</p>\n<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>\n<p>工厂方法模式 代码示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBen</span></span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenC</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenC created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenE</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaBen</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaBenE</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"DaBenE created....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MainFactory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">DaBen <span class=\"title\">createDaBen</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenCCreate</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainFactory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaBen <span class=\"title\">createDaBen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenC();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaBenECreate</span> <span class=\"keyword\">implements</span> <span class=\"title\">MainFactory</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DaBen <span class=\"title\">createDaBen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DaBenE();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    MainFactory factoryC = <span class=\"keyword\">new</span> DaBenCCreate();</span><br><span class=\"line\">    factoryC.createDaBen();</span><br><span class=\"line\">    MainFactory factoryE = <span class=\"keyword\">new</span> DaBenECreate();</span><br><span class=\"line\">    factoryE.createDaBen();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>扩展 抽象工厂模式：<br>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。</p>\n<h5 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h5><p>Spring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。使用了 双重判断加锁 的单例模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//参数true设置标识允许早期依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getSingleton(beanName,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, <span class=\"keyword\">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//检查缓存中是否存在实例</span></span><br><span class=\"line\">    Object singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果为空，则锁定全局变量并进行处理。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.singletonObjects) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果此bean正在加载，则不处理</span></span><br><span class=\"line\">            singletonObject = <span class=\"keyword\">this</span>.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span> &amp;&amp; allowEarlyReference) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">//当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories</span></span><br><span class=\"line\">                ObjectFactory&lt;?&gt; singletonFactory = <span class=\"keyword\">this</span>.singletonFactories.get(beanName);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singletonFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//调用预先设定的getObject方法</span></span><br><span class=\"line\">                    singletonObject = singletonFactory.getObject();</span><br><span class=\"line\">                    <span class=\"comment\">//记录在缓存中，earlysingletonObjects和singletonFactories互斥</span></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.singletonFactories.remove(beanName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h5><p>AOP中的AdvisorAdapter是一个适配器接口，它定义了自己支持的Advice类型，并且能把一个Advisor适配成MethodInterceptor（这也是AOP联盟定义的借口）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AdvisorAdapter</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将一个Advisor适配成MethodInterceptor</span></span><br><span class=\"line\">\t<span class=\"function\">MethodInterceptor <span class=\"title\">getInterceptor</span><span class=\"params\">(Advisor advisor)</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断此适配器是否支持特定的Advice</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supportsAdvice</span><span class=\"params\">(Advice advice)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h5><p>bean初始化的时候的init方法<br>aopBean初始化的时候直接创建代理类返回</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello........\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JdkProxy</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">newProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(),</span><br><span class=\"line\">                object.getClass().getInterfaces(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before...........\"</span>);</span><br><span class=\"line\">        method.invoke(object,args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after...........\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Cglib代理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CglibProxy</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">createProxyObject</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        enhancer.setSuperclass(object.getClass());</span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before ................\"</span>);</span><br><span class=\"line\">        method.invoke(object,objects);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after ................\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testJdkProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Hello helloImpl = <span class=\"keyword\">new</span> HelloImpl();</span><br><span class=\"line\">    JdkProxy interfaceProxy = <span class=\"keyword\">new</span> JdkProxy(helloImpl);</span><br><span class=\"line\">    Hello hello = (Hello) interfaceProxy.newProxy();</span><br><span class=\"line\">    hello.sayHello();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCglibProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Hello helloImpl = <span class=\"keyword\">new</span> HelloImpl();</span><br><span class=\"line\">    CglibProxy interfaceProxy = <span class=\"keyword\">new</span> CglibProxy(helloImpl);</span><br><span class=\"line\">    Hello hello = (Hello) interfaceProxy.createProxyObject();</span><br><span class=\"line\">    hello.sayHello();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h5><p>spring jdbcTemplate使用了模板方法模式</p>\n<p>模板方法模式 </p>\n<p>优点<br>1、封装不变部分，扩展可变部分。<br>2、提取公共代码，便于维护。<br>3、行为由父类控制，子类实现。<br>缺点<br>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>\n<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneDay</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">getUp</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">one</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        getUp();</span><br><span class=\"line\">        sleep();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoMingDay</span> <span class=\"keyword\">extends</span> <span class=\"title\">OneDay</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoming getup ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoming sleep ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoWangDay</span> <span class=\"keyword\">extends</span> <span class=\"title\">OneDay</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoWang getup ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sleep</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"xiaoWang sleep ...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        OneDay oneDay = <span class=\"keyword\">new</span> XiaoMingDay();</span><br><span class=\"line\">        OneDay oneDay1 = <span class=\"keyword\">new</span> XiaoWangDay();</span><br><span class=\"line\">        oneDay.one();</span><br><span class=\"line\">        oneDay1.one();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h5><p>Spring 事件驱动模型就是观察者模式很经典的一个应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注册一个事件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuestionEvent</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationEvent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String question;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuestionEvent</span><span class=\"params\">(String question)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(question);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.question = question;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getQuestion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> question;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setQuestion</span><span class=\"params\">(String question)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.question = question;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个观察器</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuestionListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationListener</span>&lt;<span class=\"title\">QuestionEvent</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(QuestionEvent questionEvent)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"QuestionListener......................\"</span> + questionEvent.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个发布者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventPublisher</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationEventPublisher</span><span class=\"params\">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.applicationEventPublisher =applicationEventPublisher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ApplicationEventPublisher <span class=\"title\">getApplicationEventPublisher</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationEventPublisher;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发布消息</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testEvent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String question = <span class=\"string\">\"这是一个问题\"</span>;</span><br><span class=\"line\">    applicationEventPublisher.publishEvent(<span class=\"keyword\">new</span> QuestionEvent(question));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h5><p>代码例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"A.......\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"B.......\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 策略类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Strategy strategy;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Context</span><span class=\"params\">(Strategy strategy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.strategy = strategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDoSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        strategy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testEvent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Context contextA = <span class=\"keyword\">new</span> Context(<span class=\"keyword\">new</span> StrategyA());</span><br><span class=\"line\">    Context contextB = <span class=\"keyword\">new</span> Context(<span class=\"keyword\">new</span> StrategyB());</span><br><span class=\"line\">    contextA.contextDoSomething();</span><br><span class=\"line\">    contextB.contextDoSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Zookeeper集成java","_content":"\n#### 源生API\n\n```java\n    //Maven配置\n    <dependency>\n        <groupId>org.apache.zookeeper</groupId>\n        <artifactId>zookeeper</artifactId>\n        <version>3.4.6</version>\n    </dependency>\n```\n\n```java\n    private static final int SESSION_TIMEOUT = 10000;\n    private static final String CONNECTION_STRING = \"127.0.0.1:2181\";\n    private static final String ZK_PATH = \"/leader\";\n    private ZooKeeper zk = null;\n\n    private CountDownLatch connectedSemaphore = new CountDownLatch(1);\n\n    /**\n     * 创建ZK连接\n     *\n     * @param connectString  ZK服务器地址列表\n     * @param sessionTimeout Session超时时间\n     */\n    public void createConnection(String connectString, int sessionTimeout) {\n        this.releaseConnection();\n        try {\n            // this代表有监听\n            zk = new ZooKeeper(connectString, sessionTimeout, this);\n            connectedSemaphore.await();\n        } catch (InterruptedException e) {\n            System.out.println(\"连接创建失败，发生 InterruptedException\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"连接创建失败，发生 IOException\");\n            e.printStackTrace();\n        }\n    }\n```\n<!-- more --> \n\n监听：\n\n```java\n// 实现Watcher接口\npublic class ZooKeeperWatcher implements Watcher  {\n    @Override\n    public void process(WatchedEvent watchedEvent) {\n        \n    }\n}\n```\n\n#### ZKClient\n\n```java\n    //Maven配置\n    <dependency>\n        <groupId>com.101tec</groupId>\n        <artifactId>zkclient</artifactId>\n        <version>0.10</version>\n    </dependency>\n```\n\n连接：\n\n```java\n    ZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);\n```\n\n监听：\n\n```java\n public void testZkClientWatcher2() throws Exception {\n        ZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);\n\n        zkc.createPersistent(\"/super\", \"1234\");\n\n        //对父节点添加监听子节点变化。\n        zkc.subscribeChildChanges(\"/super\", new IZkChildListener() {\n            @Override\n            public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n                System.out.println(\"parentPath: \" + parentPath);\n                System.out.println(\"currentChilds: \" + currentChilds);\n            }\n        });\n\n        //对父节点添加监听子节点内容变化。\n        zkc.subscribeDataChanges(\"/super\", new IZkDataListener() {\n            @Override\n            public void handleDataDeleted(String path) throws Exception {\n                System.out.println(\"删除的节点为:\" + path);\n            }\n\n            @Override\n            public void handleDataChange(String path, Object data) throws Exception {\n                System.out.println(\"变更的节点为:\" + path + \", 变更内容为:\" + data);\n            }\n        });\n\n        Thread.sleep(3000);\n        zkc.writeData(\"/super\", \"456\", -1);\n        Thread.sleep(1000);\n\n        zkc.delete(\"/super\");\n        Thread.sleep(Integer.MAX_VALUE);\n\n    }\n```\n\n#### Curator\n\n```java\n    //Maven配置\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-framework</artifactId>\n        <version>4.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>4.0.0</version>\n    </dependency>\n```\n\n启动：\n\n\n```java\n    public void init(){\n        //创建 CuratorFrameworkImpl实例\n        client = CuratorFrameworkFactory.newClient(SERVER, SESSION_TIMEOUT, CONNECTION_TIMEOUT, retryPolicy);\n\n        //启动\n        client.start();\n    }\n```\n\n```java\n      public void setListenterTwoOne() throws Exception{\n        ExecutorService pool = Executors.newCachedThreadPool();\n        PathChildrenCache childrenCache = new PathChildrenCache(client, \"/test\", true);\n        PathChildrenCacheListener childrenCacheListener = new PathChildrenCacheListener() {\n            @Override\n            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {\n                System.out.println(\"开始进行事件分析:-----\");\n                ChildData data = event.getData();\n                switch (event.getType()) {\n                    case CHILD_ADDED:\n                        System.out.println(\"CHILD_ADDED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    case CHILD_REMOVED:\n                        System.out.println(\"CHILD_REMOVED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    case CHILD_UPDATED:\n                        System.out.println(\"CHILD_UPDATED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    case INITIALIZED:\n                        System.out.println(\"INITIALIZED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    default:\n                        break;\n                }\n            }\n        };\n        childrenCache.getListenable().addListener(childrenCacheListener);\n        System.out.println(\"Register zk watcher successfully!\");\n        childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);\n\n        //创建一个节点\n        client.create().orSetData().withMode(CreateMode.PERSISTENT).forPath(\"/test\",\"test\".getBytes());\n\n        client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(\"/test/node01\",\"enjoy\".getBytes());\n        Thread.sleep(1000);\n        client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(\"/test/node02\",\"deer\".getBytes());\n        Thread.sleep(1000);\n        client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(\"/test/node02\",\"demo\".getBytes());\n        Thread.sleep(1000);\n        client.delete().forPath(\"/test/node02\");\n        Thread.sleep(10000);\n    }\n```\n\n\n\n\n\n\n\n\n","source":"_posts/zookeeper集成java.md","raw":"---\ntitle: Zookeeper集成java\ntags:\n  - zookeeper\n---\n\n#### 源生API\n\n```java\n    //Maven配置\n    <dependency>\n        <groupId>org.apache.zookeeper</groupId>\n        <artifactId>zookeeper</artifactId>\n        <version>3.4.6</version>\n    </dependency>\n```\n\n```java\n    private static final int SESSION_TIMEOUT = 10000;\n    private static final String CONNECTION_STRING = \"127.0.0.1:2181\";\n    private static final String ZK_PATH = \"/leader\";\n    private ZooKeeper zk = null;\n\n    private CountDownLatch connectedSemaphore = new CountDownLatch(1);\n\n    /**\n     * 创建ZK连接\n     *\n     * @param connectString  ZK服务器地址列表\n     * @param sessionTimeout Session超时时间\n     */\n    public void createConnection(String connectString, int sessionTimeout) {\n        this.releaseConnection();\n        try {\n            // this代表有监听\n            zk = new ZooKeeper(connectString, sessionTimeout, this);\n            connectedSemaphore.await();\n        } catch (InterruptedException e) {\n            System.out.println(\"连接创建失败，发生 InterruptedException\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.out.println(\"连接创建失败，发生 IOException\");\n            e.printStackTrace();\n        }\n    }\n```\n<!-- more --> \n\n监听：\n\n```java\n// 实现Watcher接口\npublic class ZooKeeperWatcher implements Watcher  {\n    @Override\n    public void process(WatchedEvent watchedEvent) {\n        \n    }\n}\n```\n\n#### ZKClient\n\n```java\n    //Maven配置\n    <dependency>\n        <groupId>com.101tec</groupId>\n        <artifactId>zkclient</artifactId>\n        <version>0.10</version>\n    </dependency>\n```\n\n连接：\n\n```java\n    ZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);\n```\n\n监听：\n\n```java\n public void testZkClientWatcher2() throws Exception {\n        ZkClient zkc = new ZkClient(new ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);\n\n        zkc.createPersistent(\"/super\", \"1234\");\n\n        //对父节点添加监听子节点变化。\n        zkc.subscribeChildChanges(\"/super\", new IZkChildListener() {\n            @Override\n            public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception {\n                System.out.println(\"parentPath: \" + parentPath);\n                System.out.println(\"currentChilds: \" + currentChilds);\n            }\n        });\n\n        //对父节点添加监听子节点内容变化。\n        zkc.subscribeDataChanges(\"/super\", new IZkDataListener() {\n            @Override\n            public void handleDataDeleted(String path) throws Exception {\n                System.out.println(\"删除的节点为:\" + path);\n            }\n\n            @Override\n            public void handleDataChange(String path, Object data) throws Exception {\n                System.out.println(\"变更的节点为:\" + path + \", 变更内容为:\" + data);\n            }\n        });\n\n        Thread.sleep(3000);\n        zkc.writeData(\"/super\", \"456\", -1);\n        Thread.sleep(1000);\n\n        zkc.delete(\"/super\");\n        Thread.sleep(Integer.MAX_VALUE);\n\n    }\n```\n\n#### Curator\n\n```java\n    //Maven配置\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-framework</artifactId>\n        <version>4.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>4.0.0</version>\n    </dependency>\n```\n\n启动：\n\n\n```java\n    public void init(){\n        //创建 CuratorFrameworkImpl实例\n        client = CuratorFrameworkFactory.newClient(SERVER, SESSION_TIMEOUT, CONNECTION_TIMEOUT, retryPolicy);\n\n        //启动\n        client.start();\n    }\n```\n\n```java\n      public void setListenterTwoOne() throws Exception{\n        ExecutorService pool = Executors.newCachedThreadPool();\n        PathChildrenCache childrenCache = new PathChildrenCache(client, \"/test\", true);\n        PathChildrenCacheListener childrenCacheListener = new PathChildrenCacheListener() {\n            @Override\n            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {\n                System.out.println(\"开始进行事件分析:-----\");\n                ChildData data = event.getData();\n                switch (event.getType()) {\n                    case CHILD_ADDED:\n                        System.out.println(\"CHILD_ADDED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    case CHILD_REMOVED:\n                        System.out.println(\"CHILD_REMOVED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    case CHILD_UPDATED:\n                        System.out.println(\"CHILD_UPDATED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    case INITIALIZED:\n                        System.out.println(\"INITIALIZED : \"+ data.getPath() +\"  数据:\"+ data.getData());\n                        break;\n                    default:\n                        break;\n                }\n            }\n        };\n        childrenCache.getListenable().addListener(childrenCacheListener);\n        System.out.println(\"Register zk watcher successfully!\");\n        childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);\n\n        //创建一个节点\n        client.create().orSetData().withMode(CreateMode.PERSISTENT).forPath(\"/test\",\"test\".getBytes());\n\n        client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(\"/test/node01\",\"enjoy\".getBytes());\n        Thread.sleep(1000);\n        client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(\"/test/node02\",\"deer\".getBytes());\n        Thread.sleep(1000);\n        client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(\"/test/node02\",\"demo\".getBytes());\n        Thread.sleep(1000);\n        client.delete().forPath(\"/test/node02\");\n        Thread.sleep(10000);\n    }\n```\n\n\n\n\n\n\n\n\n","slug":"zookeeper集成java","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15b6002e9gj7dmojv78o","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"源生API\"><a href=\"#源生API\" class=\"headerlink\" title=\"源生API\"></a>源生API</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maven配置</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SESSION_TIMEOUT = <span class=\"number\">10000</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONNECTION_STRING = <span class=\"string\">\"127.0.0.1:2181\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ZK_PATH = <span class=\"string\">\"/leader\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> CountDownLatch connectedSemaphore = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建ZK连接</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> connectString  ZK服务器地址列表</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> sessionTimeout Session超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createConnection</span><span class=\"params\">(String connectString, <span class=\"keyword\">int</span> sessionTimeout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.releaseConnection();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this代表有监听</span></span><br><span class=\"line\">        zk = <span class=\"keyword\">new</span> ZooKeeper(connectString, sessionTimeout, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        connectedSemaphore.await();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"连接创建失败，发生 InterruptedException\"</span>);</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"连接创建失败，发生 IOException\"</span>);</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a> \n<p>监听：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现Watcher接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZooKeeperWatcher</span> <span class=\"keyword\">implements</span> <span class=\"title\">Watcher</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ZKClient\"><a href=\"#ZKClient\" class=\"headerlink\" title=\"ZKClient\"></a>ZKClient</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maven配置</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;0.10&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>连接：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZkClient zkc = <span class=\"keyword\">new</span> ZkClient(<span class=\"keyword\">new</span> ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);</span><br></pre></td></tr></table></figure>\n<p>监听：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testZkClientWatcher2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       ZkClient zkc = <span class=\"keyword\">new</span> ZkClient(<span class=\"keyword\">new</span> ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);</span><br><span class=\"line\"></span><br><span class=\"line\">       zkc.createPersistent(<span class=\"string\">\"/super\"</span>, <span class=\"string\">\"1234\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//对父节点添加监听子节点变化。</span></span><br><span class=\"line\">       zkc.subscribeChildChanges(<span class=\"string\">\"/super\"</span>, <span class=\"keyword\">new</span> IZkChildListener() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleChildChange</span><span class=\"params\">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"parentPath: \"</span> + parentPath);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"currentChilds: \"</span> + currentChilds);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//对父节点添加监听子节点内容变化。</span></span><br><span class=\"line\">       zkc.subscribeDataChanges(<span class=\"string\">\"/super\"</span>, <span class=\"keyword\">new</span> IZkDataListener() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"删除的节点为:\"</span> + path);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String path, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"变更的节点为:\"</span> + path + <span class=\"string\">\", 变更内容为:\"</span> + data);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">       zkc.writeData(<span class=\"string\">\"/super\"</span>, <span class=\"string\">\"456\"</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">       Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       zkc.delete(<span class=\"string\">\"/super\"</span>);</span><br><span class=\"line\">       Thread.sleep(Integer.MAX_VALUE);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Curator\"><a href=\"#Curator\" class=\"headerlink\" title=\"Curator\"></a>Curator</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maven配置</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>启动：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建 CuratorFrameworkImpl实例</span></span><br><span class=\"line\">    client = CuratorFrameworkFactory.newClient(SERVER, SESSION_TIMEOUT, CONNECTION_TIMEOUT, retryPolicy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//启动</span></span><br><span class=\"line\">    client.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setListenterTwoOne</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class=\"line\">    PathChildrenCache childrenCache = <span class=\"keyword\">new</span> PathChildrenCache(client, <span class=\"string\">\"/test\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    PathChildrenCacheListener childrenCacheListener = <span class=\"keyword\">new</span> PathChildrenCacheListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">childEvent</span><span class=\"params\">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"开始进行事件分析:-----\"</span>);</span><br><span class=\"line\">            ChildData data = event.getData();</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (event.getType()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> CHILD_ADDED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"CHILD_ADDED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> CHILD_REMOVED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"CHILD_REMOVED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> CHILD_UPDATED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"CHILD_UPDATED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> INITIALIZED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"INITIALIZED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    childrenCache.getListenable().addListener(childrenCacheListener);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Register zk watcher successfully!\"</span>);</span><br><span class=\"line\">    childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个节点</span></span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.PERSISTENT).forPath(<span class=\"string\">\"/test\"</span>,<span class=\"string\">\"test\"</span>.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">\"/test/node01\"</span>,<span class=\"string\">\"enjoy\"</span>.getBytes());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">\"/test/node02\"</span>,<span class=\"string\">\"deer\"</span>.getBytes());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">\"/test/node02\"</span>,<span class=\"string\">\"demo\"</span>.getBytes());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    client.delete().forPath(<span class=\"string\">\"/test/node02\"</span>);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"源生API\"><a href=\"#源生API\" class=\"headerlink\" title=\"源生API\"></a>源生API</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maven配置</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.4.6&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SESSION_TIMEOUT = <span class=\"number\">10000</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CONNECTION_STRING = <span class=\"string\">\"127.0.0.1:2181\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ZK_PATH = <span class=\"string\">\"/leader\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> ZooKeeper zk = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> CountDownLatch connectedSemaphore = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建ZK连接</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> connectString  ZK服务器地址列表</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> sessionTimeout Session超时时间</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createConnection</span><span class=\"params\">(String connectString, <span class=\"keyword\">int</span> sessionTimeout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.releaseConnection();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this代表有监听</span></span><br><span class=\"line\">        zk = <span class=\"keyword\">new</span> ZooKeeper(connectString, sessionTimeout, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        connectedSemaphore.await();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"连接创建失败，发生 InterruptedException\"</span>);</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"连接创建失败，发生 IOException\"</span>);</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>监听：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现Watcher接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZooKeeperWatcher</span> <span class=\"keyword\">implements</span> <span class=\"title\">Watcher</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ZKClient\"><a href=\"#ZKClient\" class=\"headerlink\" title=\"ZKClient\"></a>ZKClient</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maven配置</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.101tec&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;0.10&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>连接：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZkClient zkc = <span class=\"keyword\">new</span> ZkClient(<span class=\"keyword\">new</span> ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);</span><br></pre></td></tr></table></figure>\n<p>监听：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testZkClientWatcher2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       ZkClient zkc = <span class=\"keyword\">new</span> ZkClient(<span class=\"keyword\">new</span> ZkConnection(CONNECT_ADDR), SESSION_OUTTIME);</span><br><span class=\"line\"></span><br><span class=\"line\">       zkc.createPersistent(<span class=\"string\">\"/super\"</span>, <span class=\"string\">\"1234\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//对父节点添加监听子节点变化。</span></span><br><span class=\"line\">       zkc.subscribeChildChanges(<span class=\"string\">\"/super\"</span>, <span class=\"keyword\">new</span> IZkChildListener() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleChildChange</span><span class=\"params\">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"parentPath: \"</span> + parentPath);</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"currentChilds: \"</span> + currentChilds);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//对父节点添加监听子节点内容变化。</span></span><br><span class=\"line\">       zkc.subscribeDataChanges(<span class=\"string\">\"/super\"</span>, <span class=\"keyword\">new</span> IZkDataListener() &#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataDeleted</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"删除的节点为:\"</span> + path);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDataChange</span><span class=\"params\">(String path, Object data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">               System.out.println(<span class=\"string\">\"变更的节点为:\"</span> + path + <span class=\"string\">\", 变更内容为:\"</span> + data);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">       Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">       zkc.writeData(<span class=\"string\">\"/super\"</span>, <span class=\"string\">\"456\"</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">       Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       zkc.delete(<span class=\"string\">\"/super\"</span>);</span><br><span class=\"line\">       Thread.sleep(Integer.MAX_VALUE);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Curator\"><a href=\"#Curator\" class=\"headerlink\" title=\"Curator\"></a>Curator</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maven配置</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>启动：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建 CuratorFrameworkImpl实例</span></span><br><span class=\"line\">    client = CuratorFrameworkFactory.newClient(SERVER, SESSION_TIMEOUT, CONNECTION_TIMEOUT, retryPolicy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//启动</span></span><br><span class=\"line\">    client.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setListenterTwoOne</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class=\"line\">    PathChildrenCache childrenCache = <span class=\"keyword\">new</span> PathChildrenCache(client, <span class=\"string\">\"/test\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    PathChildrenCacheListener childrenCacheListener = <span class=\"keyword\">new</span> PathChildrenCacheListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">childEvent</span><span class=\"params\">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"开始进行事件分析:-----\"</span>);</span><br><span class=\"line\">            ChildData data = event.getData();</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (event.getType()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> CHILD_ADDED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"CHILD_ADDED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> CHILD_REMOVED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"CHILD_REMOVED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> CHILD_UPDATED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"CHILD_UPDATED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> INITIALIZED:</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"INITIALIZED : \"</span>+ data.getPath() +<span class=\"string\">\"  数据:\"</span>+ data.getData());</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    childrenCache.getListenable().addListener(childrenCacheListener);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Register zk watcher successfully!\"</span>);</span><br><span class=\"line\">    childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建一个节点</span></span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.PERSISTENT).forPath(<span class=\"string\">\"/test\"</span>,<span class=\"string\">\"test\"</span>.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">\"/test/node01\"</span>,<span class=\"string\">\"enjoy\"</span>.getBytes());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">\"/test/node02\"</span>,<span class=\"string\">\"deer\"</span>.getBytes());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    client.create().orSetData().withMode(CreateMode.EPHEMERAL).forPath(<span class=\"string\">\"/test/node02\"</span>,<span class=\"string\">\"demo\"</span>.getBytes());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    client.delete().forPath(<span class=\"string\">\"/test/node02\"</span>);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Zookeeper集群","_content":"\n\n#### Zookeeper集群\n\n- 顺序一致性\n\t客户端的更新顺序与它们被发送的顺序相一致。\n- 原子性\n\t更新操作要么成功要么失败，没有第三种结果。\n- 单一视图\n\t无论客户端连接到哪一个服务器，客户端将看到相同的 ZooKeeper 视图。\n- 可靠性\n\t一旦一个更新操作被应用，那么在客户端再次更新它之前，它的值将不会改变。\n- 实时性\n\t连接上一个服务端数据修改，所以其他的服务端都会实时的跟新，不算完全的实时，有一点延时的\n- 角色轮换避免单点故障\n\t当leader出现问题的时候，会选举从follower中选举一个新的leader\n\n\n\n#### 集群角色\n\n- Leader  集群工作机制中的核心\n\t- 事务请求的唯一调度和处理者，保证集群事务处理的顺序性\n\t- 集群内部个服务器的调度者(管理follower,数据同步)\n- Follower  集群工作机制中的跟随者\n\t- 处理非事务请求，转发事务请求给Leader\n\t- 参与事务请求proposal投票\n参与leader选举投票\n- Observer 观察者  \n\t- 3.30以上版本提供，和follower功能相同，但不参与任何形式投票\n\t- 处理非事务请求，转发事务请求给Leader\n\t- 提高集群非事务处理能力\n\n<!-- more -->  \n\n#### 集群配置\n\n配置文件后添加(zoo.cfg)：\n\n```sh\nserver.0=192.168.212.155:2888:3888\nserver.1=192.168.212.156:2888:3888\nserver.2=192.168.212.157:2888:3888\n```\n\t\n\n设置data目录(自定义目录)(zoo.cfg)：\n\n```sh\ndataDir=/usr/local/zookeeper/data\n```\n\n服务器配置：\n\n\n```sh\n#在/usr/local/zookeeper/data路径创建文件myid并填写内容为0 于server.0对应\n```\n\n启动多台zk 单台是无法启动的。\n\n#### Java客户端连接集群\n\n逗号连接\n\n```java\n ZkClient zkClient = new ZkClient(\"host1,host2,host3\");\n```\n\n\n\n\n\n","source":"_posts/zookeeper集群.md","raw":"---\ntitle: Zookeeper集群\ntags:\n  - zookeeper\n---\n\n\n#### Zookeeper集群\n\n- 顺序一致性\n\t客户端的更新顺序与它们被发送的顺序相一致。\n- 原子性\n\t更新操作要么成功要么失败，没有第三种结果。\n- 单一视图\n\t无论客户端连接到哪一个服务器，客户端将看到相同的 ZooKeeper 视图。\n- 可靠性\n\t一旦一个更新操作被应用，那么在客户端再次更新它之前，它的值将不会改变。\n- 实时性\n\t连接上一个服务端数据修改，所以其他的服务端都会实时的跟新，不算完全的实时，有一点延时的\n- 角色轮换避免单点故障\n\t当leader出现问题的时候，会选举从follower中选举一个新的leader\n\n\n\n#### 集群角色\n\n- Leader  集群工作机制中的核心\n\t- 事务请求的唯一调度和处理者，保证集群事务处理的顺序性\n\t- 集群内部个服务器的调度者(管理follower,数据同步)\n- Follower  集群工作机制中的跟随者\n\t- 处理非事务请求，转发事务请求给Leader\n\t- 参与事务请求proposal投票\n参与leader选举投票\n- Observer 观察者  \n\t- 3.30以上版本提供，和follower功能相同，但不参与任何形式投票\n\t- 处理非事务请求，转发事务请求给Leader\n\t- 提高集群非事务处理能力\n\n<!-- more -->  \n\n#### 集群配置\n\n配置文件后添加(zoo.cfg)：\n\n```sh\nserver.0=192.168.212.155:2888:3888\nserver.1=192.168.212.156:2888:3888\nserver.2=192.168.212.157:2888:3888\n```\n\t\n\n设置data目录(自定义目录)(zoo.cfg)：\n\n```sh\ndataDir=/usr/local/zookeeper/data\n```\n\n服务器配置：\n\n\n```sh\n#在/usr/local/zookeeper/data路径创建文件myid并填写内容为0 于server.0对应\n```\n\n启动多台zk 单台是无法启动的。\n\n#### Java客户端连接集群\n\n逗号连接\n\n```java\n ZkClient zkClient = new ZkClient(\"host1,host2,host3\");\n```\n\n\n\n\n\n","slug":"zookeeper集群","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15b7002g9gj7nfo592hl","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"Zookeeper集群\"><a href=\"#Zookeeper集群\" class=\"headerlink\" title=\"Zookeeper集群\"></a>Zookeeper集群</h4><ul>\n<li>顺序一致性<br>  客户端的更新顺序与它们被发送的顺序相一致。</li>\n<li>原子性<br>  更新操作要么成功要么失败，没有第三种结果。</li>\n<li>单一视图<br>  无论客户端连接到哪一个服务器，客户端将看到相同的 ZooKeeper 视图。</li>\n<li>可靠性<br>  一旦一个更新操作被应用，那么在客户端再次更新它之前，它的值将不会改变。</li>\n<li>实时性<br>  连接上一个服务端数据修改，所以其他的服务端都会实时的跟新，不算完全的实时，有一点延时的</li>\n<li>角色轮换避免单点故障<br>  当leader出现问题的时候，会选举从follower中选举一个新的leader</li>\n</ul>\n<h4 id=\"集群角色\"><a href=\"#集群角色\" class=\"headerlink\" title=\"集群角色\"></a>集群角色</h4><ul>\n<li>Leader  集群工作机制中的核心<ul>\n<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>\n<li>集群内部个服务器的调度者(管理follower,数据同步)</li>\n</ul>\n</li>\n<li>Follower  集群工作机制中的跟随者<ul>\n<li>处理非事务请求，转发事务请求给Leader</li>\n<li>参与事务请求proposal投票<br>参与leader选举投票</li>\n</ul>\n</li>\n<li>Observer 观察者  <ul>\n<li>3.30以上版本提供，和follower功能相同，但不参与任何形式投票</li>\n<li>处理非事务请求，转发事务请求给Leader</li>\n<li>提高集群非事务处理能力</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>  \n<h4 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h4><p>配置文件后添加(zoo.cfg)：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.0=192.168.212.155:2888:3888</span><br><span class=\"line\">server.1=192.168.212.156:2888:3888</span><br><span class=\"line\">server.2=192.168.212.157:2888:3888</span><br></pre></td></tr></table></figure>\n<p>设置data目录(自定义目录)(zoo.cfg)：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataDir=/usr/<span class=\"built_in\">local</span>/zookeeper/data</span><br></pre></td></tr></table></figure>\n<p>服务器配置：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在/usr/local/zookeeper/data路径创建文件myid并填写内容为0 于server.0对应</span></span><br></pre></td></tr></table></figure>\n<p>启动多台zk 单台是无法启动的。</p>\n<h4 id=\"Java客户端连接集群\"><a href=\"#Java客户端连接集群\" class=\"headerlink\" title=\"Java客户端连接集群\"></a>Java客户端连接集群</h4><p>逗号连接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZkClient zkClient = <span class=\"keyword\">new</span> ZkClient(<span class=\"string\">\"host1,host2,host3\"</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"Zookeeper集群\"><a href=\"#Zookeeper集群\" class=\"headerlink\" title=\"Zookeeper集群\"></a>Zookeeper集群</h4><ul>\n<li>顺序一致性<br>  客户端的更新顺序与它们被发送的顺序相一致。</li>\n<li>原子性<br>  更新操作要么成功要么失败，没有第三种结果。</li>\n<li>单一视图<br>  无论客户端连接到哪一个服务器，客户端将看到相同的 ZooKeeper 视图。</li>\n<li>可靠性<br>  一旦一个更新操作被应用，那么在客户端再次更新它之前，它的值将不会改变。</li>\n<li>实时性<br>  连接上一个服务端数据修改，所以其他的服务端都会实时的跟新，不算完全的实时，有一点延时的</li>\n<li>角色轮换避免单点故障<br>  当leader出现问题的时候，会选举从follower中选举一个新的leader</li>\n</ul>\n<h4 id=\"集群角色\"><a href=\"#集群角色\" class=\"headerlink\" title=\"集群角色\"></a>集群角色</h4><ul>\n<li>Leader  集群工作机制中的核心<ul>\n<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li>\n<li>集群内部个服务器的调度者(管理follower,数据同步)</li>\n</ul>\n</li>\n<li>Follower  集群工作机制中的跟随者<ul>\n<li>处理非事务请求，转发事务请求给Leader</li>\n<li>参与事务请求proposal投票<br>参与leader选举投票</li>\n</ul>\n</li>\n<li>Observer 观察者  <ul>\n<li>3.30以上版本提供，和follower功能相同，但不参与任何形式投票</li>\n<li>处理非事务请求，转发事务请求给Leader</li>\n<li>提高集群非事务处理能力</li>\n</ul>\n</li>\n</ul>","more":"<h4 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h4><p>配置文件后添加(zoo.cfg)：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.0=192.168.212.155:2888:3888</span><br><span class=\"line\">server.1=192.168.212.156:2888:3888</span><br><span class=\"line\">server.2=192.168.212.157:2888:3888</span><br></pre></td></tr></table></figure>\n<p>设置data目录(自定义目录)(zoo.cfg)：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataDir=/usr/<span class=\"built_in\">local</span>/zookeeper/data</span><br></pre></td></tr></table></figure>\n<p>服务器配置：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在/usr/local/zookeeper/data路径创建文件myid并填写内容为0 于server.0对应</span></span><br></pre></td></tr></table></figure>\n<p>启动多台zk 单台是无法启动的。</p>\n<h4 id=\"Java客户端连接集群\"><a href=\"#Java客户端连接集群\" class=\"headerlink\" title=\"Java客户端连接集群\"></a>Java客户端连接集群</h4><p>逗号连接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZkClient zkClient = <span class=\"keyword\">new</span> ZkClient(<span class=\"string\">\"host1,host2,host3\"</span>);</span><br></pre></td></tr></table></figure>"},{"title":"分布式事务解决方案","_content":"\n分布式事务解决方案\n\n### 分布式事务解决方案\n\n数据库事务正确执行的四个基本要素ACID ：\n\n原子性\n一致性\n隔离性\n持久性\n\n\nCAP定理：在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）三个要素最多只能同时实现两点，不可能三者兼顾。\n\n- 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。\n- 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。\n- 分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n\nBASE理论：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。\n\n\n<!-- more -->\n\n\n#### 解决方案\n\n\n##### 两阶段提交（2PC）\n\n\n需要引入一个协调者，其他节点为参与者。\n\n第一阶段：\n\n- 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。\n- 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。\n- 如参与者执行成功，给协调者反馈 yes，否则反馈 no。\n\n第二阶段\n\n- 当所有参与者均反馈 yes，提交事务，协调者向所有参与者发出commit请求，参与者commit释放资源，通知协调者，完成提交。\n- 当有一个参与者反馈 no，回滚事务，协调者向所有参与者发出rollback请求，参与者执行undo日志，通知协调者，完成回滚。\n\n优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。\n缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。\n\n\n问题\n\n1. 性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。\n2. 可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。\n3. 数据一致性问题：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。\n\n##### 三阶段提交（3PC）\n\n##### TCC\n\nTry :  预留资源，执行业务\nConfirm / Cancel : 执行commit或者提交\n\n缺点：代码侵入大，Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。\n优点：业务方控制锁，数据最终一致性，解决了2阶段提交协调者单点故障问题，由主业务方发起并控制整个业务活动。\n\n注意点：\n\n1、幂等\n\n可能会存在重复调用，业务方需要保证接口幂等性\n\n2、空回滚\n\n回滚事务调用二阶段，但一阶段尚未执行，业务方需要考虑，可引入事务状态控制记录作为控制手段，无记录时即为空回滚\n\n3、资源悬挂\n\n回滚事务调用二阶段完成空回滚后，一阶段执行成功，业务方需要考虑，可引入事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在\n\n\n##### 本地消息表\n\n在发起方需要创建一个本地消息表，用来记录生产方的事务发送情况\n\n\n##### 最终一致性","source":"_posts/分布式事务解决方案.md","raw":"---\ntitle: 分布式事务解决方案\ntags:\n  - 分布式事务\n  - 解决方案\n---\n\n分布式事务解决方案\n\n### 分布式事务解决方案\n\n数据库事务正确执行的四个基本要素ACID ：\n\n原子性\n一致性\n隔离性\n持久性\n\n\nCAP定理：在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）三个要素最多只能同时实现两点，不可能三者兼顾。\n\n- 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。\n- 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。\n- 分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n\nBASE理论：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。\n\n\n<!-- more -->\n\n\n#### 解决方案\n\n\n##### 两阶段提交（2PC）\n\n\n需要引入一个协调者，其他节点为参与者。\n\n第一阶段：\n\n- 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。\n- 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。\n- 如参与者执行成功，给协调者反馈 yes，否则反馈 no。\n\n第二阶段\n\n- 当所有参与者均反馈 yes，提交事务，协调者向所有参与者发出commit请求，参与者commit释放资源，通知协调者，完成提交。\n- 当有一个参与者反馈 no，回滚事务，协调者向所有参与者发出rollback请求，参与者执行undo日志，通知协调者，完成回滚。\n\n优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。\n缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。\n\n\n问题\n\n1. 性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。\n2. 可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。\n3. 数据一致性问题：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。\n\n##### 三阶段提交（3PC）\n\n##### TCC\n\nTry :  预留资源，执行业务\nConfirm / Cancel : 执行commit或者提交\n\n缺点：代码侵入大，Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。\n优点：业务方控制锁，数据最终一致性，解决了2阶段提交协调者单点故障问题，由主业务方发起并控制整个业务活动。\n\n注意点：\n\n1、幂等\n\n可能会存在重复调用，业务方需要保证接口幂等性\n\n2、空回滚\n\n回滚事务调用二阶段，但一阶段尚未执行，业务方需要考虑，可引入事务状态控制记录作为控制手段，无记录时即为空回滚\n\n3、资源悬挂\n\n回滚事务调用二阶段完成空回滚后，一阶段执行成功，业务方需要考虑，可引入事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在\n\n\n##### 本地消息表\n\n在发起方需要创建一个本地消息表，用来记录生产方的事务发送情况\n\n\n##### 最终一致性","slug":"分布式事务解决方案","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15b9002h9gj7s9khd4uk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>分布式事务解决方案</p>\n<h3 id=\"分布式事务解决方案\"><a href=\"#分布式事务解决方案\" class=\"headerlink\" title=\"分布式事务解决方案\"></a>分布式事务解决方案</h3><p>数据库事务正确执行的四个基本要素ACID ：</p>\n<p>原子性<br>一致性<br>隔离性<br>持久性</p>\n<p>CAP定理：在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）三个要素最多只能同时实现两点，不可能三者兼顾。</p>\n<ul>\n<li>一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。</li>\n<li>可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。</li>\n<li>分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>\n</ul>\n<p>BASE理论：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>\n<a id=\"more\"></a>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><h5 id=\"两阶段提交（2PC）\"><a href=\"#两阶段提交（2PC）\" class=\"headerlink\" title=\"两阶段提交（2PC）\"></a>两阶段提交（2PC）</h5><p>需要引入一个协调者，其他节点为参与者。</p>\n<p>第一阶段：</p>\n<ul>\n<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。</li>\n<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>\n<li>如参与者执行成功，给协调者反馈 yes，否则反馈 no。</li>\n</ul>\n<p>第二阶段</p>\n<ul>\n<li>当所有参与者均反馈 yes，提交事务，协调者向所有参与者发出commit请求，参与者commit释放资源，通知协调者，完成提交。</li>\n<li>当有一个参与者反馈 no，回滚事务，协调者向所有参与者发出rollback请求，参与者执行undo日志，通知协调者，完成回滚。</li>\n</ul>\n<p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。<br>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>\n<p>问题</p>\n<ol>\n<li>性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>\n<li>可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。</li>\n<li>数据一致性问题：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。</li>\n</ol>\n<h5 id=\"三阶段提交（3PC）\"><a href=\"#三阶段提交（3PC）\" class=\"headerlink\" title=\"三阶段提交（3PC）\"></a>三阶段提交（3PC）</h5><h5 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h5><p>Try :  预留资源，执行业务<br>Confirm / Cancel : 执行commit或者提交</p>\n<p>缺点：代码侵入大，Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。<br>优点：业务方控制锁，数据最终一致性，解决了2阶段提交协调者单点故障问题，由主业务方发起并控制整个业务活动。</p>\n<p>注意点：</p>\n<p>1、幂等</p>\n<p>可能会存在重复调用，业务方需要保证接口幂等性</p>\n<p>2、空回滚</p>\n<p>回滚事务调用二阶段，但一阶段尚未执行，业务方需要考虑，可引入事务状态控制记录作为控制手段，无记录时即为空回滚</p>\n<p>3、资源悬挂</p>\n<p>回滚事务调用二阶段完成空回滚后，一阶段执行成功，业务方需要考虑，可引入事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在</p>\n<h5 id=\"本地消息表\"><a href=\"#本地消息表\" class=\"headerlink\" title=\"本地消息表\"></a>本地消息表</h5><p>在发起方需要创建一个本地消息表，用来记录生产方的事务发送情况</p>\n<h5 id=\"最终一致性\"><a href=\"#最终一致性\" class=\"headerlink\" title=\"最终一致性\"></a>最终一致性</h5>","site":{"data":{}},"excerpt":"<p>分布式事务解决方案</p>\n<h3 id=\"分布式事务解决方案\"><a href=\"#分布式事务解决方案\" class=\"headerlink\" title=\"分布式事务解决方案\"></a>分布式事务解决方案</h3><p>数据库事务正确执行的四个基本要素ACID ：</p>\n<p>原子性<br>一致性<br>隔离性<br>持久性</p>\n<p>CAP定理：在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）三个要素最多只能同时实现两点，不可能三者兼顾。</p>\n<ul>\n<li>一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。</li>\n<li>可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。</li>\n<li>分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>\n</ul>\n<p>BASE理论：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>","more":"<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><h5 id=\"两阶段提交（2PC）\"><a href=\"#两阶段提交（2PC）\" class=\"headerlink\" title=\"两阶段提交（2PC）\"></a>两阶段提交（2PC）</h5><p>需要引入一个协调者，其他节点为参与者。</p>\n<p>第一阶段：</p>\n<ul>\n<li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。</li>\n<li>各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li>\n<li>如参与者执行成功，给协调者反馈 yes，否则反馈 no。</li>\n</ul>\n<p>第二阶段</p>\n<ul>\n<li>当所有参与者均反馈 yes，提交事务，协调者向所有参与者发出commit请求，参与者commit释放资源，通知协调者，完成提交。</li>\n<li>当有一个参与者反馈 no，回滚事务，协调者向所有参与者发出rollback请求，参与者执行undo日志，通知协调者，完成回滚。</li>\n</ul>\n<p>优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。<br>缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>\n<p>问题</p>\n<ol>\n<li>性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>\n<li>可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。</li>\n<li>数据一致性问题：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。</li>\n</ol>\n<h5 id=\"三阶段提交（3PC）\"><a href=\"#三阶段提交（3PC）\" class=\"headerlink\" title=\"三阶段提交（3PC）\"></a>三阶段提交（3PC）</h5><h5 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h5><p>Try :  预留资源，执行业务<br>Confirm / Cancel : 执行commit或者提交</p>\n<p>缺点：代码侵入大，Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。<br>优点：业务方控制锁，数据最终一致性，解决了2阶段提交协调者单点故障问题，由主业务方发起并控制整个业务活动。</p>\n<p>注意点：</p>\n<p>1、幂等</p>\n<p>可能会存在重复调用，业务方需要保证接口幂等性</p>\n<p>2、空回滚</p>\n<p>回滚事务调用二阶段，但一阶段尚未执行，业务方需要考虑，可引入事务状态控制记录作为控制手段，无记录时即为空回滚</p>\n<p>3、资源悬挂</p>\n<p>回滚事务调用二阶段完成空回滚后，一阶段执行成功，业务方需要考虑，可引入事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在</p>\n<h5 id=\"本地消息表\"><a href=\"#本地消息表\" class=\"headerlink\" title=\"本地消息表\"></a>本地消息表</h5><p>在发起方需要创建一个本地消息表，用来记录生产方的事务发送情况</p>\n<h5 id=\"最终一致性\"><a href=\"#最终一致性\" class=\"headerlink\" title=\"最终一致性\"></a>最终一致性</h5>"},{"title":"分布式系统基础知识","_content":"\n#### 分布式系统带来的问题\n\n- 通信异常\n- 网络分区 （脑裂）\n- 三态 （成功、失败、超时）\n- 节点故障\n\n#### CAP理论\n\n- 一致性\n\n    在分布式系统中，一致性是数据在多个副本之间是否能够保证一致的特性，这里说的一致性和前面说的对等性其实差不多。如果能够在分布式系统中针对某一个数据项的变更成功执行后，所有用户都可以马上读取到最新的值，那么这样的系统就被认为具有【强一致性】。     \n\n- 可用性\n        \n    可用性指系统提供服务必须一直处于可用状态，对于用户的操作请求总是能够在有限的时间内访问结果。这里的重点是【有限的时间】和【返回结果】为了做到有限的时间需要用到缓存，需要用到负载，这个时候服务器增加的节点是为性能考虑；为了返回结果，需要考虑服务器主备，当主节点出现问题的时候需要备份的节点能最快的顶替上来，千万不能出现OutOfMemory或者其他500，404错误，否则这样的系统我们会认为是不可用的。\n\n- 分区容错性\n\n    分布式系统在遇到任何网络分区故障的时候，仍然需要能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。\n\n<!-- more -->  \n\n<font color=red>一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项</font>\n\n![CAP](https://image.tupelo.top/%E5%88%86%E5%B8%83%E5%BC%8F.png)\n\n> 不可能把所有应用全部放到一个节点上，因此架构师的精力往往就花在怎么样根据业务场景在A和C直接寻求平衡；\n\n\n#### BASE理论\n\nBASE理论：即使无法做到强一致性，但分布式系统可以根据自己的业务特点，采用适当的方式来使系统达到最终的一致性。\n\n- 基本可用\n    \n    允许损失部分可用、保障系统基本可用。\n\n- 软状态\n\n    允许存在中间状态\n\n- 最终一致性\n\n    所有的数据在经过一段时间的数据同步后，最终能够达到一个一致的状态\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/分布式系统.md","raw":"---\ntitle: 分布式系统基础知识\ntags:\n  - 分布式\n---\n\n#### 分布式系统带来的问题\n\n- 通信异常\n- 网络分区 （脑裂）\n- 三态 （成功、失败、超时）\n- 节点故障\n\n#### CAP理论\n\n- 一致性\n\n    在分布式系统中，一致性是数据在多个副本之间是否能够保证一致的特性，这里说的一致性和前面说的对等性其实差不多。如果能够在分布式系统中针对某一个数据项的变更成功执行后，所有用户都可以马上读取到最新的值，那么这样的系统就被认为具有【强一致性】。     \n\n- 可用性\n        \n    可用性指系统提供服务必须一直处于可用状态，对于用户的操作请求总是能够在有限的时间内访问结果。这里的重点是【有限的时间】和【返回结果】为了做到有限的时间需要用到缓存，需要用到负载，这个时候服务器增加的节点是为性能考虑；为了返回结果，需要考虑服务器主备，当主节点出现问题的时候需要备份的节点能最快的顶替上来，千万不能出现OutOfMemory或者其他500，404错误，否则这样的系统我们会认为是不可用的。\n\n- 分区容错性\n\n    分布式系统在遇到任何网络分区故障的时候，仍然需要能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。\n\n<!-- more -->  \n\n<font color=red>一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项</font>\n\n![CAP](https://image.tupelo.top/%E5%88%86%E5%B8%83%E5%BC%8F.png)\n\n> 不可能把所有应用全部放到一个节点上，因此架构师的精力往往就花在怎么样根据业务场景在A和C直接寻求平衡；\n\n\n#### BASE理论\n\nBASE理论：即使无法做到强一致性，但分布式系统可以根据自己的业务特点，采用适当的方式来使系统达到最终的一致性。\n\n- 基本可用\n    \n    允许损失部分可用、保障系统基本可用。\n\n- 软状态\n\n    允许存在中间状态\n\n- 最终一致性\n\n    所有的数据在经过一段时间的数据同步后，最终能够达到一个一致的状态\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"分布式系统","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15ba002i9gj7w4wi037x","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"分布式系统带来的问题\"><a href=\"#分布式系统带来的问题\" class=\"headerlink\" title=\"分布式系统带来的问题\"></a>分布式系统带来的问题</h4><ul>\n<li>通信异常</li>\n<li>网络分区 （脑裂）</li>\n<li>三态 （成功、失败、超时）</li>\n<li>节点故障</li>\n</ul>\n<h4 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h4><ul>\n<li><p>一致性</p>\n<p>  在分布式系统中，一致性是数据在多个副本之间是否能够保证一致的特性，这里说的一致性和前面说的对等性其实差不多。如果能够在分布式系统中针对某一个数据项的变更成功执行后，所有用户都可以马上读取到最新的值，那么这样的系统就被认为具有【强一致性】。     </p>\n</li>\n<li><p>可用性</p>\n<p>  可用性指系统提供服务必须一直处于可用状态，对于用户的操作请求总是能够在有限的时间内访问结果。这里的重点是【有限的时间】和【返回结果】为了做到有限的时间需要用到缓存，需要用到负载，这个时候服务器增加的节点是为性能考虑；为了返回结果，需要考虑服务器主备，当主节点出现问题的时候需要备份的节点能最快的顶替上来，千万不能出现OutOfMemory或者其他500，404错误，否则这样的系统我们会认为是不可用的。</p>\n</li>\n<li><p>分区容错性</p>\n<p>  分布式系统在遇到任何网络分区故障的时候，仍然需要能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>\n</li>\n</ul>\n<a id=\"more\"></a>  \n<font color=\"red\">一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项</font>\n\n<p><img src=\"https://image.tupelo.top/%E5%88%86%E5%B8%83%E5%BC%8F.png\" alt=\"CAP\"></p>\n<blockquote>\n<p>不可能把所有应用全部放到一个节点上，因此架构师的精力往往就花在怎么样根据业务场景在A和C直接寻求平衡；</p>\n</blockquote>\n<h4 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h4><p>BASE理论：即使无法做到强一致性，但分布式系统可以根据自己的业务特点，采用适当的方式来使系统达到最终的一致性。</p>\n<ul>\n<li><p>基本可用</p>\n<p>  允许损失部分可用、保障系统基本可用。</p>\n</li>\n<li><p>软状态</p>\n<p>  允许存在中间状态</p>\n</li>\n<li><p>最终一致性</p>\n<p>  所有的数据在经过一段时间的数据同步后，最终能够达到一个一致的状态</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"分布式系统带来的问题\"><a href=\"#分布式系统带来的问题\" class=\"headerlink\" title=\"分布式系统带来的问题\"></a>分布式系统带来的问题</h4><ul>\n<li>通信异常</li>\n<li>网络分区 （脑裂）</li>\n<li>三态 （成功、失败、超时）</li>\n<li>节点故障</li>\n</ul>\n<h4 id=\"CAP理论\"><a href=\"#CAP理论\" class=\"headerlink\" title=\"CAP理论\"></a>CAP理论</h4><ul>\n<li><p>一致性</p>\n<p>  在分布式系统中，一致性是数据在多个副本之间是否能够保证一致的特性，这里说的一致性和前面说的对等性其实差不多。如果能够在分布式系统中针对某一个数据项的变更成功执行后，所有用户都可以马上读取到最新的值，那么这样的系统就被认为具有【强一致性】。     </p>\n</li>\n<li><p>可用性</p>\n<p>  可用性指系统提供服务必须一直处于可用状态，对于用户的操作请求总是能够在有限的时间内访问结果。这里的重点是【有限的时间】和【返回结果】为了做到有限的时间需要用到缓存，需要用到负载，这个时候服务器增加的节点是为性能考虑；为了返回结果，需要考虑服务器主备，当主节点出现问题的时候需要备份的节点能最快的顶替上来，千万不能出现OutOfMemory或者其他500，404错误，否则这样的系统我们会认为是不可用的。</p>\n</li>\n<li><p>分区容错性</p>\n<p>  分布式系统在遇到任何网络分区故障的时候，仍然需要能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>\n</li>\n</ul>","more":"<font color=\"red\">一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个基本需求，最多只能同时满足其中的两项</font>\n\n<p><img src=\"https://image.tupelo.top/%E5%88%86%E5%B8%83%E5%BC%8F.png\" alt=\"CAP\"></p>\n<blockquote>\n<p>不可能把所有应用全部放到一个节点上，因此架构师的精力往往就花在怎么样根据业务场景在A和C直接寻求平衡；</p>\n</blockquote>\n<h4 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h4><p>BASE理论：即使无法做到强一致性，但分布式系统可以根据自己的业务特点，采用适当的方式来使系统达到最终的一致性。</p>\n<ul>\n<li><p>基本可用</p>\n<p>  允许损失部分可用、保障系统基本可用。</p>\n</li>\n<li><p>软状态</p>\n<p>  允许存在中间状态</p>\n</li>\n<li><p>最终一致性</p>\n<p>  所有的数据在经过一段时间的数据同步后，最终能够达到一个一致的状态</p>\n</li>\n</ul>"},{"title":"设计模式-单例模式","_content":"\n### 单例模式\n\n>   保证一个类有且只有一个实例，并提供一个访问它的全局访问点。\n\n- 饿汉式\n\n\n```java\npublic class Single {\n    /**\n     * 私有变量\n     */\n    private static Single single = new Single();\n    /**\n     * 私有化构造方法\n     */\n    private Single(){\n    }\n\n    /**\n     * 全局访问\n     * @return Single\n     */\n    public static Single getSingle() {\n        return single;\n    }\n}\n```\n\n- 懒汉式\n\n\n```java\npublic class Single {\n    /**\n     * 私有变量\n     */\n    private static Single single;\n    /**\n     * 私有化构造方法\n     */\n    private Single(){\n    }\n\n    /**\n     * 全局访问\n     * @return Single\n     */\n    public static Single getSingle() {\n    \tsingle = new Single();\n        return single;\n    }\n}\n```\n\n\n- 安全单例模式\n\n\n```java\n/**\n * 全局访问\n * @return Single\n */\npublic static Single getSingle() {\n    if(single==null){\n        synchronized (Single.class){\n            if(single==null){\n                single = new Single();\n            }\n        }\n    }\n    return single;\n}\n```\n\n","source":"_posts/单例模式.md","raw":"---\ntitle: 设计模式-单例模式\ntags:\n  - 设计模式\n---\n\n### 单例模式\n\n>   保证一个类有且只有一个实例，并提供一个访问它的全局访问点。\n\n- 饿汉式\n\n\n```java\npublic class Single {\n    /**\n     * 私有变量\n     */\n    private static Single single = new Single();\n    /**\n     * 私有化构造方法\n     */\n    private Single(){\n    }\n\n    /**\n     * 全局访问\n     * @return Single\n     */\n    public static Single getSingle() {\n        return single;\n    }\n}\n```\n\n- 懒汉式\n\n\n```java\npublic class Single {\n    /**\n     * 私有变量\n     */\n    private static Single single;\n    /**\n     * 私有化构造方法\n     */\n    private Single(){\n    }\n\n    /**\n     * 全局访问\n     * @return Single\n     */\n    public static Single getSingle() {\n    \tsingle = new Single();\n        return single;\n    }\n}\n```\n\n\n- 安全单例模式\n\n\n```java\n/**\n * 全局访问\n * @return Single\n */\npublic static Single getSingle() {\n    if(single==null){\n        synchronized (Single.class){\n            if(single==null){\n                single = new Single();\n            }\n        }\n    }\n    return single;\n}\n```\n\n","slug":"单例模式","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15bc002l9gj7bin3y6ed","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><blockquote>\n<p>  保证一个类有且只有一个实例，并提供一个访问它的全局访问点。</p>\n</blockquote>\n<ul>\n<li>饿汉式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Single single = <span class=\"keyword\">new</span> Single();</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有化构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Single</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 全局访问</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Single</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>懒汉式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Single single;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有化构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Single</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 全局访问</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Single</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tsingle = <span class=\"keyword\">new</span> Single();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安全单例模式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 全局访问</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> Single</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(single==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Single.class)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(single==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                single = <span class=\"keyword\">new</span> Single();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><blockquote>\n<p>  保证一个类有且只有一个实例，并提供一个访问它的全局访问点。</p>\n</blockquote>\n<ul>\n<li>饿汉式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Single single = <span class=\"keyword\">new</span> Single();</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有化构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Single</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 全局访问</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Single</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>懒汉式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有变量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Single single;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 私有化构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Single</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 全局访问</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Single</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \tsingle = <span class=\"keyword\">new</span> Single();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安全单例模式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 全局访问</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> Single</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Single <span class=\"title\">getSingle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(single==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Single.class)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(single==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                single = <span class=\"keyword\">new</span> Single();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"分布式锁解决方案","_content":"\n分布式锁解决方案\n\n### 分布式锁解决方案\n\n分布式锁：集群的情况下会产生\n\nCAP理论：一致性 可用性 分区容错性\n\n解决方案：\n基于数据库实现分布式锁\n基于缓存（Redis等）实现分布式锁\n基于Zookeeper实现分布式锁\n\n<!-- more -->\n\n1、基于数据库实现分布式锁\n\n唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。\n\n缺点：\n\n依赖数据库\n锁没用失效时间\n非重入锁\n\n解决：\n\n数据库集群\n定时解锁\n记录加锁的信息判断能否重入\n\n\n2、基于缓存（Redis等）实现分布式锁\n\nredis setnx\n\n缺点：\n1、set 和 expire 不是原子性的会造成死锁  \n解决： set key value nx ex sec\n2、A处理时间大于过期时间,会自动释放锁,此时B获取到锁，这是A执行完毕,会删除B的锁\n解决：删除之前先判断是不是自己的锁\n问题：判断和释放不是原子性\n\n解决：获得锁之后另外开启一个守护线程定期expire,执行完成之后显示关闭线程\n\n\n3、基于Zookeeper实现分布式锁\n\n- 在Zookeeper当中创建一个持久节点ParentLock\n- 当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点。\n- 查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。\n- 如果不是最小的节点 则抢锁失败，监听前一个节点\n- 当任务完成时，显示调用删除当前节点的指令。\n- 下一个节点获取到锁\n\n缺点：\n性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。\n使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）\n\n\n三种方案的比较\n上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。\n\n从理解的难易程度角度（从低到高）：\n数据库 > 缓存 > Zookeeper\n\n从实现的复杂性角度（从低到高）：\nZookeeper >= 缓存 > 数据库\n\n从性能角度（从高到低）：\n缓存 > Zookeeper >= 数据库\n\n从可靠性角度（从高到低）：\nZookeeper > 缓存 > 数据库\n\n\n\n\n\n\n","source":"_posts/分布式锁解决方案.md","raw":"---\ntitle: 分布式锁解决方案\ntags:\n  - 分布式锁\n  - 解决方案\n---\n\n分布式锁解决方案\n\n### 分布式锁解决方案\n\n分布式锁：集群的情况下会产生\n\nCAP理论：一致性 可用性 分区容错性\n\n解决方案：\n基于数据库实现分布式锁\n基于缓存（Redis等）实现分布式锁\n基于Zookeeper实现分布式锁\n\n<!-- more -->\n\n1、基于数据库实现分布式锁\n\n唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。\n\n缺点：\n\n依赖数据库\n锁没用失效时间\n非重入锁\n\n解决：\n\n数据库集群\n定时解锁\n记录加锁的信息判断能否重入\n\n\n2、基于缓存（Redis等）实现分布式锁\n\nredis setnx\n\n缺点：\n1、set 和 expire 不是原子性的会造成死锁  \n解决： set key value nx ex sec\n2、A处理时间大于过期时间,会自动释放锁,此时B获取到锁，这是A执行完毕,会删除B的锁\n解决：删除之前先判断是不是自己的锁\n问题：判断和释放不是原子性\n\n解决：获得锁之后另外开启一个守护线程定期expire,执行完成之后显示关闭线程\n\n\n3、基于Zookeeper实现分布式锁\n\n- 在Zookeeper当中创建一个持久节点ParentLock\n- 当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点。\n- 查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。\n- 如果不是最小的节点 则抢锁失败，监听前一个节点\n- 当任务完成时，显示调用删除当前节点的指令。\n- 下一个节点获取到锁\n\n缺点：\n性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。\n使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）\n\n\n三种方案的比较\n上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。\n\n从理解的难易程度角度（从低到高）：\n数据库 > 缓存 > Zookeeper\n\n从实现的复杂性角度（从低到高）：\nZookeeper >= 缓存 > 数据库\n\n从性能角度（从高到低）：\n缓存 > Zookeeper >= 数据库\n\n从可靠性角度（从高到低）：\nZookeeper > 缓存 > 数据库\n\n\n\n\n\n\n","slug":"分布式锁解决方案","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15bd002n9gj7lv42qus2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>分布式锁解决方案</p>\n<h3 id=\"分布式锁解决方案\"><a href=\"#分布式锁解决方案\" class=\"headerlink\" title=\"分布式锁解决方案\"></a>分布式锁解决方案</h3><p>分布式锁：集群的情况下会产生</p>\n<p>CAP理论：一致性 可用性 分区容错性</p>\n<p>解决方案：<br>基于数据库实现分布式锁<br>基于缓存（Redis等）实现分布式锁<br>基于Zookeeper实现分布式锁</p>\n<a id=\"more\"></a>\n<p>1、基于数据库实现分布式锁</p>\n<p>唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。</p>\n<p>缺点：</p>\n<p>依赖数据库<br>锁没用失效时间<br>非重入锁</p>\n<p>解决：</p>\n<p>数据库集群<br>定时解锁<br>记录加锁的信息判断能否重入</p>\n<p>2、基于缓存（Redis等）实现分布式锁</p>\n<p>redis setnx</p>\n<p>缺点：<br>1、set 和 expire 不是原子性的会造成死锁<br>解决： set key value nx ex sec<br>2、A处理时间大于过期时间,会自动释放锁,此时B获取到锁，这是A执行完毕,会删除B的锁<br>解决：删除之前先判断是不是自己的锁<br>问题：判断和释放不是原子性</p>\n<p>解决：获得锁之后另外开启一个守护线程定期expire,执行完成之后显示关闭线程</p>\n<p>3、基于Zookeeper实现分布式锁</p>\n<ul>\n<li>在Zookeeper当中创建一个持久节点ParentLock</li>\n<li>当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点。</li>\n<li>查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</li>\n<li>如果不是最小的节点 则抢锁失败，监听前一个节点</li>\n<li>当任务完成时，显示调用删除当前节点的指令。</li>\n<li>下一个节点获取到锁</li>\n</ul>\n<p>缺点：<br>性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。<br>使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p>\n<p>三种方案的比较<br>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p>\n<p>从理解的难易程度角度（从低到高）：<br>数据库 &gt; 缓存 &gt; Zookeeper</p>\n<p>从实现的复杂性角度（从低到高）：<br>Zookeeper &gt;= 缓存 &gt; 数据库</p>\n<p>从性能角度（从高到低）：<br>缓存 &gt; Zookeeper &gt;= 数据库</p>\n<p>从可靠性角度（从高到低）：<br>Zookeeper &gt; 缓存 &gt; 数据库</p>\n","site":{"data":{}},"excerpt":"<p>分布式锁解决方案</p>\n<h3 id=\"分布式锁解决方案\"><a href=\"#分布式锁解决方案\" class=\"headerlink\" title=\"分布式锁解决方案\"></a>分布式锁解决方案</h3><p>分布式锁：集群的情况下会产生</p>\n<p>CAP理论：一致性 可用性 分区容错性</p>\n<p>解决方案：<br>基于数据库实现分布式锁<br>基于缓存（Redis等）实现分布式锁<br>基于Zookeeper实现分布式锁</p>","more":"<p>1、基于数据库实现分布式锁</p>\n<p>唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。</p>\n<p>缺点：</p>\n<p>依赖数据库<br>锁没用失效时间<br>非重入锁</p>\n<p>解决：</p>\n<p>数据库集群<br>定时解锁<br>记录加锁的信息判断能否重入</p>\n<p>2、基于缓存（Redis等）实现分布式锁</p>\n<p>redis setnx</p>\n<p>缺点：<br>1、set 和 expire 不是原子性的会造成死锁<br>解决： set key value nx ex sec<br>2、A处理时间大于过期时间,会自动释放锁,此时B获取到锁，这是A执行完毕,会删除B的锁<br>解决：删除之前先判断是不是自己的锁<br>问题：判断和释放不是原子性</p>\n<p>解决：获得锁之后另外开启一个守护线程定期expire,执行完成之后显示关闭线程</p>\n<p>3、基于Zookeeper实现分布式锁</p>\n<ul>\n<li>在Zookeeper当中创建一个持久节点ParentLock</li>\n<li>当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点。</li>\n<li>查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</li>\n<li>如果不是最小的节点 则抢锁失败，监听前一个节点</li>\n<li>当任务完成时，显示调用删除当前节点的指令。</li>\n<li>下一个节点获取到锁</li>\n</ul>\n<p>缺点：<br>性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。<br>使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p>\n<p>三种方案的比较<br>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p>\n<p>从理解的难易程度角度（从低到高）：<br>数据库 &gt; 缓存 &gt; Zookeeper</p>\n<p>从实现的复杂性角度（从低到高）：<br>Zookeeper &gt;= 缓存 &gt; 数据库</p>\n<p>从性能角度（从高到低）：<br>缓存 &gt; Zookeeper &gt;= 数据库</p>\n<p>从可靠性角度（从高到低）：<br>Zookeeper &gt; 缓存 &gt; 数据库</p>"},{"title":"并发编程 - 线程的并发工具类","_content":"\n线程的并发工具类\n\n## 线程的并发工具类\n\n- Fork-Join:分治思想\n- CountDownLatch:是一组线程等待其他的线程完成工作以后在执行,加强版join await用来等待,countDown负责计数器的减1\n- CyclicBarrier: 让一组线程达到某个屏障,被阻塞,一直到组内最后一个线程达到屏障时,屏障开放,所有被阻塞的线程会继续运行\n\t- countdownlatch放行由第三者控制,CyclicBarrier放行由一组线程本身控制\n\t- countdownlatch放行条件》=线程数,CyclicBarrier放行条件=线程数\n- Semaphore:信号量\n- Exchange:交换\n- Callable、Future和FutureTask \n\n<!-- more -->  \n\n#### Fork-Join\n\n> 继承 RecursiveAction/RecursiveTask/ForkJoinTask,重写compute方法\n\n![Fork-Join](http://image.tupelo.top/forkJoin.jpeg)\n\n```java\n/**\n *类说明：遍历指定目录（含子目录）找寻指定类型文件\n */\npublic class FindDirsFiles extends RecursiveAction{\n    private File path;//当前任务需要搜寻的目录\n    public FindDirsFiles(File path) {\n        this.path = path;\n    }\n\n    public static void main(String [] args){\n        try {\n            // 用一个 ForkJoinPool 实例调度总任务\n            ForkJoinPool pool = new ForkJoinPool();\n            FindDirsFiles task = new FindDirsFiles(new File(\"F:/\"));\n\n            pool.execute(task);//异步调用\n            // pool.invokeAll(task);\n            System.out.println(\"Task is Running......\");\n            Thread.sleep(1);\n            int otherWork = 0;\n            System.out.println(\"Main Thread done sth......,otherWork=\"+otherWork);\n            task.join();//阻塞的方法\n            System.out.println(\"Task end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\t@Override\n\tprotected void compute() {\n\t\tList<FindDirsFiles> subTasks = new ArrayList<>();\n\t\tFile[] files = path.listFiles();\n\t\tif(files!=null) {\n\t\t\tfor(File file:files) {\n\t\t\t\tif(file.isDirectory()) {\n\t\t\t\t\tsubTasks.add(new FindDirsFiles(file));\n\t\t\t\t}else {\n\t\t\t\t\t//遇到文件，检查\n\t\t\t\t\tif(file.getAbsolutePath().endsWith(\"txt\")) {\n\t\t\t\t\t\tSystem.out.println(\"文件：\"+file.getAbsolutePath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!subTasks.isEmpty()) {\n\t\t\t\tfor(FindDirsFiles subTask:invokeAll(subTasks)) {\n\t\t\t\t\tsubTask.join();//等待子任务执行完成\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### CountDownLatch\n\n```java\n// 设置等待次数\nCountDownLatch latch = new CountDownLatch(1);\n\n// 其他线程做完后次数减1\nlatch.countDown();\n\n// 阻塞 latch 次数为0时执行\nlatch.await();\n```\n\n#### CyclicBarrier \n\n```java\n// 设置放开次数\nCyclicBarrier barrier = new CyclicBarrier(4,new CollectThread());\n\n// 阻塞住 达到设置放开次数开放次数是会继续执行\nbarrier.await();\n```\n\n#### Semaphore\n\n```java\n//定义信号量\nSemaphore semaphore=new Semaphore(3);\n\n// 闸门 判断是否有信号量是否还有 没有就阻塞\nsemaphore.acquire();\n\n// 可用信号量\nsemaphore.availablePermits();\n\n// 释放信号量\nsemaphore.release();\n```\n\n#### Callable、Future和FutureTask\n\n![Callable、Future和FutureTask](http://image.tupelo.top/Callable.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/多线程-02.md","raw":"---\ntitle: 并发编程 - 线程的并发工具类\ntags:\n  - 并发编程\n---\n\n线程的并发工具类\n\n## 线程的并发工具类\n\n- Fork-Join:分治思想\n- CountDownLatch:是一组线程等待其他的线程完成工作以后在执行,加强版join await用来等待,countDown负责计数器的减1\n- CyclicBarrier: 让一组线程达到某个屏障,被阻塞,一直到组内最后一个线程达到屏障时,屏障开放,所有被阻塞的线程会继续运行\n\t- countdownlatch放行由第三者控制,CyclicBarrier放行由一组线程本身控制\n\t- countdownlatch放行条件》=线程数,CyclicBarrier放行条件=线程数\n- Semaphore:信号量\n- Exchange:交换\n- Callable、Future和FutureTask \n\n<!-- more -->  \n\n#### Fork-Join\n\n> 继承 RecursiveAction/RecursiveTask/ForkJoinTask,重写compute方法\n\n![Fork-Join](http://image.tupelo.top/forkJoin.jpeg)\n\n```java\n/**\n *类说明：遍历指定目录（含子目录）找寻指定类型文件\n */\npublic class FindDirsFiles extends RecursiveAction{\n    private File path;//当前任务需要搜寻的目录\n    public FindDirsFiles(File path) {\n        this.path = path;\n    }\n\n    public static void main(String [] args){\n        try {\n            // 用一个 ForkJoinPool 实例调度总任务\n            ForkJoinPool pool = new ForkJoinPool();\n            FindDirsFiles task = new FindDirsFiles(new File(\"F:/\"));\n\n            pool.execute(task);//异步调用\n            // pool.invokeAll(task);\n            System.out.println(\"Task is Running......\");\n            Thread.sleep(1);\n            int otherWork = 0;\n            System.out.println(\"Main Thread done sth......,otherWork=\"+otherWork);\n            task.join();//阻塞的方法\n            System.out.println(\"Task end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\t@Override\n\tprotected void compute() {\n\t\tList<FindDirsFiles> subTasks = new ArrayList<>();\n\t\tFile[] files = path.listFiles();\n\t\tif(files!=null) {\n\t\t\tfor(File file:files) {\n\t\t\t\tif(file.isDirectory()) {\n\t\t\t\t\tsubTasks.add(new FindDirsFiles(file));\n\t\t\t\t}else {\n\t\t\t\t\t//遇到文件，检查\n\t\t\t\t\tif(file.getAbsolutePath().endsWith(\"txt\")) {\n\t\t\t\t\t\tSystem.out.println(\"文件：\"+file.getAbsolutePath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!subTasks.isEmpty()) {\n\t\t\t\tfor(FindDirsFiles subTask:invokeAll(subTasks)) {\n\t\t\t\t\tsubTask.join();//等待子任务执行完成\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n#### CountDownLatch\n\n```java\n// 设置等待次数\nCountDownLatch latch = new CountDownLatch(1);\n\n// 其他线程做完后次数减1\nlatch.countDown();\n\n// 阻塞 latch 次数为0时执行\nlatch.await();\n```\n\n#### CyclicBarrier \n\n```java\n// 设置放开次数\nCyclicBarrier barrier = new CyclicBarrier(4,new CollectThread());\n\n// 阻塞住 达到设置放开次数开放次数是会继续执行\nbarrier.await();\n```\n\n#### Semaphore\n\n```java\n//定义信号量\nSemaphore semaphore=new Semaphore(3);\n\n// 闸门 判断是否有信号量是否还有 没有就阻塞\nsemaphore.acquire();\n\n// 可用信号量\nsemaphore.availablePermits();\n\n// 释放信号量\nsemaphore.release();\n```\n\n#### Callable、Future和FutureTask\n\n![Callable、Future和FutureTask](http://image.tupelo.top/Callable.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"多线程-02","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15be002q9gj7tojfl96t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>线程的并发工具类</p>\n<h2 id=\"线程的并发工具类\"><a href=\"#线程的并发工具类\" class=\"headerlink\" title=\"线程的并发工具类\"></a>线程的并发工具类</h2><ul>\n<li>Fork-Join:分治思想</li>\n<li>CountDownLatch:是一组线程等待其他的线程完成工作以后在执行,加强版join await用来等待,countDown负责计数器的减1</li>\n<li>CyclicBarrier: 让一组线程达到某个屏障,被阻塞,一直到组内最后一个线程达到屏障时,屏障开放,所有被阻塞的线程会继续运行<ul>\n<li>countdownlatch放行由第三者控制,CyclicBarrier放行由一组线程本身控制</li>\n<li>countdownlatch放行条件》=线程数,CyclicBarrier放行条件=线程数</li>\n</ul>\n</li>\n<li>Semaphore:信号量</li>\n<li>Exchange:交换</li>\n<li>Callable、Future和FutureTask </li>\n</ul>\n<a id=\"more\"></a>  \n<h4 id=\"Fork-Join\"><a href=\"#Fork-Join\" class=\"headerlink\" title=\"Fork-Join\"></a>Fork-Join</h4><blockquote>\n<p>继承 RecursiveAction/RecursiveTask/ForkJoinTask,重写compute方法</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/forkJoin.jpeg\" alt=\"Fork-Join\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *类说明：遍历指定目录（含子目录）找寻指定类型文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindDirsFiles</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveAction</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> File path;<span class=\"comment\">//当前任务需要搜寻的目录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FindDirsFiles</span><span class=\"params\">(File path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用一个 ForkJoinPool 实例调度总任务</span></span><br><span class=\"line\">            ForkJoinPool pool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">            FindDirsFiles task = <span class=\"keyword\">new</span> FindDirsFiles(<span class=\"keyword\">new</span> File(<span class=\"string\">\"F:/\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            pool.execute(task);<span class=\"comment\">//异步调用</span></span><br><span class=\"line\">            <span class=\"comment\">// pool.invokeAll(task);</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Task is Running......\"</span>);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> otherWork = <span class=\"number\">0</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Main Thread done sth......,otherWork=\"</span>+otherWork);</span><br><span class=\"line\">            task.join();<span class=\"comment\">//阻塞的方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Task end\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;FindDirsFiles&gt; subTasks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tFile[] files = path.listFiles();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(File file:files) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(file.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\tsubTasks.add(<span class=\"keyword\">new</span> FindDirsFiles(file));</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//遇到文件，检查</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(file.getAbsolutePath().endsWith(<span class=\"string\">\"txt\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tSystem.out.println(<span class=\"string\">\"文件：\"</span>+file.getAbsolutePath());</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!subTasks.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(FindDirsFiles subTask:invokeAll(subTasks)) &#123;</span><br><span class=\"line\">\t\t\t\t\tsubTask.join();<span class=\"comment\">//等待子任务执行完成</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置等待次数</span></span><br><span class=\"line\">CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他线程做完后次数减1</span></span><br><span class=\"line\">latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阻塞 latch 次数为0时执行</span></span><br><span class=\"line\">latch.await();</span><br></pre></td></tr></table></figure>\n<h4 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置放开次数</span></span><br><span class=\"line\">CyclicBarrier barrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">4</span>,<span class=\"keyword\">new</span> CollectThread());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阻塞住 达到设置放开次数开放次数是会继续执行</span></span><br><span class=\"line\">barrier.await();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义信号量</span></span><br><span class=\"line\">Semaphore semaphore=<span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 闸门 判断是否有信号量是否还有 没有就阻塞</span></span><br><span class=\"line\">semaphore.acquire();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可用信号量</span></span><br><span class=\"line\">semaphore.availablePermits();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放信号量</span></span><br><span class=\"line\">semaphore.release();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Callable、Future和FutureTask\"><a href=\"#Callable、Future和FutureTask\" class=\"headerlink\" title=\"Callable、Future和FutureTask\"></a>Callable、Future和FutureTask</h4><p><img src=\"http://image.tupelo.top/Callable.png\" alt=\"Callable、Future和FutureTask\"></p>\n","site":{"data":{}},"excerpt":"<p>线程的并发工具类</p>\n<h2 id=\"线程的并发工具类\"><a href=\"#线程的并发工具类\" class=\"headerlink\" title=\"线程的并发工具类\"></a>线程的并发工具类</h2><ul>\n<li>Fork-Join:分治思想</li>\n<li>CountDownLatch:是一组线程等待其他的线程完成工作以后在执行,加强版join await用来等待,countDown负责计数器的减1</li>\n<li>CyclicBarrier: 让一组线程达到某个屏障,被阻塞,一直到组内最后一个线程达到屏障时,屏障开放,所有被阻塞的线程会继续运行<ul>\n<li>countdownlatch放行由第三者控制,CyclicBarrier放行由一组线程本身控制</li>\n<li>countdownlatch放行条件》=线程数,CyclicBarrier放行条件=线程数</li>\n</ul>\n</li>\n<li>Semaphore:信号量</li>\n<li>Exchange:交换</li>\n<li>Callable、Future和FutureTask </li>\n</ul>","more":"<h4 id=\"Fork-Join\"><a href=\"#Fork-Join\" class=\"headerlink\" title=\"Fork-Join\"></a>Fork-Join</h4><blockquote>\n<p>继承 RecursiveAction/RecursiveTask/ForkJoinTask,重写compute方法</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/forkJoin.jpeg\" alt=\"Fork-Join\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *类说明：遍历指定目录（含子目录）找寻指定类型文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindDirsFiles</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveAction</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> File path;<span class=\"comment\">//当前任务需要搜寻的目录</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FindDirsFiles</span><span class=\"params\">(File path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 用一个 ForkJoinPool 实例调度总任务</span></span><br><span class=\"line\">            ForkJoinPool pool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">            FindDirsFiles task = <span class=\"keyword\">new</span> FindDirsFiles(<span class=\"keyword\">new</span> File(<span class=\"string\">\"F:/\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            pool.execute(task);<span class=\"comment\">//异步调用</span></span><br><span class=\"line\">            <span class=\"comment\">// pool.invokeAll(task);</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Task is Running......\"</span>);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> otherWork = <span class=\"number\">0</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Main Thread done sth......,otherWork=\"</span>+otherWork);</span><br><span class=\"line\">            task.join();<span class=\"comment\">//阻塞的方法</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Task end\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;FindDirsFiles&gt; subTasks = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tFile[] files = path.listFiles();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(File file:files) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(file.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\tsubTasks.add(<span class=\"keyword\">new</span> FindDirsFiles(file));</span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//遇到文件，检查</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(file.getAbsolutePath().endsWith(<span class=\"string\">\"txt\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tSystem.out.println(<span class=\"string\">\"文件：\"</span>+file.getAbsolutePath());</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!subTasks.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(FindDirsFiles subTask:invokeAll(subTasks)) &#123;</span><br><span class=\"line\">\t\t\t\t\tsubTask.join();<span class=\"comment\">//等待子任务执行完成</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置等待次数</span></span><br><span class=\"line\">CountDownLatch latch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他线程做完后次数减1</span></span><br><span class=\"line\">latch.countDown();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阻塞 latch 次数为0时执行</span></span><br><span class=\"line\">latch.await();</span><br></pre></td></tr></table></figure>\n<h4 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置放开次数</span></span><br><span class=\"line\">CyclicBarrier barrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">4</span>,<span class=\"keyword\">new</span> CollectThread());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阻塞住 达到设置放开次数开放次数是会继续执行</span></span><br><span class=\"line\">barrier.await();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义信号量</span></span><br><span class=\"line\">Semaphore semaphore=<span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 闸门 判断是否有信号量是否还有 没有就阻塞</span></span><br><span class=\"line\">semaphore.acquire();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可用信号量</span></span><br><span class=\"line\">semaphore.availablePermits();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放信号量</span></span><br><span class=\"line\">semaphore.release();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Callable、Future和FutureTask\"><a href=\"#Callable、Future和FutureTask\" class=\"headerlink\" title=\"Callable、Future和FutureTask\"></a>Callable、Future和FutureTask</h4><p><img src=\"http://image.tupelo.top/Callable.png\" alt=\"Callable、Future和FutureTask\"></p>"},{"title":"并发编程 - 线程基础、线程之间的共享和协作","_content":"\n线程基础、线程之间的共享和协作\n\n## 线程基础\n\n#### 进程和线程\n\n- 进程：程序运行资源分配的最小单位,进程内部有多个线程,会共享这个进程的资源\n- 线程：CPU调度的最小单位,必须依赖进程而存在。\n\n#### 高并发编程的意义、好处和注意事项\n\n- 好处：充分利用cpu的资源、加快用户响应的时间,程序模块化,异步化\n- 问题：  \n\t- 线程共享资源,存在冲突；  \n\t- 容易导致死锁；  \n\t- 启用太多的线程,就有搞垮机器的可能\n\t\n<!-- more -->  \n\n#### 线程实现三种方式\n\n- 继承Thread\n\n```java\n/**\n * 继承Thread\n */\nprivate static class UseExtends extends Thread{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"I am extends Thread\");\n\t}\n}\n\n```\n- 实现Runnable 无返回值\n\n```java\n/**\n * 实现Runnable接口\n */\nprivate static class UseRun implements Runnable{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"I am implements Runnable\");\n\t}\n}\n\n```\n\n- 实现Callable 又返回值\n\n```java\n/**\n * 实现Callable接口,允许有返回值\n */\nprivate static class UseCall implements Callable<String>{\n\t@Override\n\tpublic String call() throws Exception {\n\t\tSystem.out.println(\"I am implements Callable\");\n\t\treturn \"CallResult\";\n\t}\n\t\n}\n```\n\n```java\n//运行\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n\t// extends\n\tUseExtends useExtends = new UseExtends();\n\tuseExtends.start();\n\n\t// Runable\n\tUseRun useRun = new UseRun();\n\tnew Thread(useRun).start();\n\n\t// Callable\n\tUseCall useCall = new UseCall();\n\tFutureTask<String> futureTask = new FutureTask<>(useCall);\n\tnew Thread(futureTask).start();\n\tSystem.out.println(futureTask.get());\n}\n```\n\n#### 线程停止\n\n> stop(),resume(),suspend() 不建议使用了 容易造成死锁 可以使用interrupt()对线程加上中断标志 如下：\n\n\tinterrupt() 将线程中断标志位置为true\n\tisInterrupted() 判定当前线程是否处于中断状态。\n\tinterrupted() 判定当前线程是否处于中断状态,同时中断标志位改为false。\n\t方法里如果抛出InterruptedException,线程的中断标志位会被复位成false,如果确实是需要中断线程,要求我们自己在catch语句块里再次调用interrupt()。\n\n#### 线程状态\n\n![线程状态](http://image.tupelo.top/thread_status.png)\n\n\trun()和start():run方法就是普通对象的普通方法,只有调用了start()后,Java才会将线程对象和操作系统中实际的线程进行映射,再来执行run方法。  \n\tyield():把CPU时间让出来,让其他或者自己的线程执行（也就是谁先抢到谁执行） \n\twait():线程会释放锁,进入阻塞状态  \n\tnotify/notifyAll():在获取锁的状态下,唤醒wait()的线程  \n\tjoin():用来插队,线程A,执行了线程B的join方法,线程A必须要等待B执行完成了以后,线程A才能继续自己的工作\n\n> 应该尽量使用notifyAll,使用notify 只会唤醒一个 有可能发生信号丢失的的情况\n\n```\nyield() 、sleep()、wait()、notify()的区别:  \n线程在执行yield()以后,持有的锁是不释放的  \nsleep()方法被调用以后,持有的锁是不释放的  \n调动方法之前,必须要持有锁。调用了wait()方法以后,锁就会被释放,当wait方法返回的时候,线程会重新持有锁  \n调动方法之前,必须要持有锁,调用notify()方法本身不会释放锁的  \n```\n\n#### 线程间的共享\n\n- synchronized内置锁\n- volatile关键字 一个写 多个读的情况\n- ThreadLocal 线程变量\n```java\n//可以理解为 一个map,类型 Map<Thread,Integer>\nstatic ThreadLocal<Integer> threadLaocl = new ThreadLocal<Integer>(){\n\t@Override\n\tprotected Integer initialValue() {\n\t\treturn 1;\n\t}\n};\n```\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/多线程-01.md","raw":"---\ntitle: 并发编程 - 线程基础、线程之间的共享和协作\ntags:\n  - 并发编程\n---\n\n线程基础、线程之间的共享和协作\n\n## 线程基础\n\n#### 进程和线程\n\n- 进程：程序运行资源分配的最小单位,进程内部有多个线程,会共享这个进程的资源\n- 线程：CPU调度的最小单位,必须依赖进程而存在。\n\n#### 高并发编程的意义、好处和注意事项\n\n- 好处：充分利用cpu的资源、加快用户响应的时间,程序模块化,异步化\n- 问题：  \n\t- 线程共享资源,存在冲突；  \n\t- 容易导致死锁；  \n\t- 启用太多的线程,就有搞垮机器的可能\n\t\n<!-- more -->  \n\n#### 线程实现三种方式\n\n- 继承Thread\n\n```java\n/**\n * 继承Thread\n */\nprivate static class UseExtends extends Thread{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"I am extends Thread\");\n\t}\n}\n\n```\n- 实现Runnable 无返回值\n\n```java\n/**\n * 实现Runnable接口\n */\nprivate static class UseRun implements Runnable{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"I am implements Runnable\");\n\t}\n}\n\n```\n\n- 实现Callable 又返回值\n\n```java\n/**\n * 实现Callable接口,允许有返回值\n */\nprivate static class UseCall implements Callable<String>{\n\t@Override\n\tpublic String call() throws Exception {\n\t\tSystem.out.println(\"I am implements Callable\");\n\t\treturn \"CallResult\";\n\t}\n\t\n}\n```\n\n```java\n//运行\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n\t// extends\n\tUseExtends useExtends = new UseExtends();\n\tuseExtends.start();\n\n\t// Runable\n\tUseRun useRun = new UseRun();\n\tnew Thread(useRun).start();\n\n\t// Callable\n\tUseCall useCall = new UseCall();\n\tFutureTask<String> futureTask = new FutureTask<>(useCall);\n\tnew Thread(futureTask).start();\n\tSystem.out.println(futureTask.get());\n}\n```\n\n#### 线程停止\n\n> stop(),resume(),suspend() 不建议使用了 容易造成死锁 可以使用interrupt()对线程加上中断标志 如下：\n\n\tinterrupt() 将线程中断标志位置为true\n\tisInterrupted() 判定当前线程是否处于中断状态。\n\tinterrupted() 判定当前线程是否处于中断状态,同时中断标志位改为false。\n\t方法里如果抛出InterruptedException,线程的中断标志位会被复位成false,如果确实是需要中断线程,要求我们自己在catch语句块里再次调用interrupt()。\n\n#### 线程状态\n\n![线程状态](http://image.tupelo.top/thread_status.png)\n\n\trun()和start():run方法就是普通对象的普通方法,只有调用了start()后,Java才会将线程对象和操作系统中实际的线程进行映射,再来执行run方法。  \n\tyield():把CPU时间让出来,让其他或者自己的线程执行（也就是谁先抢到谁执行） \n\twait():线程会释放锁,进入阻塞状态  \n\tnotify/notifyAll():在获取锁的状态下,唤醒wait()的线程  \n\tjoin():用来插队,线程A,执行了线程B的join方法,线程A必须要等待B执行完成了以后,线程A才能继续自己的工作\n\n> 应该尽量使用notifyAll,使用notify 只会唤醒一个 有可能发生信号丢失的的情况\n\n```\nyield() 、sleep()、wait()、notify()的区别:  \n线程在执行yield()以后,持有的锁是不释放的  \nsleep()方法被调用以后,持有的锁是不释放的  \n调动方法之前,必须要持有锁。调用了wait()方法以后,锁就会被释放,当wait方法返回的时候,线程会重新持有锁  \n调动方法之前,必须要持有锁,调用notify()方法本身不会释放锁的  \n```\n\n#### 线程间的共享\n\n- synchronized内置锁\n- volatile关键字 一个写 多个读的情况\n- ThreadLocal 线程变量\n```java\n//可以理解为 一个map,类型 Map<Thread,Integer>\nstatic ThreadLocal<Integer> threadLaocl = new ThreadLocal<Integer>(){\n\t@Override\n\tprotected Integer initialValue() {\n\t\treturn 1;\n\t}\n};\n```\n\n\n\n\n\n\n\n\n\n\n\n","slug":"多线程-01","published":1,"date":"2025-02-12T08:28:16.466Z","updated":"2025-02-12T08:28:16.466Z","_id":"clhua15bf002r9gj7143prg4a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>线程基础、线程之间的共享和协作</p>\n<h2 id=\"线程基础\"><a href=\"#线程基础\" class=\"headerlink\" title=\"线程基础\"></a>线程基础</h2><h4 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h4><ul>\n<li>进程：程序运行资源分配的最小单位,进程内部有多个线程,会共享这个进程的资源</li>\n<li>线程：CPU调度的最小单位,必须依赖进程而存在。</li>\n</ul>\n<h4 id=\"高并发编程的意义、好处和注意事项\"><a href=\"#高并发编程的意义、好处和注意事项\" class=\"headerlink\" title=\"高并发编程的意义、好处和注意事项\"></a>高并发编程的意义、好处和注意事项</h4><ul>\n<li>好处：充分利用cpu的资源、加快用户响应的时间,程序模块化,异步化</li>\n<li>问题：  <ul>\n<li>线程共享资源,存在冲突；  </li>\n<li>容易导致死锁；  </li>\n<li>启用太多的线程,就有搞垮机器的可能</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>  \n<h4 id=\"线程实现三种方式\"><a href=\"#线程实现三种方式\" class=\"headerlink\" title=\"线程实现三种方式\"></a>线程实现三种方式</h4><ul>\n<li>继承Thread</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 继承Thread</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseExtends</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"I am extends Thread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现Runnable 无返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现Runnable接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseRun</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"I am implements Runnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现Callable 又返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现Callable接口,允许有返回值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseCall</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"I am implements Callable\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"CallResult\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// extends</span></span><br><span class=\"line\">\tUseExtends useExtends = <span class=\"keyword\">new</span> UseExtends();</span><br><span class=\"line\">\tuseExtends.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Runable</span></span><br><span class=\"line\">\tUseRun useRun = <span class=\"keyword\">new</span> UseRun();</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> Thread(useRun).start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Callable</span></span><br><span class=\"line\">\tUseCall useCall = <span class=\"keyword\">new</span> UseCall();</span><br><span class=\"line\">\tFutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(useCall);</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> Thread(futureTask).start();</span><br><span class=\"line\">\tSystem.out.println(futureTask.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程停止\"><a href=\"#线程停止\" class=\"headerlink\" title=\"线程停止\"></a>线程停止</h4><blockquote>\n<p>stop(),resume(),suspend() 不建议使用了 容易造成死锁 可以使用interrupt()对线程加上中断标志 如下：</p>\n</blockquote>\n<pre><code>interrupt() 将线程中断标志位置为true\nisInterrupted() 判定当前线程是否处于中断状态。\ninterrupted() 判定当前线程是否处于中断状态,同时中断标志位改为false。\n方法里如果抛出InterruptedException,线程的中断标志位会被复位成false,如果确实是需要中断线程,要求我们自己在catch语句块里再次调用interrupt()。\n</code></pre><h4 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h4><p><img src=\"http://image.tupelo.top/thread_status.png\" alt=\"线程状态\"></p>\n<pre><code>run()和start():run方法就是普通对象的普通方法,只有调用了start()后,Java才会将线程对象和操作系统中实际的线程进行映射,再来执行run方法。  \nyield():把CPU时间让出来,让其他或者自己的线程执行（也就是谁先抢到谁执行） \nwait():线程会释放锁,进入阻塞状态  \nnotify/notifyAll():在获取锁的状态下,唤醒wait()的线程  \njoin():用来插队,线程A,执行了线程B的join方法,线程A必须要等待B执行完成了以后,线程A才能继续自己的工作\n</code></pre><blockquote>\n<p>应该尽量使用notifyAll,使用notify 只会唤醒一个 有可能发生信号丢失的的情况</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yield() 、sleep()、wait()、notify()的区别:  </span><br><span class=\"line\">线程在执行yield()以后,持有的锁是不释放的  </span><br><span class=\"line\">sleep()方法被调用以后,持有的锁是不释放的  </span><br><span class=\"line\">调动方法之前,必须要持有锁。调用了wait()方法以后,锁就会被释放,当wait方法返回的时候,线程会重新持有锁  </span><br><span class=\"line\">调动方法之前,必须要持有锁,调用notify()方法本身不会释放锁的</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程间的共享\"><a href=\"#线程间的共享\" class=\"headerlink\" title=\"线程间的共享\"></a>线程间的共享</h4><ul>\n<li>synchronized内置锁</li>\n<li>volatile关键字 一个写 多个读的情况</li>\n<li>ThreadLocal 线程变量<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以理解为 一个map,类型 Map&lt;Thread,Integer&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ThreadLocal&lt;Integer&gt; threadLaocl = <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>线程基础、线程之间的共享和协作</p>\n<h2 id=\"线程基础\"><a href=\"#线程基础\" class=\"headerlink\" title=\"线程基础\"></a>线程基础</h2><h4 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h4><ul>\n<li>进程：程序运行资源分配的最小单位,进程内部有多个线程,会共享这个进程的资源</li>\n<li>线程：CPU调度的最小单位,必须依赖进程而存在。</li>\n</ul>\n<h4 id=\"高并发编程的意义、好处和注意事项\"><a href=\"#高并发编程的意义、好处和注意事项\" class=\"headerlink\" title=\"高并发编程的意义、好处和注意事项\"></a>高并发编程的意义、好处和注意事项</h4><ul>\n<li>好处：充分利用cpu的资源、加快用户响应的时间,程序模块化,异步化</li>\n<li>问题：  <ul>\n<li>线程共享资源,存在冲突；  </li>\n<li>容易导致死锁；  </li>\n<li>启用太多的线程,就有搞垮机器的可能</li>\n</ul>\n</li>\n</ul>","more":"<h4 id=\"线程实现三种方式\"><a href=\"#线程实现三种方式\" class=\"headerlink\" title=\"线程实现三种方式\"></a>线程实现三种方式</h4><ul>\n<li>继承Thread</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 继承Thread</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseExtends</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"I am extends Thread\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现Runnable 无返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现Runnable接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseRun</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"I am implements Runnable\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现Callable 又返回值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现Callable接口,允许有返回值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UseCall</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"I am implements Callable\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"CallResult\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// extends</span></span><br><span class=\"line\">\tUseExtends useExtends = <span class=\"keyword\">new</span> UseExtends();</span><br><span class=\"line\">\tuseExtends.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Runable</span></span><br><span class=\"line\">\tUseRun useRun = <span class=\"keyword\">new</span> UseRun();</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> Thread(useRun).start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Callable</span></span><br><span class=\"line\">\tUseCall useCall = <span class=\"keyword\">new</span> UseCall();</span><br><span class=\"line\">\tFutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(useCall);</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> Thread(futureTask).start();</span><br><span class=\"line\">\tSystem.out.println(futureTask.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程停止\"><a href=\"#线程停止\" class=\"headerlink\" title=\"线程停止\"></a>线程停止</h4><blockquote>\n<p>stop(),resume(),suspend() 不建议使用了 容易造成死锁 可以使用interrupt()对线程加上中断标志 如下：</p>\n</blockquote>\n<pre><code>interrupt() 将线程中断标志位置为true\nisInterrupted() 判定当前线程是否处于中断状态。\ninterrupted() 判定当前线程是否处于中断状态,同时中断标志位改为false。\n方法里如果抛出InterruptedException,线程的中断标志位会被复位成false,如果确实是需要中断线程,要求我们自己在catch语句块里再次调用interrupt()。\n</code></pre><h4 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h4><p><img src=\"http://image.tupelo.top/thread_status.png\" alt=\"线程状态\"></p>\n<pre><code>run()和start():run方法就是普通对象的普通方法,只有调用了start()后,Java才会将线程对象和操作系统中实际的线程进行映射,再来执行run方法。  \nyield():把CPU时间让出来,让其他或者自己的线程执行（也就是谁先抢到谁执行） \nwait():线程会释放锁,进入阻塞状态  \nnotify/notifyAll():在获取锁的状态下,唤醒wait()的线程  \njoin():用来插队,线程A,执行了线程B的join方法,线程A必须要等待B执行完成了以后,线程A才能继续自己的工作\n</code></pre><blockquote>\n<p>应该尽量使用notifyAll,使用notify 只会唤醒一个 有可能发生信号丢失的的情况</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yield() 、sleep()、wait()、notify()的区别:  </span><br><span class=\"line\">线程在执行yield()以后,持有的锁是不释放的  </span><br><span class=\"line\">sleep()方法被调用以后,持有的锁是不释放的  </span><br><span class=\"line\">调动方法之前,必须要持有锁。调用了wait()方法以后,锁就会被释放,当wait方法返回的时候,线程会重新持有锁  </span><br><span class=\"line\">调动方法之前,必须要持有锁,调用notify()方法本身不会释放锁的</span><br></pre></td></tr></table></figure>\n<h4 id=\"线程间的共享\"><a href=\"#线程间的共享\" class=\"headerlink\" title=\"线程间的共享\"></a>线程间的共享</h4><ul>\n<li>synchronized内置锁</li>\n<li>volatile关键字 一个写 多个读的情况</li>\n<li>ThreadLocal 线程变量<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以理解为 一个map,类型 Map&lt;Thread,Integer&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ThreadLocal&lt;Integer&gt; threadLaocl = <span class=\"keyword\">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"并发编程 - 原子操作CAS","_content":"\n原子操作\n\n## CAS的原理\n\n\n\t\t利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止\n\t\t三个运算符：  一个内存地址V，一个期望的值A，一个新值B\n\t\t基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B，如果不是，不做任何操作。\n\t\t循环（死循环，自旋）里不断的进行CAS操作\n\n\n## CAS的问题\n\n\n- ABA问题（添加版本号解决）\n\t- AtomicMarkableReference，boolean 有没有动过\n\t- AtomicStampedReference  动过几次\n- 开销问题 长期不成功 会一直循环下去\n- 只能保证一个共享变量的原子操作\n\n## JDK中相关原子操作类的使用\n\n- 更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference\n- 更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray\n- 更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference\n- 原子更新字段类：AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/多线程-CAS.md","raw":"---\ntitle: 并发编程 - 原子操作CAS\ntags:\n  - 并发编程\n---\n\n原子操作\n\n## CAS的原理\n\n\n\t\t利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止\n\t\t三个运算符：  一个内存地址V，一个期望的值A，一个新值B\n\t\t基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B，如果不是，不做任何操作。\n\t\t循环（死循环，自旋）里不断的进行CAS操作\n\n\n## CAS的问题\n\n\n- ABA问题（添加版本号解决）\n\t- AtomicMarkableReference，boolean 有没有动过\n\t- AtomicStampedReference  动过几次\n- 开销问题 长期不成功 会一直循环下去\n- 只能保证一个共享变量的原子操作\n\n## JDK中相关原子操作类的使用\n\n- 更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference\n- 更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray\n- 更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference\n- 原子更新字段类：AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"多线程-CAS","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bf002t9gj7g4jh7oda","comments":1,"layout":"post","photos":[],"link":"","content":"<p>原子操作</p>\n<h2 id=\"CAS的原理\"><a href=\"#CAS的原理\" class=\"headerlink\" title=\"CAS的原理\"></a>CAS的原理</h2><pre><code>利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止\n三个运算符：  一个内存地址V，一个期望的值A，一个新值B\n基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B，如果不是，不做任何操作。\n循环（死循环，自旋）里不断的进行CAS操作\n</code></pre><h2 id=\"CAS的问题\"><a href=\"#CAS的问题\" class=\"headerlink\" title=\"CAS的问题\"></a>CAS的问题</h2><ul>\n<li>ABA问题（添加版本号解决）<ul>\n<li>AtomicMarkableReference，boolean 有没有动过</li>\n<li>AtomicStampedReference  动过几次</li>\n</ul>\n</li>\n<li>开销问题 长期不成功 会一直循环下去</li>\n<li>只能保证一个共享变量的原子操作</li>\n</ul>\n<h2 id=\"JDK中相关原子操作类的使用\"><a href=\"#JDK中相关原子操作类的使用\" class=\"headerlink\" title=\"JDK中相关原子操作类的使用\"></a>JDK中相关原子操作类的使用</h2><ul>\n<li>更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li>\n<li>更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>\n<li>更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference</li>\n<li>原子更新字段类：AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>原子操作</p>\n<h2 id=\"CAS的原理\"><a href=\"#CAS的原理\" class=\"headerlink\" title=\"CAS的原理\"></a>CAS的原理</h2><pre><code>利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止\n三个运算符：  一个内存地址V，一个期望的值A，一个新值B\n基本思路：如果地址V上的值和期望的值A相等，就给地址V赋给新值B，如果不是，不做任何操作。\n循环（死循环，自旋）里不断的进行CAS操作\n</code></pre><h2 id=\"CAS的问题\"><a href=\"#CAS的问题\" class=\"headerlink\" title=\"CAS的问题\"></a>CAS的问题</h2><ul>\n<li>ABA问题（添加版本号解决）<ul>\n<li>AtomicMarkableReference，boolean 有没有动过</li>\n<li>AtomicStampedReference  动过几次</li>\n</ul>\n</li>\n<li>开销问题 长期不成功 会一直循环下去</li>\n<li>只能保证一个共享变量的原子操作</li>\n</ul>\n<h2 id=\"JDK中相关原子操作类的使用\"><a href=\"#JDK中相关原子操作类的使用\" class=\"headerlink\" title=\"JDK中相关原子操作类的使用\"></a>JDK中相关原子操作类的使用</h2><ul>\n<li>更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</li>\n<li>更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>\n<li>更新引用类型：AtomicReference，AtomicMarkableReference，AtomicStampedReference</li>\n<li>原子更新字段类：AtomicReferenceFieldUpdater，AtomicIntegerFieldUpdater，AtomicLongFieldUpdater</li>\n</ul>\n"},{"title":"并发编程 - 并发工具类","_content":"\n并发工具类\n\n## Hashmap和HashTable\n\n- Hashmap多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。\n- HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\nHash\n\n散列，哈希：把任意长度的输入通过一种算法（散列），变换成为固定长度的输出，这个输出值就是散列值。属于压缩映射，容易产生哈希冲突。Hash算法有直接取余法等。\n产生哈希冲突时解决办法:\t\t\n\n- 开放寻址\t\t\n- 再散列\t\t\t\n- 链地址法（相同hash值的元素用链表串起来）\n\n<!-- more --> \n\n## 位运算\n\nJava实际保存int型时 正数  第31位 =0 \t负数：第31位=1\n常用位运算有：\n\n- 位与  &  (1&1=1 \t1&0=0\t 0&0=0)\n- 位或  |   (1|1=1\t\t 1|0=1 \t0|0=0)\n- 位非  ~  （ ~1=0 \t ~0=1）\n- 位异或  ^   (1^1=0\t 1^0=1\t 0^0=0) \n- <<有符号左移     >>有符号的右移    >>>无符号右移  例如：8 << 2 = 32\t8>>2 = 2\n- 取模的操作 a % (Math.pow(2,n)) 等价于 a&( Math.pow(2,n)-1)\n\n位运算适用：权限控制，物品的属性非常多时的保存\n\n## ConcurrentHashMap \n\n### 1.7中原理和实现\n\n- ConcurrentHashMap中的数据结构\n\nConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际继承自可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，每个Segment里包含一个HashEntry数组，我们称之为table，每个HashEntry是一个链表结构的元素。\t\t\n\n- 初始化 \n\n\t- initialCapacity：初始容量大小 ，默认16。\n\t- loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。\n\t- concurrencyLevel 并发度，默认16。并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。\n\n问: \tConcurrentHashMap实现原理是怎么样的或者问ConcurrentHashMap如何在保证高并发下线程安全的同时实现了性能提升？\t\t\n\n答: ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，只要多个修改操作发生在不同的段上，它们就可以并发进行。\t\t\n\t\t\n问: 在高并发下的情况下如何保证取得的元素是最新的？\t\t\n\n答：用于存储键值对数据的HashEntry，在设计上它的成员变量value等都是volatile类型的，这样就保证别的线程对value值的修改，get方法可以马上看到。\t\n\n\n### 1.8中原理和实现\n\n- 取消了segment数组，直接用table保存数据，锁的粒度更小，减少并发冲突的概率。\n- 存储数据时采用了链表+红黑树的形式，纯链表的形式时间复杂度为O(n)，红黑树则为O（logn），性能提升很大。\n\n问:什么时候链表转红黑树？当key值相等的元素形成的链表中元素个数超过8个的时候。\t\t\n问:什么时候红黑树转链表？当key值相等的元素形成的链表中元素个数少于6个的时候。\t\t\n\n\n## 更多的并发容器\n\n- ConcurrentSkipListMap和ConcurrentSkipListSet\n\n\tTreeMap和TreeSet有序的容器，这两种容器的并发版本\n\n- 跳表\n\n\tSkipList，以空间换时间，在原链表的基础上形成多层索引，但是某个节点在插入时，是否成为索引，随机决定，所以跳表又称为概率数据结构。\n\n- ConcurrentLinkedQueue\n\n\t无界非阻塞队列，底层是个链表，遵循先进先出原则。add,offer将元素插入到尾部，peek（拿头部的数据，但是不移除）和poll（拿头部的数据，但是移除）\n\n- 写时复制容器\n\n\t写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以写时复制容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向容器添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的，只能保证最终一致性。适用读多写少的并发场景，常见应用：白名单/黑名单， 商品类目的访问和更新场景。存在内存占用问题。\n\n## 阻塞队列\n\n### 概念、生产者消费者模式\n\n- 当队列满的时候，插入元素的线程被阻塞，直达队列不满。\n- 队列为空的时候，获取元素的线程被阻塞，直到队列不空。\n\n### 生产者和消费者模式\n\n生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。\n\n### 常用方法\n\n方法 | 抛出异常 |  返回值  | 一直阻塞 | 超时退出\n-|-|- | -| -\n插入方法 | add | offer | put | offer(time) |\n移除方法 | remove | poll | take | poll(time) |\n检查方法 | element | peek | N/A| N/A| \n\n\n- 抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（\"Queuefull\"）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。\n- 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。\n- 一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。\n- 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n\n### 常用阻塞队列 \n- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。\n\n\t按照先进先出原则，要求设定初始大小\n\n- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。\n\n\t按照先进先出原则，可以不设定初始大小，Integer.Max_Value\n\tArrayBlockingQueue和LinkedBlockingQueue不同:\n\n\t- 锁上面：ArrayBlockingQueue只有一个锁，LinkedBlockingQueue用了两个锁，\n\t- 实现上：ArrayBlockingQueue直接插入元素，LinkedBlockingQueue需要转换。\n\n- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。\n\n\t默认情况下，按照自然顺序，要么实现compareTo()方法，指定构造参数Comparator\n\n- DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n\n\t支持延时获取的元素的阻塞队列，元素必须要实现Delayed接口。适用场景：实现自己的缓存系统，订单到期，限时支付等等。\n\n- SynchronousQueue：一个不存储元素的阻塞队列。\n\t\n\t每一个put操作都要等待一个take操作\n\n- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n\t\n\ttransfer()，必须要消费者消费了以后方法才会返回，tryTransfer()无论消费者是否接收，方法都立即返回。\n\n- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\t\n\t可以从队列的头和尾都可以插入和移除元素，实现工作密取，方法名带了First对头部操作，带了last从尾部操作，另外：add=addLast;\tremove=removeFirst;\ttake=takeFirst\n\n\n","source":"_posts/多线程-并发工具类.md","raw":"---\ntitle: 并发编程 - 并发工具类\ntags:\n  - 并发编程\n---\n\n并发工具类\n\n## Hashmap和HashTable\n\n- Hashmap多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。\n- HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\nHash\n\n散列，哈希：把任意长度的输入通过一种算法（散列），变换成为固定长度的输出，这个输出值就是散列值。属于压缩映射，容易产生哈希冲突。Hash算法有直接取余法等。\n产生哈希冲突时解决办法:\t\t\n\n- 开放寻址\t\t\n- 再散列\t\t\t\n- 链地址法（相同hash值的元素用链表串起来）\n\n<!-- more --> \n\n## 位运算\n\nJava实际保存int型时 正数  第31位 =0 \t负数：第31位=1\n常用位运算有：\n\n- 位与  &  (1&1=1 \t1&0=0\t 0&0=0)\n- 位或  |   (1|1=1\t\t 1|0=1 \t0|0=0)\n- 位非  ~  （ ~1=0 \t ~0=1）\n- 位异或  ^   (1^1=0\t 1^0=1\t 0^0=0) \n- <<有符号左移     >>有符号的右移    >>>无符号右移  例如：8 << 2 = 32\t8>>2 = 2\n- 取模的操作 a % (Math.pow(2,n)) 等价于 a&( Math.pow(2,n)-1)\n\n位运算适用：权限控制，物品的属性非常多时的保存\n\n## ConcurrentHashMap \n\n### 1.7中原理和实现\n\n- ConcurrentHashMap中的数据结构\n\nConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际继承自可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，每个Segment里包含一个HashEntry数组，我们称之为table，每个HashEntry是一个链表结构的元素。\t\t\n\n- 初始化 \n\n\t- initialCapacity：初始容量大小 ，默认16。\n\t- loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。\n\t- concurrencyLevel 并发度，默认16。并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。\n\n问: \tConcurrentHashMap实现原理是怎么样的或者问ConcurrentHashMap如何在保证高并发下线程安全的同时实现了性能提升？\t\t\n\n答: ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，只要多个修改操作发生在不同的段上，它们就可以并发进行。\t\t\n\t\t\n问: 在高并发下的情况下如何保证取得的元素是最新的？\t\t\n\n答：用于存储键值对数据的HashEntry，在设计上它的成员变量value等都是volatile类型的，这样就保证别的线程对value值的修改，get方法可以马上看到。\t\n\n\n### 1.8中原理和实现\n\n- 取消了segment数组，直接用table保存数据，锁的粒度更小，减少并发冲突的概率。\n- 存储数据时采用了链表+红黑树的形式，纯链表的形式时间复杂度为O(n)，红黑树则为O（logn），性能提升很大。\n\n问:什么时候链表转红黑树？当key值相等的元素形成的链表中元素个数超过8个的时候。\t\t\n问:什么时候红黑树转链表？当key值相等的元素形成的链表中元素个数少于6个的时候。\t\t\n\n\n## 更多的并发容器\n\n- ConcurrentSkipListMap和ConcurrentSkipListSet\n\n\tTreeMap和TreeSet有序的容器，这两种容器的并发版本\n\n- 跳表\n\n\tSkipList，以空间换时间，在原链表的基础上形成多层索引，但是某个节点在插入时，是否成为索引，随机决定，所以跳表又称为概率数据结构。\n\n- ConcurrentLinkedQueue\n\n\t无界非阻塞队列，底层是个链表，遵循先进先出原则。add,offer将元素插入到尾部，peek（拿头部的数据，但是不移除）和poll（拿头部的数据，但是移除）\n\n- 写时复制容器\n\n\t写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以写时复制容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向容器添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的，只能保证最终一致性。适用读多写少的并发场景，常见应用：白名单/黑名单， 商品类目的访问和更新场景。存在内存占用问题。\n\n## 阻塞队列\n\n### 概念、生产者消费者模式\n\n- 当队列满的时候，插入元素的线程被阻塞，直达队列不满。\n- 队列为空的时候，获取元素的线程被阻塞，直到队列不空。\n\n### 生产者和消费者模式\n\n生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。\n\n### 常用方法\n\n方法 | 抛出异常 |  返回值  | 一直阻塞 | 超时退出\n-|-|- | -| -\n插入方法 | add | offer | put | offer(time) |\n移除方法 | remove | poll | take | poll(time) |\n检查方法 | element | peek | N/A| N/A| \n\n\n- 抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（\"Queuefull\"）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。\n- 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。\n- 一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。\n- 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n\n### 常用阻塞队列 \n- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。\n\n\t按照先进先出原则，要求设定初始大小\n\n- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。\n\n\t按照先进先出原则，可以不设定初始大小，Integer.Max_Value\n\tArrayBlockingQueue和LinkedBlockingQueue不同:\n\n\t- 锁上面：ArrayBlockingQueue只有一个锁，LinkedBlockingQueue用了两个锁，\n\t- 实现上：ArrayBlockingQueue直接插入元素，LinkedBlockingQueue需要转换。\n\n- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。\n\n\t默认情况下，按照自然顺序，要么实现compareTo()方法，指定构造参数Comparator\n\n- DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n\n\t支持延时获取的元素的阻塞队列，元素必须要实现Delayed接口。适用场景：实现自己的缓存系统，订单到期，限时支付等等。\n\n- SynchronousQueue：一个不存储元素的阻塞队列。\n\t\n\t每一个put操作都要等待一个take操作\n\n- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n\t\n\ttransfer()，必须要消费者消费了以后方法才会返回，tryTransfer()无论消费者是否接收，方法都立即返回。\n\n- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\t\n\t可以从队列的头和尾都可以插入和移除元素，实现工作密取，方法名带了First对头部操作，带了last从尾部操作，另外：add=addLast;\tremove=removeFirst;\ttake=takeFirst\n\n\n","slug":"多线程-并发工具类","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bg002v9gj718xrm6mb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>并发工具类</p>\n<h2 id=\"Hashmap和HashTable\"><a href=\"#Hashmap和HashTable\" class=\"headerlink\" title=\"Hashmap和HashTable\"></a>Hashmap和HashTable</h2><ul>\n<li>Hashmap多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</li>\n<li>HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</li>\n</ul>\n<p>Hash</p>\n<p>散列，哈希：把任意长度的输入通过一种算法（散列），变换成为固定长度的输出，这个输出值就是散列值。属于压缩映射，容易产生哈希冲突。Hash算法有直接取余法等。<br>产生哈希冲突时解决办法:        </p>\n<ul>\n<li>开放寻址        </li>\n<li>再散列            </li>\n<li>链地址法（相同hash值的元素用链表串起来）</li>\n</ul>\n<a id=\"more\"></a> \n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>Java实际保存int型时 正数  第31位 =0     负数：第31位=1<br>常用位运算有：</p>\n<ul>\n<li>位与  &amp;  (1&amp;1=1     1&amp;0=0     0&amp;0=0)</li>\n<li>位或  |   (1|1=1         1|0=1     0|0=0)</li>\n<li>位非  ~  （ ~1=0      ~0=1）</li>\n<li>位异或  ^   (1^1=0     1^0=1     0^0=0) </li>\n<li>&lt;&lt;有符号左移     &gt;&gt;有符号的右移    &gt;&gt;&gt;无符号右移  例如：8 &lt;&lt; 2 = 32    8&gt;&gt;2 = 2</li>\n<li>取模的操作 a % (Math.pow(2,n)) 等价于 a&amp;( Math.pow(2,n)-1)</li>\n</ul>\n<p>位运算适用：权限控制，物品的属性非常多时的保存</p>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><h3 id=\"1-7中原理和实现\"><a href=\"#1-7中原理和实现\" class=\"headerlink\" title=\"1.7中原理和实现\"></a>1.7中原理和实现</h3><ul>\n<li>ConcurrentHashMap中的数据结构</li>\n</ul>\n<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际继承自可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，每个Segment里包含一个HashEntry数组，我们称之为table，每个HashEntry是一个链表结构的元素。        </p>\n<ul>\n<li><p>初始化 </p>\n<ul>\n<li>initialCapacity：初始容量大小 ，默认16。</li>\n<li>loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。</li>\n<li>concurrencyLevel 并发度，默认16。并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</li>\n</ul>\n</li>\n</ul>\n<p>问:     ConcurrentHashMap实现原理是怎么样的或者问ConcurrentHashMap如何在保证高并发下线程安全的同时实现了性能提升？        </p>\n<p>答: ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，只要多个修改操作发生在不同的段上，它们就可以并发进行。        </p>\n<p>问: 在高并发下的情况下如何保证取得的元素是最新的？        </p>\n<p>答：用于存储键值对数据的HashEntry，在设计上它的成员变量value等都是volatile类型的，这样就保证别的线程对value值的修改，get方法可以马上看到。    </p>\n<h3 id=\"1-8中原理和实现\"><a href=\"#1-8中原理和实现\" class=\"headerlink\" title=\"1.8中原理和实现\"></a>1.8中原理和实现</h3><ul>\n<li>取消了segment数组，直接用table保存数据，锁的粒度更小，减少并发冲突的概率。</li>\n<li>存储数据时采用了链表+红黑树的形式，纯链表的形式时间复杂度为O(n)，红黑树则为O（logn），性能提升很大。</li>\n</ul>\n<p>问:什么时候链表转红黑树？当key值相等的元素形成的链表中元素个数超过8个的时候。<br>问:什么时候红黑树转链表？当key值相等的元素形成的链表中元素个数少于6个的时候。        </p>\n<h2 id=\"更多的并发容器\"><a href=\"#更多的并发容器\" class=\"headerlink\" title=\"更多的并发容器\"></a>更多的并发容器</h2><ul>\n<li><p>ConcurrentSkipListMap和ConcurrentSkipListSet</p>\n<p>  TreeMap和TreeSet有序的容器，这两种容器的并发版本</p>\n</li>\n<li><p>跳表</p>\n<p>  SkipList，以空间换时间，在原链表的基础上形成多层索引，但是某个节点在插入时，是否成为索引，随机决定，所以跳表又称为概率数据结构。</p>\n</li>\n<li><p>ConcurrentLinkedQueue</p>\n<p>  无界非阻塞队列，底层是个链表，遵循先进先出原则。add,offer将元素插入到尾部，peek（拿头部的数据，但是不移除）和poll（拿头部的数据，但是移除）</p>\n</li>\n<li><p>写时复制容器</p>\n<p>  写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以写时复制容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向容器添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的，只能保证最终一致性。适用读多写少的并发场景，常见应用：白名单/黑名单， 商品类目的访问和更新场景。存在内存占用问题。</p>\n</li>\n</ul>\n<h2 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h2><h3 id=\"概念、生产者消费者模式\"><a href=\"#概念、生产者消费者模式\" class=\"headerlink\" title=\"概念、生产者消费者模式\"></a>概念、生产者消费者模式</h3><ul>\n<li>当队列满的时候，插入元素的线程被阻塞，直达队列不满。</li>\n<li>队列为空的时候，获取元素的线程被阻塞，直到队列不空。</li>\n</ul>\n<h3 id=\"生产者和消费者模式\"><a href=\"#生产者和消费者模式\" class=\"headerlink\" title=\"生产者和消费者模式\"></a>生产者和消费者模式</h3><p>生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>抛出异常</th>\n<th>返回值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入方法</td>\n<td>add</td>\n<td>offer</td>\n<td>put</td>\n<td>offer(time)</td>\n<td></td>\n</tr>\n<tr>\n<td>移除方法</td>\n<td>remove</td>\n<td>poll</td>\n<td>take</td>\n<td>poll(time)</td>\n<td></td>\n</tr>\n<tr>\n<td>检查方法</td>\n<td>element</td>\n<td>peek</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>\n<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>\n<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>\n<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>\n</ul>\n<h3 id=\"常用阻塞队列\"><a href=\"#常用阻塞队列\" class=\"headerlink\" title=\"常用阻塞队列\"></a>常用阻塞队列</h3><ul>\n<li><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p>\n<p>  按照先进先出原则，要求设定初始大小</p>\n</li>\n<li><p>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</p>\n<p>  按照先进先出原则，可以不设定初始大小，Integer.Max_Value<br>  ArrayBlockingQueue和LinkedBlockingQueue不同:</p>\n<ul>\n<li>锁上面：ArrayBlockingQueue只有一个锁，LinkedBlockingQueue用了两个锁，</li>\n<li>实现上：ArrayBlockingQueue直接插入元素，LinkedBlockingQueue需要转换。</li>\n</ul>\n</li>\n<li><p>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</p>\n<p>  默认情况下，按照自然顺序，要么实现compareTo()方法，指定构造参数Comparator</p>\n</li>\n<li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>\n<p>  支持延时获取的元素的阻塞队列，元素必须要实现Delayed接口。适用场景：实现自己的缓存系统，订单到期，限时支付等等。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>\n<p>  每一个put操作都要等待一个take操作</p>\n</li>\n<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>\n<p>  transfer()，必须要消费者消费了以后方法才会返回，tryTransfer()无论消费者是否接收，方法都立即返回。</p>\n</li>\n<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n<p>  可以从队列的头和尾都可以插入和移除元素，实现工作密取，方法名带了First对头部操作，带了last从尾部操作，另外：add=addLast;    remove=removeFirst;    take=takeFirst</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>并发工具类</p>\n<h2 id=\"Hashmap和HashTable\"><a href=\"#Hashmap和HashTable\" class=\"headerlink\" title=\"Hashmap和HashTable\"></a>Hashmap和HashTable</h2><ul>\n<li>Hashmap多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</li>\n<li>HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</li>\n</ul>\n<p>Hash</p>\n<p>散列，哈希：把任意长度的输入通过一种算法（散列），变换成为固定长度的输出，这个输出值就是散列值。属于压缩映射，容易产生哈希冲突。Hash算法有直接取余法等。<br>产生哈希冲突时解决办法:        </p>\n<ul>\n<li>开放寻址        </li>\n<li>再散列            </li>\n<li>链地址法（相同hash值的元素用链表串起来）</li>\n</ul>","more":"<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>Java实际保存int型时 正数  第31位 =0     负数：第31位=1<br>常用位运算有：</p>\n<ul>\n<li>位与  &amp;  (1&amp;1=1     1&amp;0=0     0&amp;0=0)</li>\n<li>位或  |   (1|1=1         1|0=1     0|0=0)</li>\n<li>位非  ~  （ ~1=0      ~0=1）</li>\n<li>位异或  ^   (1^1=0     1^0=1     0^0=0) </li>\n<li>&lt;&lt;有符号左移     &gt;&gt;有符号的右移    &gt;&gt;&gt;无符号右移  例如：8 &lt;&lt; 2 = 32    8&gt;&gt;2 = 2</li>\n<li>取模的操作 a % (Math.pow(2,n)) 等价于 a&amp;( Math.pow(2,n)-1)</li>\n</ul>\n<p>位运算适用：权限控制，物品的属性非常多时的保存</p>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><h3 id=\"1-7中原理和实现\"><a href=\"#1-7中原理和实现\" class=\"headerlink\" title=\"1.7中原理和实现\"></a>1.7中原理和实现</h3><ul>\n<li>ConcurrentHashMap中的数据结构</li>\n</ul>\n<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment实际继承自可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，每个Segment里包含一个HashEntry数组，我们称之为table，每个HashEntry是一个链表结构的元素。        </p>\n<ul>\n<li><p>初始化 </p>\n<ul>\n<li>initialCapacity：初始容量大小 ，默认16。</li>\n<li>loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。</li>\n<li>concurrencyLevel 并发度，默认16。并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</li>\n</ul>\n</li>\n</ul>\n<p>问:     ConcurrentHashMap实现原理是怎么样的或者问ConcurrentHashMap如何在保证高并发下线程安全的同时实现了性能提升？        </p>\n<p>答: ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，只要多个修改操作发生在不同的段上，它们就可以并发进行。        </p>\n<p>问: 在高并发下的情况下如何保证取得的元素是最新的？        </p>\n<p>答：用于存储键值对数据的HashEntry，在设计上它的成员变量value等都是volatile类型的，这样就保证别的线程对value值的修改，get方法可以马上看到。    </p>\n<h3 id=\"1-8中原理和实现\"><a href=\"#1-8中原理和实现\" class=\"headerlink\" title=\"1.8中原理和实现\"></a>1.8中原理和实现</h3><ul>\n<li>取消了segment数组，直接用table保存数据，锁的粒度更小，减少并发冲突的概率。</li>\n<li>存储数据时采用了链表+红黑树的形式，纯链表的形式时间复杂度为O(n)，红黑树则为O（logn），性能提升很大。</li>\n</ul>\n<p>问:什么时候链表转红黑树？当key值相等的元素形成的链表中元素个数超过8个的时候。<br>问:什么时候红黑树转链表？当key值相等的元素形成的链表中元素个数少于6个的时候。        </p>\n<h2 id=\"更多的并发容器\"><a href=\"#更多的并发容器\" class=\"headerlink\" title=\"更多的并发容器\"></a>更多的并发容器</h2><ul>\n<li><p>ConcurrentSkipListMap和ConcurrentSkipListSet</p>\n<p>  TreeMap和TreeSet有序的容器，这两种容器的并发版本</p>\n</li>\n<li><p>跳表</p>\n<p>  SkipList，以空间换时间，在原链表的基础上形成多层索引，但是某个节点在插入时，是否成为索引，随机决定，所以跳表又称为概率数据结构。</p>\n</li>\n<li><p>ConcurrentLinkedQueue</p>\n<p>  无界非阻塞队列，底层是个链表，遵循先进先出原则。add,offer将元素插入到尾部，peek（拿头部的数据，但是不移除）和poll（拿头部的数据，但是移除）</p>\n</li>\n<li><p>写时复制容器</p>\n<p>  写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以写时复制容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向容器添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的，只能保证最终一致性。适用读多写少的并发场景，常见应用：白名单/黑名单， 商品类目的访问和更新场景。存在内存占用问题。</p>\n</li>\n</ul>\n<h2 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h2><h3 id=\"概念、生产者消费者模式\"><a href=\"#概念、生产者消费者模式\" class=\"headerlink\" title=\"概念、生产者消费者模式\"></a>概念、生产者消费者模式</h3><ul>\n<li>当队列满的时候，插入元素的线程被阻塞，直达队列不满。</li>\n<li>队列为空的时候，获取元素的线程被阻塞，直到队列不空。</li>\n</ul>\n<h3 id=\"生产者和消费者模式\"><a href=\"#生产者和消费者模式\" class=\"headerlink\" title=\"生产者和消费者模式\"></a>生产者和消费者模式</h3><p>生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>抛出异常</th>\n<th>返回值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>插入方法</td>\n<td>add</td>\n<td>offer</td>\n<td>put</td>\n<td>offer(time)</td>\n<td></td>\n</tr>\n<tr>\n<td>移除方法</td>\n<td>remove</td>\n<td>poll</td>\n<td>take</td>\n<td>poll(time)</td>\n<td></td>\n</tr>\n<tr>\n<td>检查方法</td>\n<td>element</td>\n<td>peek</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>\n<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>\n<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>\n<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>\n</ul>\n<h3 id=\"常用阻塞队列\"><a href=\"#常用阻塞队列\" class=\"headerlink\" title=\"常用阻塞队列\"></a>常用阻塞队列</h3><ul>\n<li><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p>\n<p>  按照先进先出原则，要求设定初始大小</p>\n</li>\n<li><p>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</p>\n<p>  按照先进先出原则，可以不设定初始大小，Integer.Max_Value<br>  ArrayBlockingQueue和LinkedBlockingQueue不同:</p>\n<ul>\n<li>锁上面：ArrayBlockingQueue只有一个锁，LinkedBlockingQueue用了两个锁，</li>\n<li>实现上：ArrayBlockingQueue直接插入元素，LinkedBlockingQueue需要转换。</li>\n</ul>\n</li>\n<li><p>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</p>\n<p>  默认情况下，按照自然顺序，要么实现compareTo()方法，指定构造参数Comparator</p>\n</li>\n<li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>\n<p>  支持延时获取的元素的阻塞队列，元素必须要实现Delayed接口。适用场景：实现自己的缓存系统，订单到期，限时支付等等。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>\n<p>  每一个put操作都要等待一个take操作</p>\n</li>\n<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>\n<p>  transfer()，必须要消费者消费了以后方法才会返回，tryTransfer()无论消费者是否接收，方法都立即返回。</p>\n</li>\n<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n<p>  可以从队列的头和尾都可以插入和移除元素，实现工作密取，方法名带了First对头部操作，带了last从尾部操作，另外：add=addLast;    remove=removeFirst;    take=takeFirst</p>\n</li>\n</ul>"},{"title":"并发编程 - 显式锁和AQS","_content":"\n显式锁和AQS\n\n## 显式锁\n\nLock接口\n\n```java\n\n \tprivate Lock lock = new ReentrantLock();\n    private int count;\n    // 一定要在finally中释放锁\n    public void increament() {\n        this.lock.lock();\n\n        try {\n            ++this.count;\n        } finally {\n            this.lock.unlock();\n        }\n\n    }\n```\n\n- 可重入锁ReentrantLock(默认非公平锁 构造方法可控制是否是公平锁)\n\n\t采用一个计数器，每重入一次次数加一，释放一个锁次数减一\n\n- 读写锁ReentrantReadWriteLock\n\n\t同一时刻允许多个读线程同时访问，但是写线程访问的时候，所有的读和写都被阻塞，最适宜与读多写少的情况\n\n- Condition接口\n\n\t阻塞一个线程await()，唤醒是最好使用singal().wait()阻塞线程使用notfiyAll()唤醒。\n\n\n<!-- more -->  \n\n## AQS AbstractQueuedSynchronizer\n\nAQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。\n\n![AQS](http://image.tupelo.top/53727-ae36db58241c256b.png)\n\n- 设计模式\n\t\n\t使用了模板方法设计模式，模板方法有：\t\t\n\t独占式获取：\n\n\t- accquire\n\t- acquireInterruptibly\n\t- tryAcquireNanos\n\n\t共享式获取\n\n\t- acquireShared\n\t- acquireSharedInterruptibly\n\t- tryAcquireSharedNanos\n\n\t独占式释放锁\n\n\t- release\n\n\t共享式释放锁\n\n\t- releaseShared\n\n\n\n- state状态\n\n  AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。state的访问方式有三种:\n\n``` java\ngetState()\nsetState()\n// CAS\ncompareAndSetState() \n```\n\n- 自定义资源共享方式\n\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\n\n- AQS中的数据结构-节点和同步队列\n\n\t竞争失败的线程会打包成Node放到同步队列，Node可能的状态里：\n\n\t- CANCELLED：线程等待超时或者被中断了，需要从队列中移走\n\t- SIGNAL：后续的节点等待状态，当前节点，通知后面的节点去运行\n\t- CONDITION :当前节点处于等待队列\n\t- PROPAGATE：共享，表示状态要往后面的节点传播，0表示初始状态\n\n- 独占式同步状态获取与释放\n\n\n![](http://image.tupelo.top/%E5%9B%BE%E7%89%87%201.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/多线程-显式锁和AQS.md","raw":"---\ntitle: 并发编程 - 显式锁和AQS\ntags:\n  - 并发编程\n---\n\n显式锁和AQS\n\n## 显式锁\n\nLock接口\n\n```java\n\n \tprivate Lock lock = new ReentrantLock();\n    private int count;\n    // 一定要在finally中释放锁\n    public void increament() {\n        this.lock.lock();\n\n        try {\n            ++this.count;\n        } finally {\n            this.lock.unlock();\n        }\n\n    }\n```\n\n- 可重入锁ReentrantLock(默认非公平锁 构造方法可控制是否是公平锁)\n\n\t采用一个计数器，每重入一次次数加一，释放一个锁次数减一\n\n- 读写锁ReentrantReadWriteLock\n\n\t同一时刻允许多个读线程同时访问，但是写线程访问的时候，所有的读和写都被阻塞，最适宜与读多写少的情况\n\n- Condition接口\n\n\t阻塞一个线程await()，唤醒是最好使用singal().wait()阻塞线程使用notfiyAll()唤醒。\n\n\n<!-- more -->  \n\n## AQS AbstractQueuedSynchronizer\n\nAQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。\n\n![AQS](http://image.tupelo.top/53727-ae36db58241c256b.png)\n\n- 设计模式\n\t\n\t使用了模板方法设计模式，模板方法有：\t\t\n\t独占式获取：\n\n\t- accquire\n\t- acquireInterruptibly\n\t- tryAcquireNanos\n\n\t共享式获取\n\n\t- acquireShared\n\t- acquireSharedInterruptibly\n\t- tryAcquireSharedNanos\n\n\t独占式释放锁\n\n\t- release\n\n\t共享式释放锁\n\n\t- releaseShared\n\n\n\n- state状态\n\n  AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。state的访问方式有三种:\n\n``` java\ngetState()\nsetState()\n// CAS\ncompareAndSetState() \n```\n\n- 自定义资源共享方式\n\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\n\n- AQS中的数据结构-节点和同步队列\n\n\t竞争失败的线程会打包成Node放到同步队列，Node可能的状态里：\n\n\t- CANCELLED：线程等待超时或者被中断了，需要从队列中移走\n\t- SIGNAL：后续的节点等待状态，当前节点，通知后面的节点去运行\n\t- CONDITION :当前节点处于等待队列\n\t- PROPAGATE：共享，表示状态要往后面的节点传播，0表示初始状态\n\n- 独占式同步状态获取与释放\n\n\n![](http://image.tupelo.top/%E5%9B%BE%E7%89%87%201.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"多线程-显式锁和AQS","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bh002x9gj7o9cs1omg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>显式锁和AQS</p>\n<h2 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h2><p>Lock接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">  <span class=\"comment\">// 一定要在finally中释放锁</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increament</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.lock.lock();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          ++<span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.lock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>可重入锁ReentrantLock(默认非公平锁 构造方法可控制是否是公平锁)</p>\n<p>  采用一个计数器，每重入一次次数加一，释放一个锁次数减一</p>\n</li>\n<li><p>读写锁ReentrantReadWriteLock</p>\n<p>  同一时刻允许多个读线程同时访问，但是写线程访问的时候，所有的读和写都被阻塞，最适宜与读多写少的情况</p>\n</li>\n<li><p>Condition接口</p>\n<p>  阻塞一个线程await()，唤醒是最好使用singal().wait()阻塞线程使用notfiyAll()唤醒。</p>\n</li>\n</ul>\n<a id=\"more\"></a>  \n<h2 id=\"AQS-AbstractQueuedSynchronizer\"><a href=\"#AQS-AbstractQueuedSynchronizer\" class=\"headerlink\" title=\"AQS AbstractQueuedSynchronizer\"></a>AQS AbstractQueuedSynchronizer</h2><p>AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。</p>\n<p><img src=\"http://image.tupelo.top/53727-ae36db58241c256b.png\" alt=\"AQS\"></p>\n<ul>\n<li><p>设计模式</p>\n<p>  使用了模板方法设计模式，模板方法有：<br>  独占式获取：</p>\n<ul>\n<li>accquire</li>\n<li>acquireInterruptibly</li>\n<li><p>tryAcquireNanos</p>\n<p>共享式获取</p>\n</li>\n<li><p>acquireShared</p>\n</li>\n<li>acquireSharedInterruptibly</li>\n<li><p>tryAcquireSharedNanos</p>\n<p>独占式释放锁</p>\n</li>\n<li><p>release</p>\n<p>共享式释放锁</p>\n</li>\n<li><p>releaseShared</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>state状态</li>\n</ul>\n<p>  AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。state的访问方式有三种:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getState()</span><br><span class=\"line\">setState()</span><br><span class=\"line\"><span class=\"comment\">// CAS</span></span><br><span class=\"line\">compareAndSetState()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义资源共享方式</li>\n</ul>\n<p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>\n<ul>\n<li><p>AQS中的数据结构-节点和同步队列</p>\n<p>  竞争失败的线程会打包成Node放到同步队列，Node可能的状态里：</p>\n<ul>\n<li>CANCELLED：线程等待超时或者被中断了，需要从队列中移走</li>\n<li>SIGNAL：后续的节点等待状态，当前节点，通知后面的节点去运行</li>\n<li>CONDITION :当前节点处于等待队列</li>\n<li>PROPAGATE：共享，表示状态要往后面的节点传播，0表示初始状态</li>\n</ul>\n</li>\n<li><p>独占式同步状态获取与释放</p>\n</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/%E5%9B%BE%E7%89%87%201.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>显式锁和AQS</p>\n<h2 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h2><p>Lock接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">  <span class=\"comment\">// 一定要在finally中释放锁</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increament</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.lock.lock();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          ++<span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.lock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>可重入锁ReentrantLock(默认非公平锁 构造方法可控制是否是公平锁)</p>\n<p>  采用一个计数器，每重入一次次数加一，释放一个锁次数减一</p>\n</li>\n<li><p>读写锁ReentrantReadWriteLock</p>\n<p>  同一时刻允许多个读线程同时访问，但是写线程访问的时候，所有的读和写都被阻塞，最适宜与读多写少的情况</p>\n</li>\n<li><p>Condition接口</p>\n<p>  阻塞一个线程await()，唤醒是最好使用singal().wait()阻塞线程使用notfiyAll()唤醒。</p>\n</li>\n</ul>","more":"<h2 id=\"AQS-AbstractQueuedSynchronizer\"><a href=\"#AQS-AbstractQueuedSynchronizer\" class=\"headerlink\" title=\"AQS AbstractQueuedSynchronizer\"></a>AQS AbstractQueuedSynchronizer</h2><p>AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。</p>\n<p><img src=\"http://image.tupelo.top/53727-ae36db58241c256b.png\" alt=\"AQS\"></p>\n<ul>\n<li><p>设计模式</p>\n<p>  使用了模板方法设计模式，模板方法有：<br>  独占式获取：</p>\n<ul>\n<li>accquire</li>\n<li>acquireInterruptibly</li>\n<li><p>tryAcquireNanos</p>\n<p>共享式获取</p>\n</li>\n<li><p>acquireShared</p>\n</li>\n<li>acquireSharedInterruptibly</li>\n<li><p>tryAcquireSharedNanos</p>\n<p>独占式释放锁</p>\n</li>\n<li><p>release</p>\n<p>共享式释放锁</p>\n</li>\n<li><p>releaseShared</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>state状态</li>\n</ul>\n<p>  AbstractQueuedSynchronizer维护了一个volatile int类型的变量，用户表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性。state的访问方式有三种:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getState()</span><br><span class=\"line\">setState()</span><br><span class=\"line\"><span class=\"comment\">// CAS</span></span><br><span class=\"line\">compareAndSetState()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义资源共享方式</li>\n</ul>\n<p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>\n<ul>\n<li><p>AQS中的数据结构-节点和同步队列</p>\n<p>  竞争失败的线程会打包成Node放到同步队列，Node可能的状态里：</p>\n<ul>\n<li>CANCELLED：线程等待超时或者被中断了，需要从队列中移走</li>\n<li>SIGNAL：后续的节点等待状态，当前节点，通知后面的节点去运行</li>\n<li>CONDITION :当前节点处于等待队列</li>\n<li>PROPAGATE：共享，表示状态要往后面的节点传播，0表示初始状态</li>\n</ul>\n</li>\n<li><p>独占式同步状态获取与释放</p>\n</li>\n</ul>\n<p><img src=\"http://image.tupelo.top/%E5%9B%BE%E7%89%87%201.png\" alt=\"\"></p>"},{"title":"并发编程 - 并发安全","_content":"\n并发安全\n\n## 类的线程安全定义\n\n\t\t如果多线程下使用这个类，不过多线程如何使用和调度这个类，这个类总是表示出正确的行为，这个类就是线程安全的。\n\t\t类的线程安全表现为：\n\t\t\t操作的原子性\n\t\t\t内存的可见性\n\t\t不做正确的同步，在多个线程之间共享状态的时候，就会出现线程不安全。\n\n<!-- more -->  \n\n\n## 怎么才能做到类的线程安全？\n\n- 栈封闭\n\n\t\t所有的变量都是在方法内部声明的，这些变量都处于栈封闭状态。\n\n- 无状态\n\n\t\t没有任何成员变量的类，就叫无状态的类\n\n- 让类不可变\n\n\t\t让状态不可变，两种方式：\n\t\t1，加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的类也要是不可变，才能保证整个类是不可变的。\n\t\t2、根本就不提供任何可供修改成员变量的地方，同时成员变量也不作为方法的返回值\n\n\n- volatile\n\n\t\t保证类的可见性，最适合一个线程写，多个线程读的情景，\n\n- 加锁和CAS\n- 安全的发布\n\n\t\t类中持有的成员变量，特别是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从而造成整个类线程不安全的问题。\n\n- TheadLocal\n\n\n## 安全问题\n\n- 死锁\n\n\t\t资源一定是多于1个，同时小于等于竞争的线程数，资源只有一个，只会产生激烈的竞争。\n\t\t死锁的根本成因：获取锁的顺序不一致导致。\n\t\t怀疑发送死锁：\n\t\t\t通过jps 查询应用的 id，\n\t\t\t再通过jstack id 查看应用的锁的持有情况\n\t\t解决办法：保证加锁的顺序性\n\n- 活锁\n\n\t\t尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生拿锁，释放锁的过程。\n\t\t解决办法：每个线程休眠随机数，错开拿锁的时间\n\n- 线程饥饿\n\n\t\t低优先级的线程，总是拿不到执行时间\n\n\n## 性能思考\n\n\t\t1、\t先保证程序正确，确实达不到要求的时候，再提高速度。（黄金原则）\n\t\t2、\t一定要以测试为基准。\n\t\t一个应用程序里，串行的部分是永远都有的。\n\n## 影响性能的因素\n\n- 上下文切换\n\n        是指CPU从一个进程或线程切换到另一个进程或线程。一次上下文切换花费5000~10000个时钟周期，几微秒。\n\n- 内存同步\n- 阻塞\n\n## 解决\n\n- 减少锁的竞争\t\t\t\n\n- 减少锁的粒度\n\n\t\t使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁\n\n- 缩小锁的范围\n\n\t\t对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作\n\n- 避免多余的缩减锁的范围\n\n\t\t两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化—扩大锁的范围。\n\n- 锁分段\n\t\n\t\t替换独占锁\n\n- 替换独占锁\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/多线程-线程安全.md","raw":"---\ntitle: 并发编程 - 并发安全\ntags:\n  - 并发编程\n---\n\n并发安全\n\n## 类的线程安全定义\n\n\t\t如果多线程下使用这个类，不过多线程如何使用和调度这个类，这个类总是表示出正确的行为，这个类就是线程安全的。\n\t\t类的线程安全表现为：\n\t\t\t操作的原子性\n\t\t\t内存的可见性\n\t\t不做正确的同步，在多个线程之间共享状态的时候，就会出现线程不安全。\n\n<!-- more -->  \n\n\n## 怎么才能做到类的线程安全？\n\n- 栈封闭\n\n\t\t所有的变量都是在方法内部声明的，这些变量都处于栈封闭状态。\n\n- 无状态\n\n\t\t没有任何成员变量的类，就叫无状态的类\n\n- 让类不可变\n\n\t\t让状态不可变，两种方式：\n\t\t1，加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的类也要是不可变，才能保证整个类是不可变的。\n\t\t2、根本就不提供任何可供修改成员变量的地方，同时成员变量也不作为方法的返回值\n\n\n- volatile\n\n\t\t保证类的可见性，最适合一个线程写，多个线程读的情景，\n\n- 加锁和CAS\n- 安全的发布\n\n\t\t类中持有的成员变量，特别是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从而造成整个类线程不安全的问题。\n\n- TheadLocal\n\n\n## 安全问题\n\n- 死锁\n\n\t\t资源一定是多于1个，同时小于等于竞争的线程数，资源只有一个，只会产生激烈的竞争。\n\t\t死锁的根本成因：获取锁的顺序不一致导致。\n\t\t怀疑发送死锁：\n\t\t\t通过jps 查询应用的 id，\n\t\t\t再通过jstack id 查看应用的锁的持有情况\n\t\t解决办法：保证加锁的顺序性\n\n- 活锁\n\n\t\t尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生拿锁，释放锁的过程。\n\t\t解决办法：每个线程休眠随机数，错开拿锁的时间\n\n- 线程饥饿\n\n\t\t低优先级的线程，总是拿不到执行时间\n\n\n## 性能思考\n\n\t\t1、\t先保证程序正确，确实达不到要求的时候，再提高速度。（黄金原则）\n\t\t2、\t一定要以测试为基准。\n\t\t一个应用程序里，串行的部分是永远都有的。\n\n## 影响性能的因素\n\n- 上下文切换\n\n        是指CPU从一个进程或线程切换到另一个进程或线程。一次上下文切换花费5000~10000个时钟周期，几微秒。\n\n- 内存同步\n- 阻塞\n\n## 解决\n\n- 减少锁的竞争\t\t\t\n\n- 减少锁的粒度\n\n\t\t使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁\n\n- 缩小锁的范围\n\n\t\t对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作\n\n- 避免多余的缩减锁的范围\n\n\t\t两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化—扩大锁的范围。\n\n- 锁分段\n\t\n\t\t替换独占锁\n\n- 替换独占锁\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"多线程-线程安全","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bi002z9gj72n3ewgy9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>并发安全</p>\n<h2 id=\"类的线程安全定义\"><a href=\"#类的线程安全定义\" class=\"headerlink\" title=\"类的线程安全定义\"></a>类的线程安全定义</h2><pre><code>如果多线程下使用这个类，不过多线程如何使用和调度这个类，这个类总是表示出正确的行为，这个类就是线程安全的。\n类的线程安全表现为：\n    操作的原子性\n    内存的可见性\n不做正确的同步，在多个线程之间共享状态的时候，就会出现线程不安全。\n</code></pre><a id=\"more\"></a>  \n<h2 id=\"怎么才能做到类的线程安全？\"><a href=\"#怎么才能做到类的线程安全？\" class=\"headerlink\" title=\"怎么才能做到类的线程安全？\"></a>怎么才能做到类的线程安全？</h2><ul>\n<li><p>栈封闭</p>\n<pre><code>所有的变量都是在方法内部声明的，这些变量都处于栈封闭状态。\n</code></pre></li>\n<li><p>无状态</p>\n<pre><code>没有任何成员变量的类，就叫无状态的类\n</code></pre></li>\n<li><p>让类不可变</p>\n<pre><code>让状态不可变，两种方式：\n1，加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的类也要是不可变，才能保证整个类是不可变的。\n2、根本就不提供任何可供修改成员变量的地方，同时成员变量也不作为方法的返回值\n</code></pre></li>\n</ul>\n<ul>\n<li><p>volatile</p>\n<pre><code>保证类的可见性，最适合一个线程写，多个线程读的情景，\n</code></pre></li>\n<li><p>加锁和CAS</p>\n</li>\n<li><p>安全的发布</p>\n<pre><code>类中持有的成员变量，特别是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从而造成整个类线程不安全的问题。\n</code></pre></li>\n<li><p>TheadLocal</p>\n</li>\n</ul>\n<h2 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h2><ul>\n<li><p>死锁</p>\n<pre><code>资源一定是多于1个，同时小于等于竞争的线程数，资源只有一个，只会产生激烈的竞争。\n死锁的根本成因：获取锁的顺序不一致导致。\n怀疑发送死锁：\n    通过jps 查询应用的 id，\n    再通过jstack id 查看应用的锁的持有情况\n解决办法：保证加锁的顺序性\n</code></pre></li>\n<li><p>活锁</p>\n<pre><code>尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生拿锁，释放锁的过程。\n解决办法：每个线程休眠随机数，错开拿锁的时间\n</code></pre></li>\n<li><p>线程饥饿</p>\n<pre><code>低优先级的线程，总是拿不到执行时间\n</code></pre></li>\n</ul>\n<h2 id=\"性能思考\"><a href=\"#性能思考\" class=\"headerlink\" title=\"性能思考\"></a>性能思考</h2><pre><code>1、    先保证程序正确，确实达不到要求的时候，再提高速度。（黄金原则）\n2、    一定要以测试为基准。\n一个应用程序里，串行的部分是永远都有的。\n</code></pre><h2 id=\"影响性能的因素\"><a href=\"#影响性能的因素\" class=\"headerlink\" title=\"影响性能的因素\"></a>影响性能的因素</h2><ul>\n<li><p>上下文切换</p>\n<pre><code>是指CPU从一个进程或线程切换到另一个进程或线程。一次上下文切换花费5000~10000个时钟周期，几微秒。\n</code></pre></li>\n<li><p>内存同步</p>\n</li>\n<li>阻塞</li>\n</ul>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><ul>\n<li><p>减少锁的竞争            </p>\n</li>\n<li><p>减少锁的粒度</p>\n<pre><code>使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁\n</code></pre></li>\n<li><p>缩小锁的范围</p>\n<pre><code>对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作\n</code></pre></li>\n<li><p>避免多余的缩减锁的范围</p>\n<pre><code>两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化—扩大锁的范围。\n</code></pre></li>\n<li><p>锁分段</p>\n<pre><code>替换独占锁\n</code></pre></li>\n<li><p>替换独占锁</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>并发安全</p>\n<h2 id=\"类的线程安全定义\"><a href=\"#类的线程安全定义\" class=\"headerlink\" title=\"类的线程安全定义\"></a>类的线程安全定义</h2><pre><code>如果多线程下使用这个类，不过多线程如何使用和调度这个类，这个类总是表示出正确的行为，这个类就是线程安全的。\n类的线程安全表现为：\n    操作的原子性\n    内存的可见性\n不做正确的同步，在多个线程之间共享状态的时候，就会出现线程不安全。\n</code></pre>","more":"<h2 id=\"怎么才能做到类的线程安全？\"><a href=\"#怎么才能做到类的线程安全？\" class=\"headerlink\" title=\"怎么才能做到类的线程安全？\"></a>怎么才能做到类的线程安全？</h2><ul>\n<li><p>栈封闭</p>\n<pre><code>所有的变量都是在方法内部声明的，这些变量都处于栈封闭状态。\n</code></pre></li>\n<li><p>无状态</p>\n<pre><code>没有任何成员变量的类，就叫无状态的类\n</code></pre></li>\n<li><p>让类不可变</p>\n<pre><code>让状态不可变，两种方式：\n1，加final关键字，对于一个类，所有的成员变量应该是私有的，同样的只要有可能，所有的成员变量应该加上final关键字，但是加上final，要注意如果成员变量又是一个对象时，这个对象所对应的类也要是不可变，才能保证整个类是不可变的。\n2、根本就不提供任何可供修改成员变量的地方，同时成员变量也不作为方法的返回值\n</code></pre></li>\n</ul>\n<ul>\n<li><p>volatile</p>\n<pre><code>保证类的可见性，最适合一个线程写，多个线程读的情景，\n</code></pre></li>\n<li><p>加锁和CAS</p>\n</li>\n<li><p>安全的发布</p>\n<pre><code>类中持有的成员变量，特别是对象的引用，如果这个成员对象不是线程安全的，通过get等方法发布出去，会造成这个成员对象本身持有的数据在多线程下不正确的修改，从而造成整个类线程不安全的问题。\n</code></pre></li>\n<li><p>TheadLocal</p>\n</li>\n</ul>\n<h2 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h2><ul>\n<li><p>死锁</p>\n<pre><code>资源一定是多于1个，同时小于等于竞争的线程数，资源只有一个，只会产生激烈的竞争。\n死锁的根本成因：获取锁的顺序不一致导致。\n怀疑发送死锁：\n    通过jps 查询应用的 id，\n    再通过jstack id 查看应用的锁的持有情况\n解决办法：保证加锁的顺序性\n</code></pre></li>\n<li><p>活锁</p>\n<pre><code>尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生拿锁，释放锁的过程。\n解决办法：每个线程休眠随机数，错开拿锁的时间\n</code></pre></li>\n<li><p>线程饥饿</p>\n<pre><code>低优先级的线程，总是拿不到执行时间\n</code></pre></li>\n</ul>\n<h2 id=\"性能思考\"><a href=\"#性能思考\" class=\"headerlink\" title=\"性能思考\"></a>性能思考</h2><pre><code>1、    先保证程序正确，确实达不到要求的时候，再提高速度。（黄金原则）\n2、    一定要以测试为基准。\n一个应用程序里，串行的部分是永远都有的。\n</code></pre><h2 id=\"影响性能的因素\"><a href=\"#影响性能的因素\" class=\"headerlink\" title=\"影响性能的因素\"></a>影响性能的因素</h2><ul>\n<li><p>上下文切换</p>\n<pre><code>是指CPU从一个进程或线程切换到另一个进程或线程。一次上下文切换花费5000~10000个时钟周期，几微秒。\n</code></pre></li>\n<li><p>内存同步</p>\n</li>\n<li>阻塞</li>\n</ul>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><ul>\n<li><p>减少锁的竞争            </p>\n</li>\n<li><p>减少锁的粒度</p>\n<pre><code>使用锁的时候，锁所保护的对象是多个，当这些多个对象其实是独立变化的时候，不如用多个锁来一一保护这些对象。但是如果有同时要持有多个锁的业务方法，要注意避免发生死锁\n</code></pre></li>\n<li><p>缩小锁的范围</p>\n<pre><code>对锁的持有实现快进快出，尽量缩短持由锁的的时间。将一些与锁无关的代码移出锁的范围，特别是一些耗时，可能阻塞的操作\n</code></pre></li>\n<li><p>避免多余的缩减锁的范围</p>\n<pre><code>两次加锁之间的语句非常简单，导致加锁的时间比执行这些语句还长，这个时候应该进行锁粗化—扩大锁的范围。\n</code></pre></li>\n<li><p>锁分段</p>\n<pre><code>替换独占锁\n</code></pre></li>\n<li><p>替换独占锁</p>\n</li>\n</ul>"},{"title":"设计模式-工厂模式总结","_content":"\n### 工厂模式总结\n\n> 使用原则:\n\n- 解耦：把对象的创建和使用的过程分开。\n- 工厂负责对象的创建，包括其init方法的调用，黑盒创建过程。\n- 面向接口编程： 使用者只管使用，只知其接口而不知其实现类。\n\n> 对比:\n\n- 静态工厂：把所有对象的创建逻辑集中到一个（专业）类里处理\n- 工厂方法模式：一个工厂负责创建一个产品类的创建\n- 抽象工厂模式：将一个系列的产品的工厂合并成一个工厂，负责生产这个系列的产品\n- 建造者模式：对象的创建比较复杂时，按步骤一块块创建，让创建过程模板化。\n","source":"_posts/工厂模式总结.md","raw":"---\ntitle: 设计模式-工厂模式总结\ntags:\n  - 设计模式\n---\n\n### 工厂模式总结\n\n> 使用原则:\n\n- 解耦：把对象的创建和使用的过程分开。\n- 工厂负责对象的创建，包括其init方法的调用，黑盒创建过程。\n- 面向接口编程： 使用者只管使用，只知其接口而不知其实现类。\n\n> 对比:\n\n- 静态工厂：把所有对象的创建逻辑集中到一个（专业）类里处理\n- 工厂方法模式：一个工厂负责创建一个产品类的创建\n- 抽象工厂模式：将一个系列的产品的工厂合并成一个工厂，负责生产这个系列的产品\n- 建造者模式：对象的创建比较复杂时，按步骤一块块创建，让创建过程模板化。\n","slug":"工厂模式总结","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bj00319gj72676u4du","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"工厂模式总结\"><a href=\"#工厂模式总结\" class=\"headerlink\" title=\"工厂模式总结\"></a>工厂模式总结</h3><blockquote>\n<p>使用原则:</p>\n</blockquote>\n<ul>\n<li>解耦：把对象的创建和使用的过程分开。</li>\n<li>工厂负责对象的创建，包括其init方法的调用，黑盒创建过程。</li>\n<li>面向接口编程： 使用者只管使用，只知其接口而不知其实现类。</li>\n</ul>\n<blockquote>\n<p>对比:</p>\n</blockquote>\n<ul>\n<li>静态工厂：把所有对象的创建逻辑集中到一个（专业）类里处理</li>\n<li>工厂方法模式：一个工厂负责创建一个产品类的创建</li>\n<li>抽象工厂模式：将一个系列的产品的工厂合并成一个工厂，负责生产这个系列的产品</li>\n<li>建造者模式：对象的创建比较复杂时，按步骤一块块创建，让创建过程模板化。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"工厂模式总结\"><a href=\"#工厂模式总结\" class=\"headerlink\" title=\"工厂模式总结\"></a>工厂模式总结</h3><blockquote>\n<p>使用原则:</p>\n</blockquote>\n<ul>\n<li>解耦：把对象的创建和使用的过程分开。</li>\n<li>工厂负责对象的创建，包括其init方法的调用，黑盒创建过程。</li>\n<li>面向接口编程： 使用者只管使用，只知其接口而不知其实现类。</li>\n</ul>\n<blockquote>\n<p>对比:</p>\n</blockquote>\n<ul>\n<li>静态工厂：把所有对象的创建逻辑集中到一个（专业）类里处理</li>\n<li>工厂方法模式：一个工厂负责创建一个产品类的创建</li>\n<li>抽象工厂模式：将一个系列的产品的工厂合并成一个工厂，负责生产这个系列的产品</li>\n<li>建造者模式：对象的创建比较复杂时，按步骤一块块创建，让创建过程模板化。</li>\n</ul>\n"},{"title":"设计模式-工厂方法模式","_content":"\n### 工厂方法模式\n\n>   将静态工厂类打散，每一类对象都有一个工厂来创建。\n\n![工厂方法模式](http://image.tupelo.top/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png)\n\n","source":"_posts/工厂方法模式.md","raw":"---\ntitle: 设计模式-工厂方法模式\ntags:\n  - 设计模式\n---\n\n### 工厂方法模式\n\n>   将静态工厂类打散，每一类对象都有一个工厂来创建。\n\n![工厂方法模式](http://image.tupelo.top/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png)\n\n","slug":"工厂方法模式","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bk00339gj7zkk1jkon","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><blockquote>\n<p>  将静态工厂类打散，每一类对象都有一个工厂来创建。</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png\" alt=\"工厂方法模式\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><blockquote>\n<p>  将静态工厂类打散，每一类对象都有一个工厂来创建。</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png\" alt=\"工厂方法模式\"></p>\n"},{"title":"并发编程 - 线程池","_content":"\n线程池\n\n## 使用线程池的好处\n\n- 降低资源的消耗。降低线程创建和销毁的资源消耗；\n- 提高响应速度：线程的创建时间为T1，执行时间T2,销毁时间T3，免去T1和T3的时间\n- 提高线程的可管理性。\n\n\n## 线程池的创建\n\n\n> ThreadPoolExecutor，jdk所有线程池实现的父类\n\n```java\nThreadPoolExecutor executor = new ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) \n```\n\n各个参数的含义:\t\t\n\n- corePoolSize  ：线程池中核心线程数，< corePoolSize  ，就会创建新线程，= corePoolSize  ，这个任务就会保存到BlockingQueue，如果调用prestartAllCoreThreads（）方法就会一次性的启动corePoolSize  个数的线程。\n- maximumPoolSize, 允许的最大线程数，BlockingQueue也满了，< maximumPoolSize时候就会再次创建新的线程\n- keepAliveTime, 线程空闲下来后，存活的时间，这个参数只在> corePoolSize才有用\nTimeUnit unit, 存活时间的单位值\n- workQueue, 保存任务的阻塞队列\n- threadFactory, 创建线程的工厂，给新建的线程赋予名字\n- handler ：饱和策略\n\t- AbortPolicy ：直接抛出异常，默认；\n\t- CallerRunsPolicy：用调用者所在的线程来执行任务\n\t- DiscardOldestPolicy：丢弃阻塞队列里最老的任务，队列里最靠前的任务\n\t- DiscardPolicy ：当前任务直接丢弃\t\t\t\n\n实现自己的饱和策略，实现RejectedExecutionHandler接口即可\n\n<!-- more -->  \n\n## 提交任务\n\n```java\nvoid execute(Runnable command);\n\n// 有返回值\nFuture<T> submit(Callable<T> task);\n```\n\n## 终止任务\n\n```java\n//设置线程池的状态，还会尝试停止正在运行或者暂停任务的线程\nexecutor.shutdown();\n//设置线程池的状态，只会中断所有没有执行任务的线程\nexecutor.shutdownNow();\n```\n\n## 工作机制\n\n![线程池](http://image.tupelo.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)\n\n\n## 合理配置线程池\n\n- 计算密集型（CPU） \n\t- 线程数适当小一点，最大推荐：机器的Cpu核心数+1 为什么+1，防止页缺失，(机器的Cpu核心=Runtime.getRuntime().availableProcessors();)\n- IO密集型\n\t- 读取文件，数据库连接，网络通讯, 线程数适当大一点，机器的Cpu核心数*2\n- 混合型\n\t- 尽量拆分小\n- 队列的选择上，应该使用有界，无界队列可能会导致内存溢出\n\n\n\n## jdk预定义的线程池\n\n- FixedThreadPool\n\t\n\t\t创建固定线程数量的，适用于负载较重的服务器，使用了无界队列\n\n- SingleThreadExecutor\n\n\t\t创建单个线程，需要顺序保证执行任务，不会有多个线程活动，使用了无界队列\n\n- CachedThreadPool\n\n\t\t会根据需要来创建新线程的，执行很多短期异步任务的程序，使用了SynchronousQueue\n\n- WorkStealingPool\n\n\t\t基于ForkJoinPool实现\n\n- ScheduledThreadPoolExecutor \n\n\t\tnewSingleThreadScheduledExecutor：只包含一个线程，只需要单个线程执行周期任务，保证顺序的执行各个任务\n\t\tnewScheduledThreadPool 可以包含多个线程的，线程执行周期任务，适度控制后台线程数量的时候\n\t\t方法说明：\n\t\tschedule：只执行一次，任务还可以延时执行\n\t\tscheduleAtFixedRate：提交固定时间间隔的任务\n\t\tscheduleWithFixedDelay：提交固定延时间隔执行的任务\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/多线程-线程池.md","raw":"---\ntitle: 并发编程 - 线程池\ntags:\n  - 并发编程\n---\n\n线程池\n\n## 使用线程池的好处\n\n- 降低资源的消耗。降低线程创建和销毁的资源消耗；\n- 提高响应速度：线程的创建时间为T1，执行时间T2,销毁时间T3，免去T1和T3的时间\n- 提高线程的可管理性。\n\n\n## 线程池的创建\n\n\n> ThreadPoolExecutor，jdk所有线程池实现的父类\n\n```java\nThreadPoolExecutor executor = new ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) \n```\n\n各个参数的含义:\t\t\n\n- corePoolSize  ：线程池中核心线程数，< corePoolSize  ，就会创建新线程，= corePoolSize  ，这个任务就会保存到BlockingQueue，如果调用prestartAllCoreThreads（）方法就会一次性的启动corePoolSize  个数的线程。\n- maximumPoolSize, 允许的最大线程数，BlockingQueue也满了，< maximumPoolSize时候就会再次创建新的线程\n- keepAliveTime, 线程空闲下来后，存活的时间，这个参数只在> corePoolSize才有用\nTimeUnit unit, 存活时间的单位值\n- workQueue, 保存任务的阻塞队列\n- threadFactory, 创建线程的工厂，给新建的线程赋予名字\n- handler ：饱和策略\n\t- AbortPolicy ：直接抛出异常，默认；\n\t- CallerRunsPolicy：用调用者所在的线程来执行任务\n\t- DiscardOldestPolicy：丢弃阻塞队列里最老的任务，队列里最靠前的任务\n\t- DiscardPolicy ：当前任务直接丢弃\t\t\t\n\n实现自己的饱和策略，实现RejectedExecutionHandler接口即可\n\n<!-- more -->  \n\n## 提交任务\n\n```java\nvoid execute(Runnable command);\n\n// 有返回值\nFuture<T> submit(Callable<T> task);\n```\n\n## 终止任务\n\n```java\n//设置线程池的状态，还会尝试停止正在运行或者暂停任务的线程\nexecutor.shutdown();\n//设置线程池的状态，只会中断所有没有执行任务的线程\nexecutor.shutdownNow();\n```\n\n## 工作机制\n\n![线程池](http://image.tupelo.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)\n\n\n## 合理配置线程池\n\n- 计算密集型（CPU） \n\t- 线程数适当小一点，最大推荐：机器的Cpu核心数+1 为什么+1，防止页缺失，(机器的Cpu核心=Runtime.getRuntime().availableProcessors();)\n- IO密集型\n\t- 读取文件，数据库连接，网络通讯, 线程数适当大一点，机器的Cpu核心数*2\n- 混合型\n\t- 尽量拆分小\n- 队列的选择上，应该使用有界，无界队列可能会导致内存溢出\n\n\n\n## jdk预定义的线程池\n\n- FixedThreadPool\n\t\n\t\t创建固定线程数量的，适用于负载较重的服务器，使用了无界队列\n\n- SingleThreadExecutor\n\n\t\t创建单个线程，需要顺序保证执行任务，不会有多个线程活动，使用了无界队列\n\n- CachedThreadPool\n\n\t\t会根据需要来创建新线程的，执行很多短期异步任务的程序，使用了SynchronousQueue\n\n- WorkStealingPool\n\n\t\t基于ForkJoinPool实现\n\n- ScheduledThreadPoolExecutor \n\n\t\tnewSingleThreadScheduledExecutor：只包含一个线程，只需要单个线程执行周期任务，保证顺序的执行各个任务\n\t\tnewScheduledThreadPool 可以包含多个线程的，线程执行周期任务，适度控制后台线程数量的时候\n\t\t方法说明：\n\t\tschedule：只执行一次，任务还可以延时执行\n\t\tscheduleAtFixedRate：提交固定时间间隔的任务\n\t\tscheduleWithFixedDelay：提交固定延时间隔执行的任务\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"多线程-线程池","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bl00359gj7btmgnq2y","comments":1,"layout":"post","photos":[],"link":"","content":"<p>线程池</p>\n<h2 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h2><ul>\n<li>降低资源的消耗。降低线程创建和销毁的资源消耗；</li>\n<li>提高响应速度：线程的创建时间为T1，执行时间T2,销毁时间T3，免去T1和T3的时间</li>\n<li>提高线程的可管理性。</li>\n</ul>\n<h2 id=\"线程池的创建\"><a href=\"#线程池的创建\" class=\"headerlink\" title=\"线程池的创建\"></a>线程池的创建</h2><blockquote>\n<p>ThreadPoolExecutor，jdk所有线程池实现的父类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize,</span><br><span class=\"line\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span><br><span class=\"line\">                              <span class=\"keyword\">long</span> keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n<p>各个参数的含义:        </p>\n<ul>\n<li>corePoolSize  ：线程池中核心线程数，&lt; corePoolSize  ，就会创建新线程，= corePoolSize  ，这个任务就会保存到BlockingQueue，如果调用prestartAllCoreThreads（）方法就会一次性的启动corePoolSize  个数的线程。</li>\n<li>maximumPoolSize, 允许的最大线程数，BlockingQueue也满了，&lt; maximumPoolSize时候就会再次创建新的线程</li>\n<li>keepAliveTime, 线程空闲下来后，存活的时间，这个参数只在&gt; corePoolSize才有用<br>TimeUnit unit, 存活时间的单位值</li>\n<li>workQueue, 保存任务的阻塞队列</li>\n<li>threadFactory, 创建线程的工厂，给新建的线程赋予名字</li>\n<li>handler ：饱和策略<ul>\n<li>AbortPolicy ：直接抛出异常，默认；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，队列里最靠前的任务</li>\n<li>DiscardPolicy ：当前任务直接丢弃            </li>\n</ul>\n</li>\n</ul>\n<p>实现自己的饱和策略，实现RejectedExecutionHandler接口即可</p>\n<a id=\"more\"></a>  \n<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"终止任务\"><a href=\"#终止任务\" class=\"headerlink\" title=\"终止任务\"></a>终止任务</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置线程池的状态，还会尝试停止正在运行或者暂停任务的线程</span></span><br><span class=\"line\">executor.shutdown();</span><br><span class=\"line\"><span class=\"comment\">//设置线程池的状态，只会中断所有没有执行任务的线程</span></span><br><span class=\"line\">executor.shutdownNow();</span><br></pre></td></tr></table></figure>\n<h2 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h2><p><img src=\"http://image.tupelo.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png\" alt=\"线程池\"></p>\n<h2 id=\"合理配置线程池\"><a href=\"#合理配置线程池\" class=\"headerlink\" title=\"合理配置线程池\"></a>合理配置线程池</h2><ul>\n<li>计算密集型（CPU） <ul>\n<li>线程数适当小一点，最大推荐：机器的Cpu核心数+1 为什么+1，防止页缺失，(机器的Cpu核心=Runtime.getRuntime().availableProcessors();)</li>\n</ul>\n</li>\n<li>IO密集型<ul>\n<li>读取文件，数据库连接，网络通讯, 线程数适当大一点，机器的Cpu核心数*2</li>\n</ul>\n</li>\n<li>混合型<ul>\n<li>尽量拆分小</li>\n</ul>\n</li>\n<li>队列的选择上，应该使用有界，无界队列可能会导致内存溢出</li>\n</ul>\n<h2 id=\"jdk预定义的线程池\"><a href=\"#jdk预定义的线程池\" class=\"headerlink\" title=\"jdk预定义的线程池\"></a>jdk预定义的线程池</h2><ul>\n<li><p>FixedThreadPool</p>\n<pre><code>创建固定线程数量的，适用于负载较重的服务器，使用了无界队列\n</code></pre></li>\n<li><p>SingleThreadExecutor</p>\n<pre><code>创建单个线程，需要顺序保证执行任务，不会有多个线程活动，使用了无界队列\n</code></pre></li>\n<li><p>CachedThreadPool</p>\n<pre><code>会根据需要来创建新线程的，执行很多短期异步任务的程序，使用了SynchronousQueue\n</code></pre></li>\n<li><p>WorkStealingPool</p>\n<pre><code>基于ForkJoinPool实现\n</code></pre></li>\n<li><p>ScheduledThreadPoolExecutor </p>\n<pre><code>newSingleThreadScheduledExecutor：只包含一个线程，只需要单个线程执行周期任务，保证顺序的执行各个任务\nnewScheduledThreadPool 可以包含多个线程的，线程执行周期任务，适度控制后台线程数量的时候\n方法说明：\nschedule：只执行一次，任务还可以延时执行\nscheduleAtFixedRate：提交固定时间间隔的任务\nscheduleWithFixedDelay：提交固定延时间隔执行的任务\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>线程池</p>\n<h2 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h2><ul>\n<li>降低资源的消耗。降低线程创建和销毁的资源消耗；</li>\n<li>提高响应速度：线程的创建时间为T1，执行时间T2,销毁时间T3，免去T1和T3的时间</li>\n<li>提高线程的可管理性。</li>\n</ul>\n<h2 id=\"线程池的创建\"><a href=\"#线程池的创建\" class=\"headerlink\" title=\"线程池的创建\"></a>线程池的创建</h2><blockquote>\n<p>ThreadPoolExecutor，jdk所有线程池实现的父类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize,</span><br><span class=\"line\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span><br><span class=\"line\">                              <span class=\"keyword\">long</span> keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n<p>各个参数的含义:        </p>\n<ul>\n<li>corePoolSize  ：线程池中核心线程数，&lt; corePoolSize  ，就会创建新线程，= corePoolSize  ，这个任务就会保存到BlockingQueue，如果调用prestartAllCoreThreads（）方法就会一次性的启动corePoolSize  个数的线程。</li>\n<li>maximumPoolSize, 允许的最大线程数，BlockingQueue也满了，&lt; maximumPoolSize时候就会再次创建新的线程</li>\n<li>keepAliveTime, 线程空闲下来后，存活的时间，这个参数只在&gt; corePoolSize才有用<br>TimeUnit unit, 存活时间的单位值</li>\n<li>workQueue, 保存任务的阻塞队列</li>\n<li>threadFactory, 创建线程的工厂，给新建的线程赋予名字</li>\n<li>handler ：饱和策略<ul>\n<li>AbortPolicy ：直接抛出异常，默认；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，队列里最靠前的任务</li>\n<li>DiscardPolicy ：当前任务直接丢弃            </li>\n</ul>\n</li>\n</ul>\n<p>实现自己的饱和策略，实现RejectedExecutionHandler接口即可</p>","more":"<h2 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"终止任务\"><a href=\"#终止任务\" class=\"headerlink\" title=\"终止任务\"></a>终止任务</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置线程池的状态，还会尝试停止正在运行或者暂停任务的线程</span></span><br><span class=\"line\">executor.shutdown();</span><br><span class=\"line\"><span class=\"comment\">//设置线程池的状态，只会中断所有没有执行任务的线程</span></span><br><span class=\"line\">executor.shutdownNow();</span><br></pre></td></tr></table></figure>\n<h2 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h2><p><img src=\"http://image.tupelo.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png\" alt=\"线程池\"></p>\n<h2 id=\"合理配置线程池\"><a href=\"#合理配置线程池\" class=\"headerlink\" title=\"合理配置线程池\"></a>合理配置线程池</h2><ul>\n<li>计算密集型（CPU） <ul>\n<li>线程数适当小一点，最大推荐：机器的Cpu核心数+1 为什么+1，防止页缺失，(机器的Cpu核心=Runtime.getRuntime().availableProcessors();)</li>\n</ul>\n</li>\n<li>IO密集型<ul>\n<li>读取文件，数据库连接，网络通讯, 线程数适当大一点，机器的Cpu核心数*2</li>\n</ul>\n</li>\n<li>混合型<ul>\n<li>尽量拆分小</li>\n</ul>\n</li>\n<li>队列的选择上，应该使用有界，无界队列可能会导致内存溢出</li>\n</ul>\n<h2 id=\"jdk预定义的线程池\"><a href=\"#jdk预定义的线程池\" class=\"headerlink\" title=\"jdk预定义的线程池\"></a>jdk预定义的线程池</h2><ul>\n<li><p>FixedThreadPool</p>\n<pre><code>创建固定线程数量的，适用于负载较重的服务器，使用了无界队列\n</code></pre></li>\n<li><p>SingleThreadExecutor</p>\n<pre><code>创建单个线程，需要顺序保证执行任务，不会有多个线程活动，使用了无界队列\n</code></pre></li>\n<li><p>CachedThreadPool</p>\n<pre><code>会根据需要来创建新线程的，执行很多短期异步任务的程序，使用了SynchronousQueue\n</code></pre></li>\n<li><p>WorkStealingPool</p>\n<pre><code>基于ForkJoinPool实现\n</code></pre></li>\n<li><p>ScheduledThreadPoolExecutor </p>\n<pre><code>newSingleThreadScheduledExecutor：只包含一个线程，只需要单个线程执行周期任务，保证顺序的执行各个任务\nnewScheduledThreadPool 可以包含多个线程的，线程执行周期任务，适度控制后台线程数量的时候\n方法说明：\nschedule：只执行一次，任务还可以延时执行\nscheduleAtFixedRate：提交固定时间间隔的任务\nscheduleWithFixedDelay：提交固定延时间隔执行的任务\n</code></pre></li>\n</ul>"},{"title":"总结-MQ","_content":"\n\n\n## kafka\n\n分为生产者、broker、消费者\ntopic: 虚拟的\n分区: 分区，实际真正存放消息的地方，多个分区中有一个主分区，主分区负责消息读取，副本负责消息同步\n副本: 一个分区有多个副本\nAR: 所有副本集合\nISR: 同步进度相差不大分副本,参与leader选举\nOSR: AR - ISR\n\nkafka消费者偏移量的存储\n\n消费者的offset会更新到一个kafka自带的topic consumer_offsets 下面   \n\nkafka的消息丢失\n\nkafka的高可用controller选举\n\ncontroller实际是在zk中注册了一个临时节点，当controller挂了之后，kafka中集群监听器就会通知其它的broker到zk中创建controler的临时节点，成功了就是新的controller。\n\nkafka文件存储\n\n每个分区都会在所在broker上创建文件夹，一个分区文件又分为多段，每段两个文件，一个日志文件，一个索引文件，日志文件末尾以偏移量命名，查找消息先根据文件名称定位段，然后根据索引文件定位所在位置。\n\n\nkafka文件删除\n\n时间或者大小\n\nkafka零拷贝\n\nkafka分区一致性\n\n\n\nkafka rebalance\n\nkafka数据可靠性\n\n配置响应ACKS,0-无需等待落盘，1-需要等待leader落盘，-1/ALL-所有的节点都落盘\n\n不同的消息语义\n\n至少一次: ACKS = =1\n至多一次: ACKS = 0\n精准一次: \n\n\n## RocketMq\n\n严格的顺序性 （kafka非严格）\n拉模型\n堆积能力强\n满足至少消费一次的语义\n\n支持事务消息 保证最终一致性\n18个等级的小时延时\n可以指定次数和时间的重试\nbrocker\n\n\n\n## RabbitMq\n\n推模型\n","source":"_posts/总结-MQ.md","raw":"---\ntitle: 总结-MQ\ntags:\n  - 总结\n---\n\n\n\n## kafka\n\n分为生产者、broker、消费者\ntopic: 虚拟的\n分区: 分区，实际真正存放消息的地方，多个分区中有一个主分区，主分区负责消息读取，副本负责消息同步\n副本: 一个分区有多个副本\nAR: 所有副本集合\nISR: 同步进度相差不大分副本,参与leader选举\nOSR: AR - ISR\n\nkafka消费者偏移量的存储\n\n消费者的offset会更新到一个kafka自带的topic consumer_offsets 下面   \n\nkafka的消息丢失\n\nkafka的高可用controller选举\n\ncontroller实际是在zk中注册了一个临时节点，当controller挂了之后，kafka中集群监听器就会通知其它的broker到zk中创建controler的临时节点，成功了就是新的controller。\n\nkafka文件存储\n\n每个分区都会在所在broker上创建文件夹，一个分区文件又分为多段，每段两个文件，一个日志文件，一个索引文件，日志文件末尾以偏移量命名，查找消息先根据文件名称定位段，然后根据索引文件定位所在位置。\n\n\nkafka文件删除\n\n时间或者大小\n\nkafka零拷贝\n\nkafka分区一致性\n\n\n\nkafka rebalance\n\nkafka数据可靠性\n\n配置响应ACKS,0-无需等待落盘，1-需要等待leader落盘，-1/ALL-所有的节点都落盘\n\n不同的消息语义\n\n至少一次: ACKS = =1\n至多一次: ACKS = 0\n精准一次: \n\n\n## RocketMq\n\n严格的顺序性 （kafka非严格）\n拉模型\n堆积能力强\n满足至少消费一次的语义\n\n支持事务消息 保证最终一致性\n18个等级的小时延时\n可以指定次数和时间的重试\nbrocker\n\n\n\n## RabbitMq\n\n推模型\n","slug":"总结-MQ","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bm00379gj736jjzoqg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"kafka\"><a href=\"#kafka\" class=\"headerlink\" title=\"kafka\"></a>kafka</h2><p>分为生产者、broker、消费者<br>topic: 虚拟的<br>分区: 分区，实际真正存放消息的地方，多个分区中有一个主分区，主分区负责消息读取，副本负责消息同步<br>副本: 一个分区有多个副本<br>AR: 所有副本集合<br>ISR: 同步进度相差不大分副本,参与leader选举<br>OSR: AR - ISR</p>\n<p>kafka消费者偏移量的存储</p>\n<p>消费者的offset会更新到一个kafka自带的topic consumer_offsets 下面   </p>\n<p>kafka的消息丢失</p>\n<p>kafka的高可用controller选举</p>\n<p>controller实际是在zk中注册了一个临时节点，当controller挂了之后，kafka中集群监听器就会通知其它的broker到zk中创建controler的临时节点，成功了就是新的controller。</p>\n<p>kafka文件存储</p>\n<p>每个分区都会在所在broker上创建文件夹，一个分区文件又分为多段，每段两个文件，一个日志文件，一个索引文件，日志文件末尾以偏移量命名，查找消息先根据文件名称定位段，然后根据索引文件定位所在位置。</p>\n<p>kafka文件删除</p>\n<p>时间或者大小</p>\n<p>kafka零拷贝</p>\n<p>kafka分区一致性</p>\n<p>kafka rebalance</p>\n<p>kafka数据可靠性</p>\n<p>配置响应ACKS,0-无需等待落盘，1-需要等待leader落盘，-1/ALL-所有的节点都落盘</p>\n<p>不同的消息语义</p>\n<p>至少一次: ACKS = =1<br>至多一次: ACKS = 0<br>精准一次: </p>\n<h2 id=\"RocketMq\"><a href=\"#RocketMq\" class=\"headerlink\" title=\"RocketMq\"></a>RocketMq</h2><p>严格的顺序性 （kafka非严格）<br>拉模型<br>堆积能力强<br>满足至少消费一次的语义</p>\n<p>支持事务消息 保证最终一致性<br>18个等级的小时延时<br>可以指定次数和时间的重试<br>brocker</p>\n<h2 id=\"RabbitMq\"><a href=\"#RabbitMq\" class=\"headerlink\" title=\"RabbitMq\"></a>RabbitMq</h2><p>推模型</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"kafka\"><a href=\"#kafka\" class=\"headerlink\" title=\"kafka\"></a>kafka</h2><p>分为生产者、broker、消费者<br>topic: 虚拟的<br>分区: 分区，实际真正存放消息的地方，多个分区中有一个主分区，主分区负责消息读取，副本负责消息同步<br>副本: 一个分区有多个副本<br>AR: 所有副本集合<br>ISR: 同步进度相差不大分副本,参与leader选举<br>OSR: AR - ISR</p>\n<p>kafka消费者偏移量的存储</p>\n<p>消费者的offset会更新到一个kafka自带的topic consumer_offsets 下面   </p>\n<p>kafka的消息丢失</p>\n<p>kafka的高可用controller选举</p>\n<p>controller实际是在zk中注册了一个临时节点，当controller挂了之后，kafka中集群监听器就会通知其它的broker到zk中创建controler的临时节点，成功了就是新的controller。</p>\n<p>kafka文件存储</p>\n<p>每个分区都会在所在broker上创建文件夹，一个分区文件又分为多段，每段两个文件，一个日志文件，一个索引文件，日志文件末尾以偏移量命名，查找消息先根据文件名称定位段，然后根据索引文件定位所在位置。</p>\n<p>kafka文件删除</p>\n<p>时间或者大小</p>\n<p>kafka零拷贝</p>\n<p>kafka分区一致性</p>\n<p>kafka rebalance</p>\n<p>kafka数据可靠性</p>\n<p>配置响应ACKS,0-无需等待落盘，1-需要等待leader落盘，-1/ALL-所有的节点都落盘</p>\n<p>不同的消息语义</p>\n<p>至少一次: ACKS = =1<br>至多一次: ACKS = 0<br>精准一次: </p>\n<h2 id=\"RocketMq\"><a href=\"#RocketMq\" class=\"headerlink\" title=\"RocketMq\"></a>RocketMq</h2><p>严格的顺序性 （kafka非严格）<br>拉模型<br>堆积能力强<br>满足至少消费一次的语义</p>\n<p>支持事务消息 保证最终一致性<br>18个等级的小时延时<br>可以指定次数和时间的重试<br>brocker</p>\n<h2 id=\"RabbitMq\"><a href=\"#RabbitMq\" class=\"headerlink\" title=\"RabbitMq\"></a>RabbitMq</h2><p>推模型</p>\n"},{"title":"设计模式-建造者模式","_content":"\n### 抽象工厂方法模式\n\n>   当抽象工厂比较复杂时使用。(相当于一个流程)\n\n![建造者模式](http://image.tupelo.top/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png)\n\n","source":"_posts/建造者模式.md","raw":"---\ntitle: 设计模式-建造者模式\ntags:\n  - 设计模式\n---\n\n### 抽象工厂方法模式\n\n>   当抽象工厂比较复杂时使用。(相当于一个流程)\n\n![建造者模式](http://image.tupelo.top/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png)\n\n","slug":"建造者模式","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bn00399gj7oyh1m68w","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"抽象工厂方法模式\"><a href=\"#抽象工厂方法模式\" class=\"headerlink\" title=\"抽象工厂方法模式\"></a>抽象工厂方法模式</h3><blockquote>\n<p>  当抽象工厂比较复杂时使用。(相当于一个流程)</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png\" alt=\"建造者模式\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"抽象工厂方法模式\"><a href=\"#抽象工厂方法模式\" class=\"headerlink\" title=\"抽象工厂方法模式\"></a>抽象工厂方法模式</h3><blockquote>\n<p>  当抽象工厂比较复杂时使用。(相当于一个流程)</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png\" alt=\"建造者模式\"></p>\n"},{"title":"总结-多线程","_content":"\n\n\n### 线程池\n\n创建线程的方式，继承Thread类，实现Runable接口，但是Java是单继承多实现，所有推荐使用Runable的方式。\n\n线程的状态\n\n- 新建状态，new 一个线程的时候就是新建状态。\n- 就绪状态，调用start方法之后，等待CPU调度。\n- 运行状态，线程获取得了CPU，开始执行run方法.\n- 阻塞状态，执行wait/sleep、等待锁 等方法。\n- 死亡 run执行完成之后或者执行了stop方法。调用stop方法不会释放锁，可能会造成死锁。\n\n---\n\nseelp和wait的区别  \n\nseelp是Thrad类中的一个方法，执行时不会释放锁，到了指定的时候继续执行，wait是Object中的方法，会释放锁，进入等待，需要notify/notigyall唤醒后才能继续执行。\n\n---\n\n为什么使用线程池\n\n降低频繁创建线程的消耗，方便管理线程。\n\n线程池的关键参数：\n\n- 核心线程数\n- 最大线程数\n- 等待队列\n- 线程存活时间\n- 拒绝策略\n\n线程的执行流程：\n\n1. 提交一个任务判断线程池中的线程数量是否大于核心线程数，没有的话就创建一个线程执行\n2. 大于等于最大核心线程数，则加入到等待队列中等待执行\n3. 如果队列中已经满了，还有任务来，则继续创建线程只到达到最大线程数\n4. 达到最大线程数之后的任务则按照拒绝策略执行\n5. 任务执行完成后如果当前的线程数量大于核心线程数，则超过存活时间则会销毁掉多余的线程\n\n---\n\n为什么不推荐Executors创建线程池\n\n- fix和single的使用的是无界队列\n- scheduleh和delay最大线程数是intmax\n\n两种情况都会导致创建大量的线程，可能会OOM\n\n---\n\n线程池合理配置\n\n1. CPU密集型，主要是计算，压力在CPU,分配小的线程数，NCPU+1\n2. IO密集型，压力不在CPU,可多分配线程，2 * NCPU\n\n---\n\n如何停止一个线程的方法\n\n使用interrupt方法打上中断的标志，然后自己决定是否需要停止线程。\n\n---\n\n如何保证线程安全\n\n- 栈封闭\n- 无状态的类 没有任何成员变量的类\n- 没有返回值\n\n\n### Synchronized\n\n\n\n#### 锁的对象\n\n- 使用在方法上 或者锁的对象是this，则锁的对象是调用方\n- 使用在静态方法，则锁的对象是当前类\n- 指定具体的对象，则锁的是指定的对象\n\n#### 实现原理\n\n使用monitorenter和monitorexit指令实现同步，本质是对一个对象的监视器进行获取，同一个时刻只有一个线程可以获取到一个对象的监视器。\n\n\n#### 锁升级过程\n\n- 在Synchronize加锁时，如果偏向锁已经启动的情况，则此时是锁对象是偏向锁状态，否则是无锁状态。\n- 偏向的锁的对象执行hashcode方法的时候会撤销到无锁的状态。原因是对象头中保存了对象的hashcode值。偏向锁对象头中存在的是线程ID\n- 如果有少量线程竞争时，升级为轻量级锁，\n- 大量线程竞争时，升级为重量级锁，对象头中存的是指向montior的指针。\n\n\n#### Synchronized和Lock的区别\n\nLock是java中的一个接口，是java层面的锁，需要手动的释放，可以定制为不同情况的锁，多样化\nSynchronized是属于JVM层面的锁，不能中断，不是公平的，不支持条件唤醒。\n\n\n### TheadLocal\n\n每个线程里面都维护着一个TheadLocalMap\n\nTheadLocalMap里面又维护着一个entry数组，entry对象是ThreadLocal的弱引用，entry里面维护具体的值\n\nTheadLocal.set() 会先回去当前线程的TheadLocalMap，然后保存当前threadLocl为key 值为value到TheadLocalMap里面，获取的时候先获取当前线程的threadlocalMap,然后以当前的threadlocal为key获取值。\n\n\n问题：\n\n1、存在线程池的时候可能会互相影像，每次使用完成之后需要remove()一下\n2、存在内存泄漏问题 TheadLocalMap 的生命周期和线程的生命周期是一样的，所以如果没有手动删除key，就会导致内存泄漏。\n\n\n### volatile\n\n保证线程的可见性和有序性，不能保证原子性。引入了内存屏障，防止重排序。\n\n\n### CAS\n\n比较并交换，操作系统保证原子性。\n\n### AQS\n\n是一个构建锁和同步器的框架。\n\n","source":"_posts/总结-多线程.md","raw":"---\ntitle: 总结-多线程\ntags:\n  - 总结\n---\n\n\n\n### 线程池\n\n创建线程的方式，继承Thread类，实现Runable接口，但是Java是单继承多实现，所有推荐使用Runable的方式。\n\n线程的状态\n\n- 新建状态，new 一个线程的时候就是新建状态。\n- 就绪状态，调用start方法之后，等待CPU调度。\n- 运行状态，线程获取得了CPU，开始执行run方法.\n- 阻塞状态，执行wait/sleep、等待锁 等方法。\n- 死亡 run执行完成之后或者执行了stop方法。调用stop方法不会释放锁，可能会造成死锁。\n\n---\n\nseelp和wait的区别  \n\nseelp是Thrad类中的一个方法，执行时不会释放锁，到了指定的时候继续执行，wait是Object中的方法，会释放锁，进入等待，需要notify/notigyall唤醒后才能继续执行。\n\n---\n\n为什么使用线程池\n\n降低频繁创建线程的消耗，方便管理线程。\n\n线程池的关键参数：\n\n- 核心线程数\n- 最大线程数\n- 等待队列\n- 线程存活时间\n- 拒绝策略\n\n线程的执行流程：\n\n1. 提交一个任务判断线程池中的线程数量是否大于核心线程数，没有的话就创建一个线程执行\n2. 大于等于最大核心线程数，则加入到等待队列中等待执行\n3. 如果队列中已经满了，还有任务来，则继续创建线程只到达到最大线程数\n4. 达到最大线程数之后的任务则按照拒绝策略执行\n5. 任务执行完成后如果当前的线程数量大于核心线程数，则超过存活时间则会销毁掉多余的线程\n\n---\n\n为什么不推荐Executors创建线程池\n\n- fix和single的使用的是无界队列\n- scheduleh和delay最大线程数是intmax\n\n两种情况都会导致创建大量的线程，可能会OOM\n\n---\n\n线程池合理配置\n\n1. CPU密集型，主要是计算，压力在CPU,分配小的线程数，NCPU+1\n2. IO密集型，压力不在CPU,可多分配线程，2 * NCPU\n\n---\n\n如何停止一个线程的方法\n\n使用interrupt方法打上中断的标志，然后自己决定是否需要停止线程。\n\n---\n\n如何保证线程安全\n\n- 栈封闭\n- 无状态的类 没有任何成员变量的类\n- 没有返回值\n\n\n### Synchronized\n\n\n\n#### 锁的对象\n\n- 使用在方法上 或者锁的对象是this，则锁的对象是调用方\n- 使用在静态方法，则锁的对象是当前类\n- 指定具体的对象，则锁的是指定的对象\n\n#### 实现原理\n\n使用monitorenter和monitorexit指令实现同步，本质是对一个对象的监视器进行获取，同一个时刻只有一个线程可以获取到一个对象的监视器。\n\n\n#### 锁升级过程\n\n- 在Synchronize加锁时，如果偏向锁已经启动的情况，则此时是锁对象是偏向锁状态，否则是无锁状态。\n- 偏向的锁的对象执行hashcode方法的时候会撤销到无锁的状态。原因是对象头中保存了对象的hashcode值。偏向锁对象头中存在的是线程ID\n- 如果有少量线程竞争时，升级为轻量级锁，\n- 大量线程竞争时，升级为重量级锁，对象头中存的是指向montior的指针。\n\n\n#### Synchronized和Lock的区别\n\nLock是java中的一个接口，是java层面的锁，需要手动的释放，可以定制为不同情况的锁，多样化\nSynchronized是属于JVM层面的锁，不能中断，不是公平的，不支持条件唤醒。\n\n\n### TheadLocal\n\n每个线程里面都维护着一个TheadLocalMap\n\nTheadLocalMap里面又维护着一个entry数组，entry对象是ThreadLocal的弱引用，entry里面维护具体的值\n\nTheadLocal.set() 会先回去当前线程的TheadLocalMap，然后保存当前threadLocl为key 值为value到TheadLocalMap里面，获取的时候先获取当前线程的threadlocalMap,然后以当前的threadlocal为key获取值。\n\n\n问题：\n\n1、存在线程池的时候可能会互相影像，每次使用完成之后需要remove()一下\n2、存在内存泄漏问题 TheadLocalMap 的生命周期和线程的生命周期是一样的，所以如果没有手动删除key，就会导致内存泄漏。\n\n\n### volatile\n\n保证线程的可见性和有序性，不能保证原子性。引入了内存屏障，防止重排序。\n\n\n### CAS\n\n比较并交换，操作系统保证原子性。\n\n### AQS\n\n是一个构建锁和同步器的框架。\n\n","slug":"总结-多线程","published":1,"date":"2025-02-12T08:28:16.472Z","updated":"2025-02-12T08:28:16.472Z","_id":"clhua15bo003b9gj7blfsakdl","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>创建线程的方式，继承Thread类，实现Runable接口，但是Java是单继承多实现，所有推荐使用Runable的方式。</p>\n<p>线程的状态</p>\n<ul>\n<li>新建状态，new 一个线程的时候就是新建状态。</li>\n<li>就绪状态，调用start方法之后，等待CPU调度。</li>\n<li>运行状态，线程获取得了CPU，开始执行run方法.</li>\n<li>阻塞状态，执行wait/sleep、等待锁 等方法。</li>\n<li>死亡 run执行完成之后或者执行了stop方法。调用stop方法不会释放锁，可能会造成死锁。</li>\n</ul>\n<hr>\n<p>seelp和wait的区别  </p>\n<p>seelp是Thrad类中的一个方法，执行时不会释放锁，到了指定的时候继续执行，wait是Object中的方法，会释放锁，进入等待，需要notify/notigyall唤醒后才能继续执行。</p>\n<hr>\n<p>为什么使用线程池</p>\n<p>降低频繁创建线程的消耗，方便管理线程。</p>\n<p>线程池的关键参数：</p>\n<ul>\n<li>核心线程数</li>\n<li>最大线程数</li>\n<li>等待队列</li>\n<li>线程存活时间</li>\n<li>拒绝策略</li>\n</ul>\n<p>线程的执行流程：</p>\n<ol>\n<li>提交一个任务判断线程池中的线程数量是否大于核心线程数，没有的话就创建一个线程执行</li>\n<li>大于等于最大核心线程数，则加入到等待队列中等待执行</li>\n<li>如果队列中已经满了，还有任务来，则继续创建线程只到达到最大线程数</li>\n<li>达到最大线程数之后的任务则按照拒绝策略执行</li>\n<li>任务执行完成后如果当前的线程数量大于核心线程数，则超过存活时间则会销毁掉多余的线程</li>\n</ol>\n<hr>\n<p>为什么不推荐Executors创建线程池</p>\n<ul>\n<li>fix和single的使用的是无界队列</li>\n<li>scheduleh和delay最大线程数是intmax</li>\n</ul>\n<p>两种情况都会导致创建大量的线程，可能会OOM</p>\n<hr>\n<p>线程池合理配置</p>\n<ol>\n<li>CPU密集型，主要是计算，压力在CPU,分配小的线程数，NCPU+1</li>\n<li>IO密集型，压力不在CPU,可多分配线程，2 * NCPU</li>\n</ol>\n<hr>\n<p>如何停止一个线程的方法</p>\n<p>使用interrupt方法打上中断的标志，然后自己决定是否需要停止线程。</p>\n<hr>\n<p>如何保证线程安全</p>\n<ul>\n<li>栈封闭</li>\n<li>无状态的类 没有任何成员变量的类</li>\n<li>没有返回值</li>\n</ul>\n<h3 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h3><h4 id=\"锁的对象\"><a href=\"#锁的对象\" class=\"headerlink\" title=\"锁的对象\"></a>锁的对象</h4><ul>\n<li>使用在方法上 或者锁的对象是this，则锁的对象是调用方</li>\n<li>使用在静态方法，则锁的对象是当前类</li>\n<li>指定具体的对象，则锁的是指定的对象</li>\n</ul>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>使用monitorenter和monitorexit指令实现同步，本质是对一个对象的监视器进行获取，同一个时刻只有一个线程可以获取到一个对象的监视器。</p>\n<h4 id=\"锁升级过程\"><a href=\"#锁升级过程\" class=\"headerlink\" title=\"锁升级过程\"></a>锁升级过程</h4><ul>\n<li>在Synchronize加锁时，如果偏向锁已经启动的情况，则此时是锁对象是偏向锁状态，否则是无锁状态。</li>\n<li>偏向的锁的对象执行hashcode方法的时候会撤销到无锁的状态。原因是对象头中保存了对象的hashcode值。偏向锁对象头中存在的是线程ID</li>\n<li>如果有少量线程竞争时，升级为轻量级锁，</li>\n<li>大量线程竞争时，升级为重量级锁，对象头中存的是指向montior的指针。</li>\n</ul>\n<h4 id=\"Synchronized和Lock的区别\"><a href=\"#Synchronized和Lock的区别\" class=\"headerlink\" title=\"Synchronized和Lock的区别\"></a>Synchronized和Lock的区别</h4><p>Lock是java中的一个接口，是java层面的锁，需要手动的释放，可以定制为不同情况的锁，多样化<br>Synchronized是属于JVM层面的锁，不能中断，不是公平的，不支持条件唤醒。</p>\n<h3 id=\"TheadLocal\"><a href=\"#TheadLocal\" class=\"headerlink\" title=\"TheadLocal\"></a>TheadLocal</h3><p>每个线程里面都维护着一个TheadLocalMap</p>\n<p>TheadLocalMap里面又维护着一个entry数组，entry对象是ThreadLocal的弱引用，entry里面维护具体的值</p>\n<p>TheadLocal.set() 会先回去当前线程的TheadLocalMap，然后保存当前threadLocl为key 值为value到TheadLocalMap里面，获取的时候先获取当前线程的threadlocalMap,然后以当前的threadlocal为key获取值。</p>\n<p>问题：</p>\n<p>1、存在线程池的时候可能会互相影像，每次使用完成之后需要remove()一下<br>2、存在内存泄漏问题 TheadLocalMap 的生命周期和线程的生命周期是一样的，所以如果没有手动删除key，就会导致内存泄漏。</p>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>保证线程的可见性和有序性，不能保证原子性。引入了内存屏障，防止重排序。</p>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>比较并交换，操作系统保证原子性。</p>\n<h3 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h3><p>是一个构建锁和同步器的框架。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>创建线程的方式，继承Thread类，实现Runable接口，但是Java是单继承多实现，所有推荐使用Runable的方式。</p>\n<p>线程的状态</p>\n<ul>\n<li>新建状态，new 一个线程的时候就是新建状态。</li>\n<li>就绪状态，调用start方法之后，等待CPU调度。</li>\n<li>运行状态，线程获取得了CPU，开始执行run方法.</li>\n<li>阻塞状态，执行wait/sleep、等待锁 等方法。</li>\n<li>死亡 run执行完成之后或者执行了stop方法。调用stop方法不会释放锁，可能会造成死锁。</li>\n</ul>\n<hr>\n<p>seelp和wait的区别  </p>\n<p>seelp是Thrad类中的一个方法，执行时不会释放锁，到了指定的时候继续执行，wait是Object中的方法，会释放锁，进入等待，需要notify/notigyall唤醒后才能继续执行。</p>\n<hr>\n<p>为什么使用线程池</p>\n<p>降低频繁创建线程的消耗，方便管理线程。</p>\n<p>线程池的关键参数：</p>\n<ul>\n<li>核心线程数</li>\n<li>最大线程数</li>\n<li>等待队列</li>\n<li>线程存活时间</li>\n<li>拒绝策略</li>\n</ul>\n<p>线程的执行流程：</p>\n<ol>\n<li>提交一个任务判断线程池中的线程数量是否大于核心线程数，没有的话就创建一个线程执行</li>\n<li>大于等于最大核心线程数，则加入到等待队列中等待执行</li>\n<li>如果队列中已经满了，还有任务来，则继续创建线程只到达到最大线程数</li>\n<li>达到最大线程数之后的任务则按照拒绝策略执行</li>\n<li>任务执行完成后如果当前的线程数量大于核心线程数，则超过存活时间则会销毁掉多余的线程</li>\n</ol>\n<hr>\n<p>为什么不推荐Executors创建线程池</p>\n<ul>\n<li>fix和single的使用的是无界队列</li>\n<li>scheduleh和delay最大线程数是intmax</li>\n</ul>\n<p>两种情况都会导致创建大量的线程，可能会OOM</p>\n<hr>\n<p>线程池合理配置</p>\n<ol>\n<li>CPU密集型，主要是计算，压力在CPU,分配小的线程数，NCPU+1</li>\n<li>IO密集型，压力不在CPU,可多分配线程，2 * NCPU</li>\n</ol>\n<hr>\n<p>如何停止一个线程的方法</p>\n<p>使用interrupt方法打上中断的标志，然后自己决定是否需要停止线程。</p>\n<hr>\n<p>如何保证线程安全</p>\n<ul>\n<li>栈封闭</li>\n<li>无状态的类 没有任何成员变量的类</li>\n<li>没有返回值</li>\n</ul>\n<h3 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h3><h4 id=\"锁的对象\"><a href=\"#锁的对象\" class=\"headerlink\" title=\"锁的对象\"></a>锁的对象</h4><ul>\n<li>使用在方法上 或者锁的对象是this，则锁的对象是调用方</li>\n<li>使用在静态方法，则锁的对象是当前类</li>\n<li>指定具体的对象，则锁的是指定的对象</li>\n</ul>\n<h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><p>使用monitorenter和monitorexit指令实现同步，本质是对一个对象的监视器进行获取，同一个时刻只有一个线程可以获取到一个对象的监视器。</p>\n<h4 id=\"锁升级过程\"><a href=\"#锁升级过程\" class=\"headerlink\" title=\"锁升级过程\"></a>锁升级过程</h4><ul>\n<li>在Synchronize加锁时，如果偏向锁已经启动的情况，则此时是锁对象是偏向锁状态，否则是无锁状态。</li>\n<li>偏向的锁的对象执行hashcode方法的时候会撤销到无锁的状态。原因是对象头中保存了对象的hashcode值。偏向锁对象头中存在的是线程ID</li>\n<li>如果有少量线程竞争时，升级为轻量级锁，</li>\n<li>大量线程竞争时，升级为重量级锁，对象头中存的是指向montior的指针。</li>\n</ul>\n<h4 id=\"Synchronized和Lock的区别\"><a href=\"#Synchronized和Lock的区别\" class=\"headerlink\" title=\"Synchronized和Lock的区别\"></a>Synchronized和Lock的区别</h4><p>Lock是java中的一个接口，是java层面的锁，需要手动的释放，可以定制为不同情况的锁，多样化<br>Synchronized是属于JVM层面的锁，不能中断，不是公平的，不支持条件唤醒。</p>\n<h3 id=\"TheadLocal\"><a href=\"#TheadLocal\" class=\"headerlink\" title=\"TheadLocal\"></a>TheadLocal</h3><p>每个线程里面都维护着一个TheadLocalMap</p>\n<p>TheadLocalMap里面又维护着一个entry数组，entry对象是ThreadLocal的弱引用，entry里面维护具体的值</p>\n<p>TheadLocal.set() 会先回去当前线程的TheadLocalMap，然后保存当前threadLocl为key 值为value到TheadLocalMap里面，获取的时候先获取当前线程的threadlocalMap,然后以当前的threadlocal为key获取值。</p>\n<p>问题：</p>\n<p>1、存在线程池的时候可能会互相影像，每次使用完成之后需要remove()一下<br>2、存在内存泄漏问题 TheadLocalMap 的生命周期和线程的生命周期是一样的，所以如果没有手动删除key，就会导致内存泄漏。</p>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>保证线程的可见性和有序性，不能保证原子性。引入了内存屏障，防止重排序。</p>\n<h3 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h3><p>比较并交换，操作系统保证原子性。</p>\n<h3 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h3><p>是一个构建锁和同步器的框架。</p>\n"},{"title":"总结-mysql","_content":"\n聚集索引/非聚集索引\n\n\n\n### 三大范式\n\n1. 所有的列不可分\n2. 每一列都和主键相关\n3. 每一列都和主键直接相关，不能间接相关\n\n实际使用中为了提高查下效率，有时候也会适当的冗余一些数据，空间换时间。\n\n\n### 存储引擎 MyISAM和InnoDB的区别\n\n查下mysql的所有引擎  ``` show ENGINES  ``` innodb是mysql5.6之后的默认引擎，MyISAM是5.6之前的默认引擎。\n\n区别：\n\n1. MyISAM不支持事务，不支持行级锁，不支持外键，会保存行数，查询快，但是增删慢，适合大量查询的场景。\n2. InnoDB支持事务，支持行级锁，适合执行大量insert和update的表。\n\n### SQL优化\n\nSQL优化主要就是索引优化，尽量是sql使用到索引\n\n- 添加索引\n- 联合索引的时候，使用最左前缀法则，不是指sql的顺序，而是sql中需要有索引中顺序的字段。\n- 索引列不要做任何的操作\n- 尽量使用覆盖索引，能减少回表\n- like将%放在后面\n- 字符串类型不加单引号会导致索引失效\n- or改union\n\n#### 索引失效的场景\n\n\n\n### 聚集索引和非聚集索引\n\n聚集索引一般就是主键索引，如果没有主键，mysql会自己生成一列主键，一个表一定会有一个聚集索引。非聚集索引就是主键之外的索引，也叫辅助索引。\n\n\n### 索引B+树\n\nMyISAM和InnoDB索引都使用的是B+树的结构\n\nB+树：非叶子节点只存储索引信息，叶子节点会冗余非叶子节点的数据，还会存在指向真实数据的指针，并且还会保存相邻的叶子节点之间的双向指针。\nB树：非叶子节点和叶子节点都会都会保存索引的数据和真实数据的指针\n\n为什么使用B+树不使用B树\n\n1. B+树非叶子节点不存数据，跟小，可以容纳更多的数据。\n2. B+树每次查询的路径大致相同跟稳定，B树可能在叶子节点就直接查询到了。\n3. B+树叶子节点间有双向指针，更适合范围查询。\n\n\n\n### 事务特性和隔离级别\n\n#### 事务特性\n\n- A 原子性\n- C 一致性 保证数据的完整性\n- I 隔离性\n- D 持久性\n\n#### 事务隔离级别\n\n事务会带来的问题：\n\n1. 脏读: 一个事务中会读取到其它事务之间的数据。\n2. 不可重复读： 一个事务多次读取的数据不一致。\n3. 幻读: 一个事务中查询莫一类数据的时候结果不一致，如其它线程插入了新的数据。\n\n- 读未提交，存在脏读的问题\n- 读已提交，其它事务中没有提交的数据无法读取，解决了脏读的问题。\n- 可重复读，一次事务中查询的同一个数据不会改变，解决了不可重复读。mysql中默认的隔离级别。\n- 串行化，事务之间串行处理，级别最高，并发最差。\n\n### MVCC\n\n事务读已提交和可重复读是基于MVCC实现的，\n\n\n### 数据库锁\n\n\n### 数据库日志\n\nredoLog: 保证数据的持久性，主要作用是用于数据库的崩溃恢复，存在单独的日志文件。\nundoLog: 记录数据的逻辑变化，用作事务回滚，存在于表空间的数据文件中。\n\n\n","source":"_posts/总结题-mysql.md","raw":"---\ntitle: 总结-mysql\ntags:\n  - 总结\n---\n\n聚集索引/非聚集索引\n\n\n\n### 三大范式\n\n1. 所有的列不可分\n2. 每一列都和主键相关\n3. 每一列都和主键直接相关，不能间接相关\n\n实际使用中为了提高查下效率，有时候也会适当的冗余一些数据，空间换时间。\n\n\n### 存储引擎 MyISAM和InnoDB的区别\n\n查下mysql的所有引擎  ``` show ENGINES  ``` innodb是mysql5.6之后的默认引擎，MyISAM是5.6之前的默认引擎。\n\n区别：\n\n1. MyISAM不支持事务，不支持行级锁，不支持外键，会保存行数，查询快，但是增删慢，适合大量查询的场景。\n2. InnoDB支持事务，支持行级锁，适合执行大量insert和update的表。\n\n### SQL优化\n\nSQL优化主要就是索引优化，尽量是sql使用到索引\n\n- 添加索引\n- 联合索引的时候，使用最左前缀法则，不是指sql的顺序，而是sql中需要有索引中顺序的字段。\n- 索引列不要做任何的操作\n- 尽量使用覆盖索引，能减少回表\n- like将%放在后面\n- 字符串类型不加单引号会导致索引失效\n- or改union\n\n#### 索引失效的场景\n\n\n\n### 聚集索引和非聚集索引\n\n聚集索引一般就是主键索引，如果没有主键，mysql会自己生成一列主键，一个表一定会有一个聚集索引。非聚集索引就是主键之外的索引，也叫辅助索引。\n\n\n### 索引B+树\n\nMyISAM和InnoDB索引都使用的是B+树的结构\n\nB+树：非叶子节点只存储索引信息，叶子节点会冗余非叶子节点的数据，还会存在指向真实数据的指针，并且还会保存相邻的叶子节点之间的双向指针。\nB树：非叶子节点和叶子节点都会都会保存索引的数据和真实数据的指针\n\n为什么使用B+树不使用B树\n\n1. B+树非叶子节点不存数据，跟小，可以容纳更多的数据。\n2. B+树每次查询的路径大致相同跟稳定，B树可能在叶子节点就直接查询到了。\n3. B+树叶子节点间有双向指针，更适合范围查询。\n\n\n\n### 事务特性和隔离级别\n\n#### 事务特性\n\n- A 原子性\n- C 一致性 保证数据的完整性\n- I 隔离性\n- D 持久性\n\n#### 事务隔离级别\n\n事务会带来的问题：\n\n1. 脏读: 一个事务中会读取到其它事务之间的数据。\n2. 不可重复读： 一个事务多次读取的数据不一致。\n3. 幻读: 一个事务中查询莫一类数据的时候结果不一致，如其它线程插入了新的数据。\n\n- 读未提交，存在脏读的问题\n- 读已提交，其它事务中没有提交的数据无法读取，解决了脏读的问题。\n- 可重复读，一次事务中查询的同一个数据不会改变，解决了不可重复读。mysql中默认的隔离级别。\n- 串行化，事务之间串行处理，级别最高，并发最差。\n\n### MVCC\n\n事务读已提交和可重复读是基于MVCC实现的，\n\n\n### 数据库锁\n\n\n### 数据库日志\n\nredoLog: 保证数据的持久性，主要作用是用于数据库的崩溃恢复，存在单独的日志文件。\nundoLog: 记录数据的逻辑变化，用作事务回滚，存在于表空间的数据文件中。\n\n\n","slug":"总结题-mysql","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bp003d9gj7sufkpta4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>聚集索引/非聚集索引</p>\n<h3 id=\"三大范式\"><a href=\"#三大范式\" class=\"headerlink\" title=\"三大范式\"></a>三大范式</h3><ol>\n<li>所有的列不可分</li>\n<li>每一列都和主键相关</li>\n<li>每一列都和主键直接相关，不能间接相关</li>\n</ol>\n<p>实际使用中为了提高查下效率，有时候也会适当的冗余一些数据，空间换时间。</p>\n<h3 id=\"存储引擎-MyISAM和InnoDB的区别\"><a href=\"#存储引擎-MyISAM和InnoDB的区别\" class=\"headerlink\" title=\"存储引擎 MyISAM和InnoDB的区别\"></a>存储引擎 MyISAM和InnoDB的区别</h3><p>查下mysql的所有引擎  <code>show ENGINES</code> innodb是mysql5.6之后的默认引擎，MyISAM是5.6之前的默认引擎。</p>\n<p>区别：</p>\n<ol>\n<li>MyISAM不支持事务，不支持行级锁，不支持外键，会保存行数，查询快，但是增删慢，适合大量查询的场景。</li>\n<li>InnoDB支持事务，支持行级锁，适合执行大量insert和update的表。</li>\n</ol>\n<h3 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h3><p>SQL优化主要就是索引优化，尽量是sql使用到索引</p>\n<ul>\n<li>添加索引</li>\n<li>联合索引的时候，使用最左前缀法则，不是指sql的顺序，而是sql中需要有索引中顺序的字段。</li>\n<li>索引列不要做任何的操作</li>\n<li>尽量使用覆盖索引，能减少回表</li>\n<li>like将%放在后面</li>\n<li>字符串类型不加单引号会导致索引失效</li>\n<li>or改union</li>\n</ul>\n<h4 id=\"索引失效的场景\"><a href=\"#索引失效的场景\" class=\"headerlink\" title=\"索引失效的场景\"></a>索引失效的场景</h4><h3 id=\"聚集索引和非聚集索引\"><a href=\"#聚集索引和非聚集索引\" class=\"headerlink\" title=\"聚集索引和非聚集索引\"></a>聚集索引和非聚集索引</h3><p>聚集索引一般就是主键索引，如果没有主键，mysql会自己生成一列主键，一个表一定会有一个聚集索引。非聚集索引就是主键之外的索引，也叫辅助索引。</p>\n<h3 id=\"索引B-树\"><a href=\"#索引B-树\" class=\"headerlink\" title=\"索引B+树\"></a>索引B+树</h3><p>MyISAM和InnoDB索引都使用的是B+树的结构</p>\n<p>B+树：非叶子节点只存储索引信息，叶子节点会冗余非叶子节点的数据，还会存在指向真实数据的指针，并且还会保存相邻的叶子节点之间的双向指针。<br>B树：非叶子节点和叶子节点都会都会保存索引的数据和真实数据的指针</p>\n<p>为什么使用B+树不使用B树</p>\n<ol>\n<li>B+树非叶子节点不存数据，跟小，可以容纳更多的数据。</li>\n<li>B+树每次查询的路径大致相同跟稳定，B树可能在叶子节点就直接查询到了。</li>\n<li>B+树叶子节点间有双向指针，更适合范围查询。</li>\n</ol>\n<h3 id=\"事务特性和隔离级别\"><a href=\"#事务特性和隔离级别\" class=\"headerlink\" title=\"事务特性和隔离级别\"></a>事务特性和隔离级别</h3><h4 id=\"事务特性\"><a href=\"#事务特性\" class=\"headerlink\" title=\"事务特性\"></a>事务特性</h4><ul>\n<li>A 原子性</li>\n<li>C 一致性 保证数据的完整性</li>\n<li>I 隔离性</li>\n<li>D 持久性</li>\n</ul>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><p>事务会带来的问题：</p>\n<ol>\n<li>脏读: 一个事务中会读取到其它事务之间的数据。</li>\n<li>不可重复读： 一个事务多次读取的数据不一致。</li>\n<li>幻读: 一个事务中查询莫一类数据的时候结果不一致，如其它线程插入了新的数据。</li>\n</ol>\n<ul>\n<li>读未提交，存在脏读的问题</li>\n<li>读已提交，其它事务中没有提交的数据无法读取，解决了脏读的问题。</li>\n<li>可重复读，一次事务中查询的同一个数据不会改变，解决了不可重复读。mysql中默认的隔离级别。</li>\n<li>串行化，事务之间串行处理，级别最高，并发最差。</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><p>事务读已提交和可重复读是基于MVCC实现的，</p>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><h3 id=\"数据库日志\"><a href=\"#数据库日志\" class=\"headerlink\" title=\"数据库日志\"></a>数据库日志</h3><p>redoLog: 保证数据的持久性，主要作用是用于数据库的崩溃恢复，存在单独的日志文件。<br>undoLog: 记录数据的逻辑变化，用作事务回滚，存在于表空间的数据文件中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>聚集索引/非聚集索引</p>\n<h3 id=\"三大范式\"><a href=\"#三大范式\" class=\"headerlink\" title=\"三大范式\"></a>三大范式</h3><ol>\n<li>所有的列不可分</li>\n<li>每一列都和主键相关</li>\n<li>每一列都和主键直接相关，不能间接相关</li>\n</ol>\n<p>实际使用中为了提高查下效率，有时候也会适当的冗余一些数据，空间换时间。</p>\n<h3 id=\"存储引擎-MyISAM和InnoDB的区别\"><a href=\"#存储引擎-MyISAM和InnoDB的区别\" class=\"headerlink\" title=\"存储引擎 MyISAM和InnoDB的区别\"></a>存储引擎 MyISAM和InnoDB的区别</h3><p>查下mysql的所有引擎  <code>show ENGINES</code> innodb是mysql5.6之后的默认引擎，MyISAM是5.6之前的默认引擎。</p>\n<p>区别：</p>\n<ol>\n<li>MyISAM不支持事务，不支持行级锁，不支持外键，会保存行数，查询快，但是增删慢，适合大量查询的场景。</li>\n<li>InnoDB支持事务，支持行级锁，适合执行大量insert和update的表。</li>\n</ol>\n<h3 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h3><p>SQL优化主要就是索引优化，尽量是sql使用到索引</p>\n<ul>\n<li>添加索引</li>\n<li>联合索引的时候，使用最左前缀法则，不是指sql的顺序，而是sql中需要有索引中顺序的字段。</li>\n<li>索引列不要做任何的操作</li>\n<li>尽量使用覆盖索引，能减少回表</li>\n<li>like将%放在后面</li>\n<li>字符串类型不加单引号会导致索引失效</li>\n<li>or改union</li>\n</ul>\n<h4 id=\"索引失效的场景\"><a href=\"#索引失效的场景\" class=\"headerlink\" title=\"索引失效的场景\"></a>索引失效的场景</h4><h3 id=\"聚集索引和非聚集索引\"><a href=\"#聚集索引和非聚集索引\" class=\"headerlink\" title=\"聚集索引和非聚集索引\"></a>聚集索引和非聚集索引</h3><p>聚集索引一般就是主键索引，如果没有主键，mysql会自己生成一列主键，一个表一定会有一个聚集索引。非聚集索引就是主键之外的索引，也叫辅助索引。</p>\n<h3 id=\"索引B-树\"><a href=\"#索引B-树\" class=\"headerlink\" title=\"索引B+树\"></a>索引B+树</h3><p>MyISAM和InnoDB索引都使用的是B+树的结构</p>\n<p>B+树：非叶子节点只存储索引信息，叶子节点会冗余非叶子节点的数据，还会存在指向真实数据的指针，并且还会保存相邻的叶子节点之间的双向指针。<br>B树：非叶子节点和叶子节点都会都会保存索引的数据和真实数据的指针</p>\n<p>为什么使用B+树不使用B树</p>\n<ol>\n<li>B+树非叶子节点不存数据，跟小，可以容纳更多的数据。</li>\n<li>B+树每次查询的路径大致相同跟稳定，B树可能在叶子节点就直接查询到了。</li>\n<li>B+树叶子节点间有双向指针，更适合范围查询。</li>\n</ol>\n<h3 id=\"事务特性和隔离级别\"><a href=\"#事务特性和隔离级别\" class=\"headerlink\" title=\"事务特性和隔离级别\"></a>事务特性和隔离级别</h3><h4 id=\"事务特性\"><a href=\"#事务特性\" class=\"headerlink\" title=\"事务特性\"></a>事务特性</h4><ul>\n<li>A 原子性</li>\n<li>C 一致性 保证数据的完整性</li>\n<li>I 隔离性</li>\n<li>D 持久性</li>\n</ul>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><p>事务会带来的问题：</p>\n<ol>\n<li>脏读: 一个事务中会读取到其它事务之间的数据。</li>\n<li>不可重复读： 一个事务多次读取的数据不一致。</li>\n<li>幻读: 一个事务中查询莫一类数据的时候结果不一致，如其它线程插入了新的数据。</li>\n</ol>\n<ul>\n<li>读未提交，存在脏读的问题</li>\n<li>读已提交，其它事务中没有提交的数据无法读取，解决了脏读的问题。</li>\n<li>可重复读，一次事务中查询的同一个数据不会改变，解决了不可重复读。mysql中默认的隔离级别。</li>\n<li>串行化，事务之间串行处理，级别最高，并发最差。</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><p>事务读已提交和可重复读是基于MVCC实现的，</p>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><h3 id=\"数据库日志\"><a href=\"#数据库日志\" class=\"headerlink\" title=\"数据库日志\"></a>数据库日志</h3><p>redoLog: 保证数据的持久性，主要作用是用于数据库的崩溃恢复，存在单独的日志文件。<br>undoLog: 记录数据的逻辑变化，用作事务回滚，存在于表空间的数据文件中。</p>\n"},{"title":"总结-分布式","_content":"\n\n\n### CAP\n\n\n- 一致性: 数据要保持完整\n- 可用性: 服务可用\n- 分区容错性： 在部分网络出现故障的时候仍可以提供一致性和可用性的服务\n\n### BASE理论\n\nBASE理论是为了对cap的一种权衡\n\n- 基本可用： 不要求全部可用，只保证基本的功能可用\n- 软状态： 允许存在中间状态\n- 最终一致性： 可以接收数据短时间的不一致，只需要保证数据的最终一致\n\n\n### 分布式锁\n\n- 数据库 使用数据库 乐观锁/悲观锁控制 需要注意效率问题\n- redis 自己实现比较复杂，可用线程的框架redission\n- zookeeper \n\n\n### 生成唯一主键ID\n\n- 数据库自增ID\n- UUID\n- 雪花算法\n\n\n### 分布式事务\n\n- 2PC \n\n引入事务协调者，第一阶段执行事务记录日志，第二阶段协调者发起commit或者rollback    \n可能存在的问题：\n\n1. 所有的节点都会阻塞。\n2. 如果第二阶段出现问题，数据可能会存在不一致的情况。\n3. 协调者宕机的情况可能会导致阻塞。\n\n\n- 3PC\n\n在2PC的基础上添加了超时时间，并且将第一阶段分为了两个部分，询问和执行     \n可能存在的问题：\n\n1. 第三阶段出现问题时还是会导致数据不一致\n\n- TCC\n\nTCC和2PC类似，try阶段预留锁定资源，confirm/cancel阶段提交或者回滚事务。   \n\n优点：\n\n1. 具体业务实现锁定的资源，锁定力度小，但是同时也使得实现比较复杂。\n2. 第二阶段失败会重试，实现最终一致性。\n\n可能存在的问题：\n\n1. 加入了重试的机制，需要保证接口的幂等性。\n2. 空回滚，第一阶段还没有执行的时候就调用了第二阶段的cancel，需要记录第一阶段的状态。\n3. 先执行了第二阶段，后执行第一阶段导致锁住了资源无法释放，需要记录整个事务的状态。\n\n\n\n### 缓存一致性\n\n延时双删： 先删除缓存，再更新数据库，再过一段时间再删除缓存。\n","source":"_posts/总结题-分布式.md","raw":"---\ntitle: 总结-分布式\ntags:\n  - 总结\n---\n\n\n\n### CAP\n\n\n- 一致性: 数据要保持完整\n- 可用性: 服务可用\n- 分区容错性： 在部分网络出现故障的时候仍可以提供一致性和可用性的服务\n\n### BASE理论\n\nBASE理论是为了对cap的一种权衡\n\n- 基本可用： 不要求全部可用，只保证基本的功能可用\n- 软状态： 允许存在中间状态\n- 最终一致性： 可以接收数据短时间的不一致，只需要保证数据的最终一致\n\n\n### 分布式锁\n\n- 数据库 使用数据库 乐观锁/悲观锁控制 需要注意效率问题\n- redis 自己实现比较复杂，可用线程的框架redission\n- zookeeper \n\n\n### 生成唯一主键ID\n\n- 数据库自增ID\n- UUID\n- 雪花算法\n\n\n### 分布式事务\n\n- 2PC \n\n引入事务协调者，第一阶段执行事务记录日志，第二阶段协调者发起commit或者rollback    \n可能存在的问题：\n\n1. 所有的节点都会阻塞。\n2. 如果第二阶段出现问题，数据可能会存在不一致的情况。\n3. 协调者宕机的情况可能会导致阻塞。\n\n\n- 3PC\n\n在2PC的基础上添加了超时时间，并且将第一阶段分为了两个部分，询问和执行     \n可能存在的问题：\n\n1. 第三阶段出现问题时还是会导致数据不一致\n\n- TCC\n\nTCC和2PC类似，try阶段预留锁定资源，confirm/cancel阶段提交或者回滚事务。   \n\n优点：\n\n1. 具体业务实现锁定的资源，锁定力度小，但是同时也使得实现比较复杂。\n2. 第二阶段失败会重试，实现最终一致性。\n\n可能存在的问题：\n\n1. 加入了重试的机制，需要保证接口的幂等性。\n2. 空回滚，第一阶段还没有执行的时候就调用了第二阶段的cancel，需要记录第一阶段的状态。\n3. 先执行了第二阶段，后执行第一阶段导致锁住了资源无法释放，需要记录整个事务的状态。\n\n\n\n### 缓存一致性\n\n延时双删： 先删除缓存，再更新数据库，再过一段时间再删除缓存。\n","slug":"总结题-分布式","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bp003f9gj70pswxkh3","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h3><ul>\n<li>一致性: 数据要保持完整</li>\n<li>可用性: 服务可用</li>\n<li>分区容错性： 在部分网络出现故障的时候仍可以提供一致性和可用性的服务</li>\n</ul>\n<h3 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h3><p>BASE理论是为了对cap的一种权衡</p>\n<ul>\n<li>基本可用： 不要求全部可用，只保证基本的功能可用</li>\n<li>软状态： 允许存在中间状态</li>\n<li>最终一致性： 可以接收数据短时间的不一致，只需要保证数据的最终一致</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li>数据库 使用数据库 乐观锁/悲观锁控制 需要注意效率问题</li>\n<li>redis 自己实现比较复杂，可用线程的框架redission</li>\n<li>zookeeper </li>\n</ul>\n<h3 id=\"生成唯一主键ID\"><a href=\"#生成唯一主键ID\" class=\"headerlink\" title=\"生成唯一主键ID\"></a>生成唯一主键ID</h3><ul>\n<li>数据库自增ID</li>\n<li>UUID</li>\n<li>雪花算法</li>\n</ul>\n<h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3><ul>\n<li>2PC </li>\n</ul>\n<p>引入事务协调者，第一阶段执行事务记录日志，第二阶段协调者发起commit或者rollback<br>可能存在的问题：</p>\n<ol>\n<li>所有的节点都会阻塞。</li>\n<li>如果第二阶段出现问题，数据可能会存在不一致的情况。</li>\n<li>协调者宕机的情况可能会导致阻塞。</li>\n</ol>\n<ul>\n<li>3PC</li>\n</ul>\n<p>在2PC的基础上添加了超时时间，并且将第一阶段分为了两个部分，询问和执行<br>可能存在的问题：</p>\n<ol>\n<li>第三阶段出现问题时还是会导致数据不一致</li>\n</ol>\n<ul>\n<li>TCC</li>\n</ul>\n<p>TCC和2PC类似，try阶段预留锁定资源，confirm/cancel阶段提交或者回滚事务。   </p>\n<p>优点：</p>\n<ol>\n<li>具体业务实现锁定的资源，锁定力度小，但是同时也使得实现比较复杂。</li>\n<li>第二阶段失败会重试，实现最终一致性。</li>\n</ol>\n<p>可能存在的问题：</p>\n<ol>\n<li>加入了重试的机制，需要保证接口的幂等性。</li>\n<li>空回滚，第一阶段还没有执行的时候就调用了第二阶段的cancel，需要记录第一阶段的状态。</li>\n<li>先执行了第二阶段，后执行第一阶段导致锁住了资源无法释放，需要记录整个事务的状态。</li>\n</ol>\n<h3 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h3><p>延时双删： 先删除缓存，再更新数据库，再过一段时间再删除缓存。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h3><ul>\n<li>一致性: 数据要保持完整</li>\n<li>可用性: 服务可用</li>\n<li>分区容错性： 在部分网络出现故障的时候仍可以提供一致性和可用性的服务</li>\n</ul>\n<h3 id=\"BASE理论\"><a href=\"#BASE理论\" class=\"headerlink\" title=\"BASE理论\"></a>BASE理论</h3><p>BASE理论是为了对cap的一种权衡</p>\n<ul>\n<li>基本可用： 不要求全部可用，只保证基本的功能可用</li>\n<li>软状态： 允许存在中间状态</li>\n<li>最终一致性： 可以接收数据短时间的不一致，只需要保证数据的最终一致</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li>数据库 使用数据库 乐观锁/悲观锁控制 需要注意效率问题</li>\n<li>redis 自己实现比较复杂，可用线程的框架redission</li>\n<li>zookeeper </li>\n</ul>\n<h3 id=\"生成唯一主键ID\"><a href=\"#生成唯一主键ID\" class=\"headerlink\" title=\"生成唯一主键ID\"></a>生成唯一主键ID</h3><ul>\n<li>数据库自增ID</li>\n<li>UUID</li>\n<li>雪花算法</li>\n</ul>\n<h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3><ul>\n<li>2PC </li>\n</ul>\n<p>引入事务协调者，第一阶段执行事务记录日志，第二阶段协调者发起commit或者rollback<br>可能存在的问题：</p>\n<ol>\n<li>所有的节点都会阻塞。</li>\n<li>如果第二阶段出现问题，数据可能会存在不一致的情况。</li>\n<li>协调者宕机的情况可能会导致阻塞。</li>\n</ol>\n<ul>\n<li>3PC</li>\n</ul>\n<p>在2PC的基础上添加了超时时间，并且将第一阶段分为了两个部分，询问和执行<br>可能存在的问题：</p>\n<ol>\n<li>第三阶段出现问题时还是会导致数据不一致</li>\n</ol>\n<ul>\n<li>TCC</li>\n</ul>\n<p>TCC和2PC类似，try阶段预留锁定资源，confirm/cancel阶段提交或者回滚事务。   </p>\n<p>优点：</p>\n<ol>\n<li>具体业务实现锁定的资源，锁定力度小，但是同时也使得实现比较复杂。</li>\n<li>第二阶段失败会重试，实现最终一致性。</li>\n</ol>\n<p>可能存在的问题：</p>\n<ol>\n<li>加入了重试的机制，需要保证接口的幂等性。</li>\n<li>空回滚，第一阶段还没有执行的时候就调用了第二阶段的cancel，需要记录第一阶段的状态。</li>\n<li>先执行了第二阶段，后执行第一阶段导致锁住了资源无法释放，需要记录整个事务的状态。</li>\n</ol>\n<h3 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h3><p>延时双删： 先删除缓存，再更新数据库，再过一段时间再删除缓存。</p>\n"},{"_content":"什么是线程和进程?\n\n程序一个执行过程就是进程，一个进程多个线程，线程是cpu的最小执行单位\n\n为什么要使⽤多线程呢?\n\n提高CPU的利用率 提高效率\n\n使⽤多线程可能带来什么问题?\n\n死锁问题、cpu线程切换消耗问题、内存泄漏问题\n\n说说线程的⽣命周期和状态?\n\n新建状态、就绪状态、运行状态、阻塞状态、死亡状态\n\n什么是线程死锁?如何避免死锁?\n\n多个线程互相持续对方的锁对象 互斥、不可剥夺、循环、请求和保持\n\n\n说说 sleep() ⽅法和 wait() ⽅法区别和共同点?\n\n相同：都是使线程阻塞\n区别：sleep自动唤醒、不会释放锁，wait不会自动唤醒，释放当前持有的锁\n\n为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？\n\nstart是多线程的方法，run是对象普通方法\n\n\n说⼀说⾃⼰对于 synchronized 关键字的了解\n\n锁，保证被它修饰的代码或者方法同时只被一个线程执行，早期是调用操作系统的mutexlock互斥锁实现，java1.6之后优化了（锁升级）\n\n说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗\n\n修饰静态方法，获取的是类的锁，修饰普通方法，获取的是实例对象的锁，修饰代码块，获取的是指定对象的锁。\n\n讲⼀下 synchronized 关键字的底层原理\n\n线程获取monitor的持有权来实现\n\n说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗\n\ntodo // 锁升级\n\n谈谈 synchronized和ReentrantLock 的区别\n\nsynchronized是jvm的锁，非公平锁，ReentrantLock是JDK提供的，需要手动lock、unlock,还有一些高级功能，公平\n\ntodo // ReentrantLock condition选择性通知\n\n\n讲⼀下Java内存模型\n\n\ntodo //  总结\n\n\n并发编程的三个重要特性\n\n原子性、可见性、有序性\n\n说说 synchronized 关键字和 volatile 关键字的区别\n\nsynchronized主要解决原子性，volatile主要解决可见性和有序性\n\n\nThreadLocal\n\n主要保存线程私有的问题\n\nThreadLocal内存泄露问题\n\n\n为什么要⽤线程池？\n\n提高CPU利用率\n\n实现Runnable接⼝和Callable接⼝的区别 执⾏execute()⽅法和submit()⽅法的区别是什么呢？\n\nRunnable无返回值 不会抛出错误，Callable有返回值 会抛出错误，execute()无返回值，submit()有返回值\n\n如何创建线程池\n\nThreadPoolExecutor 或者 ExecutorService 创建\n\n线程池原理分析\n\n\n介绍⼀下Atomic 原⼦类\n\n\n\n2. JUC 包中的原⼦类是哪4类?\n3. 讲讲 AtomicInteger 的使⽤\n4. 能不能给我简单介绍⼀下 AtomicInteger 类的原理\n\n2.3.16 AQS\n1. AQS 介绍\n2. AQS 原理分析\nAQS 原理概览\nAQS 对资源的共享⽅式\nAQS底层使⽤了模板⽅法模式\n3. AQS 组件总结\n","source":"_posts/总结题-多线程.md","raw":"什么是线程和进程?\n\n程序一个执行过程就是进程，一个进程多个线程，线程是cpu的最小执行单位\n\n为什么要使⽤多线程呢?\n\n提高CPU的利用率 提高效率\n\n使⽤多线程可能带来什么问题?\n\n死锁问题、cpu线程切换消耗问题、内存泄漏问题\n\n说说线程的⽣命周期和状态?\n\n新建状态、就绪状态、运行状态、阻塞状态、死亡状态\n\n什么是线程死锁?如何避免死锁?\n\n多个线程互相持续对方的锁对象 互斥、不可剥夺、循环、请求和保持\n\n\n说说 sleep() ⽅法和 wait() ⽅法区别和共同点?\n\n相同：都是使线程阻塞\n区别：sleep自动唤醒、不会释放锁，wait不会自动唤醒，释放当前持有的锁\n\n为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？\n\nstart是多线程的方法，run是对象普通方法\n\n\n说⼀说⾃⼰对于 synchronized 关键字的了解\n\n锁，保证被它修饰的代码或者方法同时只被一个线程执行，早期是调用操作系统的mutexlock互斥锁实现，java1.6之后优化了（锁升级）\n\n说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗\n\n修饰静态方法，获取的是类的锁，修饰普通方法，获取的是实例对象的锁，修饰代码块，获取的是指定对象的锁。\n\n讲⼀下 synchronized 关键字的底层原理\n\n线程获取monitor的持有权来实现\n\n说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗\n\ntodo // 锁升级\n\n谈谈 synchronized和ReentrantLock 的区别\n\nsynchronized是jvm的锁，非公平锁，ReentrantLock是JDK提供的，需要手动lock、unlock,还有一些高级功能，公平\n\ntodo // ReentrantLock condition选择性通知\n\n\n讲⼀下Java内存模型\n\n\ntodo //  总结\n\n\n并发编程的三个重要特性\n\n原子性、可见性、有序性\n\n说说 synchronized 关键字和 volatile 关键字的区别\n\nsynchronized主要解决原子性，volatile主要解决可见性和有序性\n\n\nThreadLocal\n\n主要保存线程私有的问题\n\nThreadLocal内存泄露问题\n\n\n为什么要⽤线程池？\n\n提高CPU利用率\n\n实现Runnable接⼝和Callable接⼝的区别 执⾏execute()⽅法和submit()⽅法的区别是什么呢？\n\nRunnable无返回值 不会抛出错误，Callable有返回值 会抛出错误，execute()无返回值，submit()有返回值\n\n如何创建线程池\n\nThreadPoolExecutor 或者 ExecutorService 创建\n\n线程池原理分析\n\n\n介绍⼀下Atomic 原⼦类\n\n\n\n2. JUC 包中的原⼦类是哪4类?\n3. 讲讲 AtomicInteger 的使⽤\n4. 能不能给我简单介绍⼀下 AtomicInteger 类的原理\n\n2.3.16 AQS\n1. AQS 介绍\n2. AQS 原理分析\nAQS 原理概览\nAQS 对资源的共享⽅式\nAQS底层使⽤了模板⽅法模式\n3. AQS 组件总结\n","slug":"总结题-多线程","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bq003h9gj74owvf0nr","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>什么是线程和进程?</p>\n<p>程序一个执行过程就是进程，一个进程多个线程，线程是cpu的最小执行单位</p>\n<p>为什么要使⽤多线程呢?</p>\n<p>提高CPU的利用率 提高效率</p>\n<p>使⽤多线程可能带来什么问题?</p>\n<p>死锁问题、cpu线程切换消耗问题、内存泄漏问题</p>\n<p>说说线程的⽣命周期和状态?</p>\n<p>新建状态、就绪状态、运行状态、阻塞状态、死亡状态</p>\n<p>什么是线程死锁?如何避免死锁?</p>\n<p>多个线程互相持续对方的锁对象 互斥、不可剥夺、循环、请求和保持</p>\n<p>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</p>\n<p>相同：都是使线程阻塞<br>区别：sleep自动唤醒、不会释放锁，wait不会自动唤醒，释放当前持有的锁</p>\n<p>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</p>\n<p>start是多线程的方法，run是对象普通方法</p>\n<p>说⼀说⾃⼰对于 synchronized 关键字的了解</p>\n<p>锁，保证被它修饰的代码或者方法同时只被一个线程执行，早期是调用操作系统的mutexlock互斥锁实现，java1.6之后优化了（锁升级）</p>\n<p>说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗</p>\n<p>修饰静态方法，获取的是类的锁，修饰普通方法，获取的是实例对象的锁，修饰代码块，获取的是指定对象的锁。</p>\n<p>讲⼀下 synchronized 关键字的底层原理</p>\n<p>线程获取monitor的持有权来实现</p>\n<p>说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗</p>\n<p>todo // 锁升级</p>\n<p>谈谈 synchronized和ReentrantLock 的区别</p>\n<p>synchronized是jvm的锁，非公平锁，ReentrantLock是JDK提供的，需要手动lock、unlock,还有一些高级功能，公平</p>\n<p>todo // ReentrantLock condition选择性通知</p>\n<p>讲⼀下Java内存模型</p>\n<p>todo //  总结</p>\n<p>并发编程的三个重要特性</p>\n<p>原子性、可见性、有序性</p>\n<p>说说 synchronized 关键字和 volatile 关键字的区别</p>\n<p>synchronized主要解决原子性，volatile主要解决可见性和有序性</p>\n<p>ThreadLocal</p>\n<p>主要保存线程私有的问题</p>\n<p>ThreadLocal内存泄露问题</p>\n<p>为什么要⽤线程池？</p>\n<p>提高CPU利用率</p>\n<p>实现Runnable接⼝和Callable接⼝的区别 执⾏execute()⽅法和submit()⽅法的区别是什么呢？</p>\n<p>Runnable无返回值 不会抛出错误，Callable有返回值 会抛出错误，execute()无返回值，submit()有返回值</p>\n<p>如何创建线程池</p>\n<p>ThreadPoolExecutor 或者 ExecutorService 创建</p>\n<p>线程池原理分析</p>\n<p>介绍⼀下Atomic 原⼦类</p>\n<ol start=\"2\">\n<li>JUC 包中的原⼦类是哪4类?</li>\n<li>讲讲 AtomicInteger 的使⽤</li>\n<li>能不能给我简单介绍⼀下 AtomicInteger 类的原理</li>\n</ol>\n<p>2.3.16 AQS</p>\n<ol>\n<li>AQS 介绍</li>\n<li>AQS 原理分析<br>AQS 原理概览<br>AQS 对资源的共享⽅式<br>AQS底层使⽤了模板⽅法模式</li>\n<li>AQS 组件总结</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>什么是线程和进程?</p>\n<p>程序一个执行过程就是进程，一个进程多个线程，线程是cpu的最小执行单位</p>\n<p>为什么要使⽤多线程呢?</p>\n<p>提高CPU的利用率 提高效率</p>\n<p>使⽤多线程可能带来什么问题?</p>\n<p>死锁问题、cpu线程切换消耗问题、内存泄漏问题</p>\n<p>说说线程的⽣命周期和状态?</p>\n<p>新建状态、就绪状态、运行状态、阻塞状态、死亡状态</p>\n<p>什么是线程死锁?如何避免死锁?</p>\n<p>多个线程互相持续对方的锁对象 互斥、不可剥夺、循环、请求和保持</p>\n<p>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</p>\n<p>相同：都是使线程阻塞<br>区别：sleep自动唤醒、不会释放锁，wait不会自动唤醒，释放当前持有的锁</p>\n<p>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</p>\n<p>start是多线程的方法，run是对象普通方法</p>\n<p>说⼀说⾃⼰对于 synchronized 关键字的了解</p>\n<p>锁，保证被它修饰的代码或者方法同时只被一个线程执行，早期是调用操作系统的mutexlock互斥锁实现，java1.6之后优化了（锁升级）</p>\n<p>说说⾃⼰是怎么使⽤ synchronized 关键字，在项⽬中⽤到了吗</p>\n<p>修饰静态方法，获取的是类的锁，修饰普通方法，获取的是实例对象的锁，修饰代码块，获取的是指定对象的锁。</p>\n<p>讲⼀下 synchronized 关键字的底层原理</p>\n<p>线程获取monitor的持有权来实现</p>\n<p>说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍⼀下这些优化吗</p>\n<p>todo // 锁升级</p>\n<p>谈谈 synchronized和ReentrantLock 的区别</p>\n<p>synchronized是jvm的锁，非公平锁，ReentrantLock是JDK提供的，需要手动lock、unlock,还有一些高级功能，公平</p>\n<p>todo // ReentrantLock condition选择性通知</p>\n<p>讲⼀下Java内存模型</p>\n<p>todo //  总结</p>\n<p>并发编程的三个重要特性</p>\n<p>原子性、可见性、有序性</p>\n<p>说说 synchronized 关键字和 volatile 关键字的区别</p>\n<p>synchronized主要解决原子性，volatile主要解决可见性和有序性</p>\n<p>ThreadLocal</p>\n<p>主要保存线程私有的问题</p>\n<p>ThreadLocal内存泄露问题</p>\n<p>为什么要⽤线程池？</p>\n<p>提高CPU利用率</p>\n<p>实现Runnable接⼝和Callable接⼝的区别 执⾏execute()⽅法和submit()⽅法的区别是什么呢？</p>\n<p>Runnable无返回值 不会抛出错误，Callable有返回值 会抛出错误，execute()无返回值，submit()有返回值</p>\n<p>如何创建线程池</p>\n<p>ThreadPoolExecutor 或者 ExecutorService 创建</p>\n<p>线程池原理分析</p>\n<p>介绍⼀下Atomic 原⼦类</p>\n<ol start=\"2\">\n<li>JUC 包中的原⼦类是哪4类?</li>\n<li>讲讲 AtomicInteger 的使⽤</li>\n<li>能不能给我简单介绍⼀下 AtomicInteger 类的原理</li>\n</ol>\n<p>2.3.16 AQS</p>\n<ol>\n<li>AQS 介绍</li>\n<li>AQS 原理分析<br>AQS 原理概览<br>AQS 对资源的共享⽅式<br>AQS底层使⽤了模板⽅法模式</li>\n<li>AQS 组件总结</li>\n</ol>\n"},{"title":"总结-总结题","_content":"\n\n\n## JVM篇\n\n- 运行时区域组成结构和各部分作用\n\n```\n\n线程共享： 堆  方法区（包含运行时常量池）\n线程私有区： 虚拟机栈 本地方法栈 程序计数器\n直接内存\n\n虚拟栈： 每个方法会以栈帧的方式存在虚拟机栈中，每一个栈帧中包含四大区域（局部变量表、操作数栈、动态链接、返回地址），缺省值大小为1M,递归死循环会导致StackOverflowError。\n\n\t局部变量表 ： 存放变量的地方，主要存方八大数据类型，如果时一个对象，则存放对象的引用地址\n\t操作数栈： JVM引擎的工作区\n\t动态链接： Java语言特性多态\n\t返回地址： 正常情况从程序计数器中取，异常的时候从异常表里面取\n\n本地方法栈： 执行native方法\n\n程序计数器： 存储当前字节码的偏移量，线程独有，互不干扰\n\n方法区: 存储已被虚拟机加载的类信息、常量、静态变量、代码缓存等等\n\n\n堆：分为新生代和老年代（1：2），新生代分为Eden区和两个Survivor区（8：1：1），堆主要与垃圾回收相关\n\n```\n\n\n\n- Java对象\n\n```\n\n对象的组成部分：  Header + 实例数据 + 对其填充\n\nHeader : 包含对象头markdown(8个字节)  对象头指针（4个字节） 如果是数组还有一个数组长度（4个字节）\n实例数据：\n对其填充： 对象的整体大小需要是8的倍数\n\n\n对象创建过程：\n\n\n加载检查\n分配对象 : 如果是连续的内存，直接使用内存碰撞的方式，如不是连续的内存，需要维护一张空闲列表，性能相比连续内存较低。\n内存空间初始化 ： 属性赋予默认值\n设置对象头\n对象初始化\n\n\n对象的分配策略\n\n1、先检查是否开启了逃逸分析，是否能够在栈上分配（更好的进行垃圾回收）\n2、检查是否是大对象，大对象直接进入老年代\n3、是否开启了本地线程缓冲，在Eden区域分配对象\n\n\n```\n\n- 类加载机制\n\n```\n\n1、加载  根据class文件加载二进制字节流，存在方法区\n2、验证  版本号 cafababy等等\n3、准备  类变量、静态变量等分配内存，赋初始值 final常量会在这一步赋值\n4、解析  将符号引用转换为直接引用\n5、初始化  \n\n```\n\n- 双亲委派及作用\n\n```\n\n加载一个类的时候先给父加载器加载，父加载器加载不了再自己加载，目的是为了防止核心类被篡改\n\n```\n\n- 垃圾回收机制\n\n```\n\n判断一个类是不是垃圾 （引用计数（只计强引用） / 可达性分析）\n\n\n常见的回收算法：\n\n复制算法\n标记清除算法\n标记整理\n\n\n```\n\n\n\n\n\n\n①悲观锁和乐观锁 （ 具体可以看我的这篇文章：面试必备之乐观锁与悲观锁）.\n②synchronized 和 lock 区别以及 volatile 和 synchronized 的区别，\n③可重入锁与非可重入锁 的区别.\n④多线程是解决什么问题的.\n⑤线程池解决什么问题.\n⑥线程池的原理.⑦\n线程池使用时的注意事项.⑧AQS 原有没有在项目中实际使用多线程的经历。所 以，如果你在你的项目中有实际使用 Java 多线程的经历 的话，会为你加分不少 哦！\n异常的类型\ncatch中出现异常\ncatch 中return finally 中return\n\njvm常见的配置参数\n\ncatch 中报错","source":"_posts/总结题.md","raw":"---\ntitle: 总结-总结题\ntags:\n  - 总结\n---\n\n\n\n## JVM篇\n\n- 运行时区域组成结构和各部分作用\n\n```\n\n线程共享： 堆  方法区（包含运行时常量池）\n线程私有区： 虚拟机栈 本地方法栈 程序计数器\n直接内存\n\n虚拟栈： 每个方法会以栈帧的方式存在虚拟机栈中，每一个栈帧中包含四大区域（局部变量表、操作数栈、动态链接、返回地址），缺省值大小为1M,递归死循环会导致StackOverflowError。\n\n\t局部变量表 ： 存放变量的地方，主要存方八大数据类型，如果时一个对象，则存放对象的引用地址\n\t操作数栈： JVM引擎的工作区\n\t动态链接： Java语言特性多态\n\t返回地址： 正常情况从程序计数器中取，异常的时候从异常表里面取\n\n本地方法栈： 执行native方法\n\n程序计数器： 存储当前字节码的偏移量，线程独有，互不干扰\n\n方法区: 存储已被虚拟机加载的类信息、常量、静态变量、代码缓存等等\n\n\n堆：分为新生代和老年代（1：2），新生代分为Eden区和两个Survivor区（8：1：1），堆主要与垃圾回收相关\n\n```\n\n\n\n- Java对象\n\n```\n\n对象的组成部分：  Header + 实例数据 + 对其填充\n\nHeader : 包含对象头markdown(8个字节)  对象头指针（4个字节） 如果是数组还有一个数组长度（4个字节）\n实例数据：\n对其填充： 对象的整体大小需要是8的倍数\n\n\n对象创建过程：\n\n\n加载检查\n分配对象 : 如果是连续的内存，直接使用内存碰撞的方式，如不是连续的内存，需要维护一张空闲列表，性能相比连续内存较低。\n内存空间初始化 ： 属性赋予默认值\n设置对象头\n对象初始化\n\n\n对象的分配策略\n\n1、先检查是否开启了逃逸分析，是否能够在栈上分配（更好的进行垃圾回收）\n2、检查是否是大对象，大对象直接进入老年代\n3、是否开启了本地线程缓冲，在Eden区域分配对象\n\n\n```\n\n- 类加载机制\n\n```\n\n1、加载  根据class文件加载二进制字节流，存在方法区\n2、验证  版本号 cafababy等等\n3、准备  类变量、静态变量等分配内存，赋初始值 final常量会在这一步赋值\n4、解析  将符号引用转换为直接引用\n5、初始化  \n\n```\n\n- 双亲委派及作用\n\n```\n\n加载一个类的时候先给父加载器加载，父加载器加载不了再自己加载，目的是为了防止核心类被篡改\n\n```\n\n- 垃圾回收机制\n\n```\n\n判断一个类是不是垃圾 （引用计数（只计强引用） / 可达性分析）\n\n\n常见的回收算法：\n\n复制算法\n标记清除算法\n标记整理\n\n\n```\n\n\n\n\n\n\n①悲观锁和乐观锁 （ 具体可以看我的这篇文章：面试必备之乐观锁与悲观锁）.\n②synchronized 和 lock 区别以及 volatile 和 synchronized 的区别，\n③可重入锁与非可重入锁 的区别.\n④多线程是解决什么问题的.\n⑤线程池解决什么问题.\n⑥线程池的原理.⑦\n线程池使用时的注意事项.⑧AQS 原有没有在项目中实际使用多线程的经历。所 以，如果你在你的项目中有实际使用 Java 多线程的经历 的话，会为你加分不少 哦！\n异常的类型\ncatch中出现异常\ncatch 中return finally 中return\n\njvm常见的配置参数\n\ncatch 中报错","slug":"总结题","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15br003j9gj7w4g8h5jd","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"JVM篇\"><a href=\"#JVM篇\" class=\"headerlink\" title=\"JVM篇\"></a>JVM篇</h2><ul>\n<li>运行时区域组成结构和各部分作用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">线程共享： 堆  方法区（包含运行时常量池）</span><br><span class=\"line\">线程私有区： 虚拟机栈 本地方法栈 程序计数器</span><br><span class=\"line\">直接内存</span><br><span class=\"line\"></span><br><span class=\"line\">虚拟栈： 每个方法会以栈帧的方式存在虚拟机栈中，每一个栈帧中包含四大区域（局部变量表、操作数栈、动态链接、返回地址），缺省值大小为1M,递归死循环会导致StackOverflowError。</span><br><span class=\"line\"></span><br><span class=\"line\">\t局部变量表 ： 存放变量的地方，主要存方八大数据类型，如果时一个对象，则存放对象的引用地址</span><br><span class=\"line\">\t操作数栈： JVM引擎的工作区</span><br><span class=\"line\">\t动态链接： Java语言特性多态</span><br><span class=\"line\">\t返回地址： 正常情况从程序计数器中取，异常的时候从异常表里面取</span><br><span class=\"line\"></span><br><span class=\"line\">本地方法栈： 执行native方法</span><br><span class=\"line\"></span><br><span class=\"line\">程序计数器： 存储当前字节码的偏移量，线程独有，互不干扰</span><br><span class=\"line\"></span><br><span class=\"line\">方法区: 存储已被虚拟机加载的类信息、常量、静态变量、代码缓存等等</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">堆：分为新生代和老年代（1：2），新生代分为Eden区和两个Survivor区（8：1：1），堆主要与垃圾回收相关</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对象的组成部分：  Header + 实例数据 + 对其填充</span><br><span class=\"line\"></span><br><span class=\"line\">Header : 包含对象头markdown(8个字节)  对象头指针（4个字节） 如果是数组还有一个数组长度（4个字节）</span><br><span class=\"line\">实例数据：</span><br><span class=\"line\">对其填充： 对象的整体大小需要是8的倍数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">对象创建过程：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">加载检查</span><br><span class=\"line\">分配对象 : 如果是连续的内存，直接使用内存碰撞的方式，如不是连续的内存，需要维护一张空闲列表，性能相比连续内存较低。</span><br><span class=\"line\">内存空间初始化 ： 属性赋予默认值</span><br><span class=\"line\">设置对象头</span><br><span class=\"line\">对象初始化</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">对象的分配策略</span><br><span class=\"line\"></span><br><span class=\"line\">1、先检查是否开启了逃逸分析，是否能够在栈上分配（更好的进行垃圾回收）</span><br><span class=\"line\">2、检查是否是大对象，大对象直接进入老年代</span><br><span class=\"line\">3、是否开启了本地线程缓冲，在Eden区域分配对象</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类加载机制</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1、加载  根据class文件加载二进制字节流，存在方法区</span><br><span class=\"line\">2、验证  版本号 cafababy等等</span><br><span class=\"line\">3、准备  类变量、静态变量等分配内存，赋初始值 final常量会在这一步赋值</span><br><span class=\"line\">4、解析  将符号引用转换为直接引用</span><br><span class=\"line\">5、初始化</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双亲委派及作用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">加载一个类的时候先给父加载器加载，父加载器加载不了再自己加载，目的是为了防止核心类被篡改</span><br></pre></td></tr></table></figure>\n<ul>\n<li>垃圾回收机制</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">判断一个类是不是垃圾 （引用计数（只计强引用） / 可达性分析）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">常见的回收算法：</span><br><span class=\"line\"></span><br><span class=\"line\">复制算法</span><br><span class=\"line\">标记清除算法</span><br><span class=\"line\">标记整理</span><br></pre></td></tr></table></figure>\n<p>①悲观锁和乐观锁 （ 具体可以看我的这篇文章：面试必备之乐观锁与悲观锁）.<br>②synchronized 和 lock 区别以及 volatile 和 synchronized 的区别，<br>③可重入锁与非可重入锁 的区别.<br>④多线程是解决什么问题的.<br>⑤线程池解决什么问题.<br>⑥线程池的原理.⑦<br>线程池使用时的注意事项.⑧AQS 原有没有在项目中实际使用多线程的经历。所 以，如果你在你的项目中有实际使用 Java 多线程的经历 的话，会为你加分不少 哦！<br>异常的类型<br>catch中出现异常<br>catch 中return finally 中return</p>\n<p>jvm常见的配置参数</p>\n<p>catch 中报错</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JVM篇\"><a href=\"#JVM篇\" class=\"headerlink\" title=\"JVM篇\"></a>JVM篇</h2><ul>\n<li>运行时区域组成结构和各部分作用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">线程共享： 堆  方法区（包含运行时常量池）</span><br><span class=\"line\">线程私有区： 虚拟机栈 本地方法栈 程序计数器</span><br><span class=\"line\">直接内存</span><br><span class=\"line\"></span><br><span class=\"line\">虚拟栈： 每个方法会以栈帧的方式存在虚拟机栈中，每一个栈帧中包含四大区域（局部变量表、操作数栈、动态链接、返回地址），缺省值大小为1M,递归死循环会导致StackOverflowError。</span><br><span class=\"line\"></span><br><span class=\"line\">\t局部变量表 ： 存放变量的地方，主要存方八大数据类型，如果时一个对象，则存放对象的引用地址</span><br><span class=\"line\">\t操作数栈： JVM引擎的工作区</span><br><span class=\"line\">\t动态链接： Java语言特性多态</span><br><span class=\"line\">\t返回地址： 正常情况从程序计数器中取，异常的时候从异常表里面取</span><br><span class=\"line\"></span><br><span class=\"line\">本地方法栈： 执行native方法</span><br><span class=\"line\"></span><br><span class=\"line\">程序计数器： 存储当前字节码的偏移量，线程独有，互不干扰</span><br><span class=\"line\"></span><br><span class=\"line\">方法区: 存储已被虚拟机加载的类信息、常量、静态变量、代码缓存等等</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">堆：分为新生代和老年代（1：2），新生代分为Eden区和两个Survivor区（8：1：1），堆主要与垃圾回收相关</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Java对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对象的组成部分：  Header + 实例数据 + 对其填充</span><br><span class=\"line\"></span><br><span class=\"line\">Header : 包含对象头markdown(8个字节)  对象头指针（4个字节） 如果是数组还有一个数组长度（4个字节）</span><br><span class=\"line\">实例数据：</span><br><span class=\"line\">对其填充： 对象的整体大小需要是8的倍数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">对象创建过程：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">加载检查</span><br><span class=\"line\">分配对象 : 如果是连续的内存，直接使用内存碰撞的方式，如不是连续的内存，需要维护一张空闲列表，性能相比连续内存较低。</span><br><span class=\"line\">内存空间初始化 ： 属性赋予默认值</span><br><span class=\"line\">设置对象头</span><br><span class=\"line\">对象初始化</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">对象的分配策略</span><br><span class=\"line\"></span><br><span class=\"line\">1、先检查是否开启了逃逸分析，是否能够在栈上分配（更好的进行垃圾回收）</span><br><span class=\"line\">2、检查是否是大对象，大对象直接进入老年代</span><br><span class=\"line\">3、是否开启了本地线程缓冲，在Eden区域分配对象</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类加载机制</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1、加载  根据class文件加载二进制字节流，存在方法区</span><br><span class=\"line\">2、验证  版本号 cafababy等等</span><br><span class=\"line\">3、准备  类变量、静态变量等分配内存，赋初始值 final常量会在这一步赋值</span><br><span class=\"line\">4、解析  将符号引用转换为直接引用</span><br><span class=\"line\">5、初始化</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双亲委派及作用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">加载一个类的时候先给父加载器加载，父加载器加载不了再自己加载，目的是为了防止核心类被篡改</span><br></pre></td></tr></table></figure>\n<ul>\n<li>垃圾回收机制</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">判断一个类是不是垃圾 （引用计数（只计强引用） / 可达性分析）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">常见的回收算法：</span><br><span class=\"line\"></span><br><span class=\"line\">复制算法</span><br><span class=\"line\">标记清除算法</span><br><span class=\"line\">标记整理</span><br></pre></td></tr></table></figure>\n<p>①悲观锁和乐观锁 （ 具体可以看我的这篇文章：面试必备之乐观锁与悲观锁）.<br>②synchronized 和 lock 区别以及 volatile 和 synchronized 的区别，<br>③可重入锁与非可重入锁 的区别.<br>④多线程是解决什么问题的.<br>⑤线程池解决什么问题.<br>⑥线程池的原理.⑦<br>线程池使用时的注意事项.⑧AQS 原有没有在项目中实际使用多线程的经历。所 以，如果你在你的项目中有实际使用 Java 多线程的经历 的话，会为你加分不少 哦！<br>异常的类型<br>catch中出现异常<br>catch 中return finally 中return</p>\n<p>jvm常见的配置参数</p>\n<p>catch 中报错</p>\n"},{"title":"常见排序算法","_content":"\n### 总结常见的10中排序模型\n\n本文主要汇总下常见的10中排序模型，用一张图概括如下：\n\n![时间复杂度与空间复杂度](https://image.tupelo.top/sort.png)\n\n- 排序稳定性：相同元素的排序后顺序是否是固定的\n\n\n<!-- more -->\n\n\n#### 冒泡排序\n\n- 两次循环，每个都和后面的数进行比较，如果当前数大于后面的数则交换位置。\n- 每循环一次，当前的最后的一个数为当次循环的最大数。\n\n```java\npublic static void sort(int[] ints){\n        for (int i = 0; i < ints.length-1; i++) {\n            for (int j = 0; j < ints.length-i-1; j++) {\n                if(ints[j]>ints[j+1]){\n                    swap(ints,j,j+1);\n                }\n            }\n        }\n    }\n```\n\n#### 选择排序\n\n- 找到数组（0 - n）中的最大值，放到数组最后。\n- 在循环找到数组（0 - n-1）中的最大值，放到n-1的位置，如此循环知道最后完成。\n\n```java\nprivate static void sort(int[] ints){\n    for (int i = 0; i < ints.length; i++) {\n        int minNum = ints[i];\n        int index = i;\n        for (int j = i + 1; j < ints.length; j++) {\n            if(ints[j] < minNum){\n                minNum = ints[j];\n                index = j;\n            }\n        }\n        if(i!=index){\n            swap(ints,i,index);\n        }\n    }\n}\n```\n\n#### 插入排序\n\n- 两层遍历，二层遍历遍历当前index前面的值，如果当前值小于前面的值，则交换位置\n- 知道前面的值小于等于当前值\n\n```java\nprivate static void sort(int[] ints){\n    for (int i = 0; i < ints.length; i++) {\n        int index = i;\n        for (int j = i - 1; j >= 0 ; j--) {\n            if(ints[index] < ints[j]){\n                swap(ints,index,j);\n                index--;\n            }else {\n                break;\n            }\n        }\n    }\n}\n```\n\n#### 计数排序\n\n- 将当前数组中的值转化为一个新数组的下标。\n- 新数组的值为当前下标在目标数组中的个数，新数组的大小为`最大值 - 最小值 + 1`。\n- 最后将新数组中的值按顺序重新复制到老数组中。\n- 如果最大值和最小值相差太多的，会存在空间浪费的情况。\n\n```java\nprivate static void sort(int[] ints){\n    // 找最大最小值\n    int max = ints[0];\n    int min = ints[0];\n    for (int i = 1; i < ints.length; i++) {\n        if(ints[i]>max){\n            max = ints[i];\n        }\n        if(ints[i]<min){\n            min = ints[i];\n        }\n    }\n    // 创建新数组 大小为 max - min + 1\n    int[] temp = new int[max - min + 1];\n    // 将当前数组中的值存入到新数组中\n    for (int i : ints) {\n        temp[i-min]++;\n    }\n    // 新数组的值又重新赋值回去\n    int index = 0;\n    for (int i = 0; i < temp.length; i++) {\n        int i1 = temp[i];\n        if(i1>0){\n            for (int i2 = 0; i2 < i1; i2++) {\n                ints[index] = i+min;\n                index++;\n            }\n        }\n    }\n}\n```\n\n\n#### 桶排序\n\n- 将数组中的值按照大小分到固定几个桶中。\n- 将每个桶中的数据都分别进行排序(使用其它的排序算法，如插入排序)。\n- 最后将每个桶中的数据重新复制到原数组中。\n\n```java\n// num 为桶的个数\nprivate static void bucketSort(int[] ints,int num){\n    // 查找数组中的最大最小值\n    int max = ints[0];\n    int min = ints[0];\n    for (int i = 1; i < ints.length; i++) {\n        if(ints[i]>max){\n            max = ints[i];\n        }\n        if(ints[i]<min){\n            min = ints[i];\n        }\n    }\n    // 不是根据个数，是根据数组中值的大小 计算桶的容量\n    int count =  (max - min) / num + 1;\n    int[][] bucket = new int[num][0];\n    // 根据值的大小放到不同的桶中去\n    for (int anInt : ints) {\n        int index = (anInt - min) / count;\n        bucket[index] = appendBucket(bucket[index],anInt);\n    }\n    int mainIndex = 0;\n    // 将每个桶进行排序 并赋值到原来的数组中\n    for (int[] ints1 : bucket) {\n        if(ints1.length<=0){\n            continue;\n        }\n        // 排序 此处使用插入排序 也可以用其它的排序方式\n        for (int i = 0; i < ints1.length; i++) {\n            int index = i;\n            for (int j = i-1; j >= 0; j--) {\n                if(ints1[j]>ints1[index]){\n                    swap(ints1,index,j);\n                    index--;\n                }\n            }\n        }\n        for (int i : ints1) {\n            ints[mainIndex] = i;\n            mainIndex++;\n        }\n    }\n}\n\n// 向数组中添加元素\npublic static int[] appendBucket(int[] bucket , int anInt){\n    int[] ints = Arrays.copyOf(bucket, bucket.length + 1);\n    ints[ints.length-1] = anInt;\n    return ints;\n}\n```\n\n\n#### 基数排序\n\n\n- 按照数据的位数来排序，方式类型桶排序，只是桶中的数据不用再排序了。\n- 固定10个桶，编号0-9。\n- 从个、十、百...位开始遍历，位数比较小的补0。\n- 每次遍历将值放到对应位数的数字对应桶中，然后合并。\n\n```java\n\nprivate static void sort(int[] ints){\n    // 获取最大的数的长度\n    int maxLength = getMaxLength(ints);\n    // 从个位开始遍历\n    for (int i = maxLength-1; i >= 0; i--) {\n        baseSort(ints,i,maxLength);\n    }\n\n}\n\n\nprivate static void baseSort(int[] ints,int index,int maxLength){\n    // 固定10个桶\n    int[][] base = new int[10][0];\n    for (int i = 0; i < ints.length; i++) {\n        // 获取当前值在第几位上的数\n        int intIndex = getIntIndex(ints[i], index, maxLength);\n        // 放到对应的桶里去\n        base[intIndex] = appendBucket(base[intIndex],ints[i]);\n    }\n    // 再合并起来 此时不用再排序\n    int mainIndex = 0;\n    for (int[] ints1 : base) {\n        if(ints1.length<=0){\n            continue;\n        }\n        for (int i : ints1) {\n            ints[mainIndex] = i;\n            mainIndex++;\n        }\n    }\n}\n\n// 获取第几位的数\nprivate static int getIntIndex(int i,int index,int maxLength){\n    String s = String.valueOf(i);\n    int length = s.length();\n    if(length + index < maxLength){\n        return 0;\n    }\n    char c = s.charAt(index - maxLength + length);\n    return Integer.parseInt(String.valueOf(c));\n}\n\n// 获取最大数的长度\nprivate static int getMaxLength(int[] ints){\n    int max = ints[0];\n    for (int anInt : ints) {\n        if(anInt>max){\n            max = anInt;\n        }\n    }\n    return String.valueOf(max).length();\n}\n\n// 向数组中添加一个元素\npublic static int[] appendBucket(int[] bucket , int anInt){\n    int[] ints = Arrays.copyOf(bucket, bucket.length + 1);\n    ints[ints.length-1] = anInt;\n    return ints;\n}\n```\n\n\n#### 希尔排序\n\n- 拆分 -> 每组插入排序 -> 拆分 -> 每组插入排序 ...\n- 只到最终拆分成每组的间隔只有1\n\n```java\nprivate static void sort(int[] ints){\n    // 首先要进行分组 然后进行插入排序 间隔为长度 / 2 ... 一直到长度为1\n    for (int step = ints.length/2; step > 0 ; step /= 2) {\n        // 每次都进行一次插入排序\n        for (int i = step; i < ints.length; i++) {\n            // 当前值\n            int index = i;\n            for (int j = i-step; j >= 0 ; j-=step) {\n                if(ints[j]>ints[index]){\n                    swap(ints,index,j);\n                    index = j;\n                }else {\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n#### 快速排序\n\n- 找到一个基准值 然后设置左右两个指针，当左边的大于基准值、右边的小于基准值，则交换位置\n- 当左指针>=右指针时与基准值交换位置\n- 再分别重复基准值左边的部分和右边的部分，知道里面的拆分里面的元素只有一个\n\n```java\nprivate static void sort(int[] param,int left ,int right){\n    // 里面元素只有一个的时候结束递归\n    if(left>=right){\n        return;\n    }\n    // 找到基准值的位置\n    int partition = partition(param, left, right);\n    // 继续递归左边的数据\n    sort(param,left,partition-1);\n    // 继续递归右边的数据\n    sort(param,partition+1,right);\n}\n\n// 找基准值\nprivate static int partition(int[] param,int left ,int right){\n    // 直接以第一个为基准值\n    int pivot = param[left];\n    int index = left;\n    while (left<right){\n        while (right>left){\n            // 如果右边有值小于基准值 则交换位置\n            if(param[right] < pivot){\n                swap(right,index,param);\n                index = right;\n                left++;\n                break;\n            }\n            right--;\n        }\n        // 如果左边有值大于基准值 则与基准值交换位置\n        while (right>left){\n            if(param[left] > pivot){\n                swap(left,index,param);\n                index = left;\n                right--;\n                break;\n\n            }\n            left++;\n        }\n    }\n    // 返回基准值的位置\n    return index;\n}\n```\n\n#### 归并排序\n\n- 先将数组进行拆分，一直拆到只有一个元素\n- 再将数组进行合并，合并的时候进行排序\n\n```java\n\n// 先用递归进行拆分 知道里面只有一个元素为止\npublic static void sort(int[] ints,int left,int right){\n    int mid = (right+left) / 2;\n    if(left<right){\n        sort( ints, left, mid);\n        sort( ints, mid+1, right);\n        merge(ints ,left,mid,right);\n    }\n}\n\n// 开始进行合并\npublic static void merge(int[] ints,int left,int mid,int right){\n\n    // 构建一个临时数组 并记录左边的下标和右边的下标\n    int[] temp = new int[right-left+1];\n    int k = 0;\n    int i = left;\n    int j = mid+1;\n\n    // 左边和右边都有值的时候 直接比较 按顺序赋值\n    while (i<=mid && j<=right){\n        if(ints[i]<ints[j]){\n            temp[k] = ints[i];\n            i++;\n        }else {\n            temp[k] = ints[j];\n            j++;\n        }\n        k++;\n    }\n\n    // 只有左边有值 直接将左边的赋值过去\n    while (i<=mid){\n        temp[k] = ints[i];\n        i++;\n        k++;\n    }\n    // 只有右边有值 直接将右边的赋值过去\n    while (j<=right){\n        temp[k] = ints[j];\n        j++;\n        k++;\n    }\n\n    // 临时数组重新赋值回去\n    for (int i1 = 0; i1 < temp.length; i1++) {\n        ints[left+i1] = temp[i1];\n    }\n}\n```\n\n","source":"_posts/排序.md","raw":"---\ntitle: 常见排序算法\ntags:\n  - 算法\n  - 排序\n---\n\n### 总结常见的10中排序模型\n\n本文主要汇总下常见的10中排序模型，用一张图概括如下：\n\n![时间复杂度与空间复杂度](https://image.tupelo.top/sort.png)\n\n- 排序稳定性：相同元素的排序后顺序是否是固定的\n\n\n<!-- more -->\n\n\n#### 冒泡排序\n\n- 两次循环，每个都和后面的数进行比较，如果当前数大于后面的数则交换位置。\n- 每循环一次，当前的最后的一个数为当次循环的最大数。\n\n```java\npublic static void sort(int[] ints){\n        for (int i = 0; i < ints.length-1; i++) {\n            for (int j = 0; j < ints.length-i-1; j++) {\n                if(ints[j]>ints[j+1]){\n                    swap(ints,j,j+1);\n                }\n            }\n        }\n    }\n```\n\n#### 选择排序\n\n- 找到数组（0 - n）中的最大值，放到数组最后。\n- 在循环找到数组（0 - n-1）中的最大值，放到n-1的位置，如此循环知道最后完成。\n\n```java\nprivate static void sort(int[] ints){\n    for (int i = 0; i < ints.length; i++) {\n        int minNum = ints[i];\n        int index = i;\n        for (int j = i + 1; j < ints.length; j++) {\n            if(ints[j] < minNum){\n                minNum = ints[j];\n                index = j;\n            }\n        }\n        if(i!=index){\n            swap(ints,i,index);\n        }\n    }\n}\n```\n\n#### 插入排序\n\n- 两层遍历，二层遍历遍历当前index前面的值，如果当前值小于前面的值，则交换位置\n- 知道前面的值小于等于当前值\n\n```java\nprivate static void sort(int[] ints){\n    for (int i = 0; i < ints.length; i++) {\n        int index = i;\n        for (int j = i - 1; j >= 0 ; j--) {\n            if(ints[index] < ints[j]){\n                swap(ints,index,j);\n                index--;\n            }else {\n                break;\n            }\n        }\n    }\n}\n```\n\n#### 计数排序\n\n- 将当前数组中的值转化为一个新数组的下标。\n- 新数组的值为当前下标在目标数组中的个数，新数组的大小为`最大值 - 最小值 + 1`。\n- 最后将新数组中的值按顺序重新复制到老数组中。\n- 如果最大值和最小值相差太多的，会存在空间浪费的情况。\n\n```java\nprivate static void sort(int[] ints){\n    // 找最大最小值\n    int max = ints[0];\n    int min = ints[0];\n    for (int i = 1; i < ints.length; i++) {\n        if(ints[i]>max){\n            max = ints[i];\n        }\n        if(ints[i]<min){\n            min = ints[i];\n        }\n    }\n    // 创建新数组 大小为 max - min + 1\n    int[] temp = new int[max - min + 1];\n    // 将当前数组中的值存入到新数组中\n    for (int i : ints) {\n        temp[i-min]++;\n    }\n    // 新数组的值又重新赋值回去\n    int index = 0;\n    for (int i = 0; i < temp.length; i++) {\n        int i1 = temp[i];\n        if(i1>0){\n            for (int i2 = 0; i2 < i1; i2++) {\n                ints[index] = i+min;\n                index++;\n            }\n        }\n    }\n}\n```\n\n\n#### 桶排序\n\n- 将数组中的值按照大小分到固定几个桶中。\n- 将每个桶中的数据都分别进行排序(使用其它的排序算法，如插入排序)。\n- 最后将每个桶中的数据重新复制到原数组中。\n\n```java\n// num 为桶的个数\nprivate static void bucketSort(int[] ints,int num){\n    // 查找数组中的最大最小值\n    int max = ints[0];\n    int min = ints[0];\n    for (int i = 1; i < ints.length; i++) {\n        if(ints[i]>max){\n            max = ints[i];\n        }\n        if(ints[i]<min){\n            min = ints[i];\n        }\n    }\n    // 不是根据个数，是根据数组中值的大小 计算桶的容量\n    int count =  (max - min) / num + 1;\n    int[][] bucket = new int[num][0];\n    // 根据值的大小放到不同的桶中去\n    for (int anInt : ints) {\n        int index = (anInt - min) / count;\n        bucket[index] = appendBucket(bucket[index],anInt);\n    }\n    int mainIndex = 0;\n    // 将每个桶进行排序 并赋值到原来的数组中\n    for (int[] ints1 : bucket) {\n        if(ints1.length<=0){\n            continue;\n        }\n        // 排序 此处使用插入排序 也可以用其它的排序方式\n        for (int i = 0; i < ints1.length; i++) {\n            int index = i;\n            for (int j = i-1; j >= 0; j--) {\n                if(ints1[j]>ints1[index]){\n                    swap(ints1,index,j);\n                    index--;\n                }\n            }\n        }\n        for (int i : ints1) {\n            ints[mainIndex] = i;\n            mainIndex++;\n        }\n    }\n}\n\n// 向数组中添加元素\npublic static int[] appendBucket(int[] bucket , int anInt){\n    int[] ints = Arrays.copyOf(bucket, bucket.length + 1);\n    ints[ints.length-1] = anInt;\n    return ints;\n}\n```\n\n\n#### 基数排序\n\n\n- 按照数据的位数来排序，方式类型桶排序，只是桶中的数据不用再排序了。\n- 固定10个桶，编号0-9。\n- 从个、十、百...位开始遍历，位数比较小的补0。\n- 每次遍历将值放到对应位数的数字对应桶中，然后合并。\n\n```java\n\nprivate static void sort(int[] ints){\n    // 获取最大的数的长度\n    int maxLength = getMaxLength(ints);\n    // 从个位开始遍历\n    for (int i = maxLength-1; i >= 0; i--) {\n        baseSort(ints,i,maxLength);\n    }\n\n}\n\n\nprivate static void baseSort(int[] ints,int index,int maxLength){\n    // 固定10个桶\n    int[][] base = new int[10][0];\n    for (int i = 0; i < ints.length; i++) {\n        // 获取当前值在第几位上的数\n        int intIndex = getIntIndex(ints[i], index, maxLength);\n        // 放到对应的桶里去\n        base[intIndex] = appendBucket(base[intIndex],ints[i]);\n    }\n    // 再合并起来 此时不用再排序\n    int mainIndex = 0;\n    for (int[] ints1 : base) {\n        if(ints1.length<=0){\n            continue;\n        }\n        for (int i : ints1) {\n            ints[mainIndex] = i;\n            mainIndex++;\n        }\n    }\n}\n\n// 获取第几位的数\nprivate static int getIntIndex(int i,int index,int maxLength){\n    String s = String.valueOf(i);\n    int length = s.length();\n    if(length + index < maxLength){\n        return 0;\n    }\n    char c = s.charAt(index - maxLength + length);\n    return Integer.parseInt(String.valueOf(c));\n}\n\n// 获取最大数的长度\nprivate static int getMaxLength(int[] ints){\n    int max = ints[0];\n    for (int anInt : ints) {\n        if(anInt>max){\n            max = anInt;\n        }\n    }\n    return String.valueOf(max).length();\n}\n\n// 向数组中添加一个元素\npublic static int[] appendBucket(int[] bucket , int anInt){\n    int[] ints = Arrays.copyOf(bucket, bucket.length + 1);\n    ints[ints.length-1] = anInt;\n    return ints;\n}\n```\n\n\n#### 希尔排序\n\n- 拆分 -> 每组插入排序 -> 拆分 -> 每组插入排序 ...\n- 只到最终拆分成每组的间隔只有1\n\n```java\nprivate static void sort(int[] ints){\n    // 首先要进行分组 然后进行插入排序 间隔为长度 / 2 ... 一直到长度为1\n    for (int step = ints.length/2; step > 0 ; step /= 2) {\n        // 每次都进行一次插入排序\n        for (int i = step; i < ints.length; i++) {\n            // 当前值\n            int index = i;\n            for (int j = i-step; j >= 0 ; j-=step) {\n                if(ints[j]>ints[index]){\n                    swap(ints,index,j);\n                    index = j;\n                }else {\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n#### 快速排序\n\n- 找到一个基准值 然后设置左右两个指针，当左边的大于基准值、右边的小于基准值，则交换位置\n- 当左指针>=右指针时与基准值交换位置\n- 再分别重复基准值左边的部分和右边的部分，知道里面的拆分里面的元素只有一个\n\n```java\nprivate static void sort(int[] param,int left ,int right){\n    // 里面元素只有一个的时候结束递归\n    if(left>=right){\n        return;\n    }\n    // 找到基准值的位置\n    int partition = partition(param, left, right);\n    // 继续递归左边的数据\n    sort(param,left,partition-1);\n    // 继续递归右边的数据\n    sort(param,partition+1,right);\n}\n\n// 找基准值\nprivate static int partition(int[] param,int left ,int right){\n    // 直接以第一个为基准值\n    int pivot = param[left];\n    int index = left;\n    while (left<right){\n        while (right>left){\n            // 如果右边有值小于基准值 则交换位置\n            if(param[right] < pivot){\n                swap(right,index,param);\n                index = right;\n                left++;\n                break;\n            }\n            right--;\n        }\n        // 如果左边有值大于基准值 则与基准值交换位置\n        while (right>left){\n            if(param[left] > pivot){\n                swap(left,index,param);\n                index = left;\n                right--;\n                break;\n\n            }\n            left++;\n        }\n    }\n    // 返回基准值的位置\n    return index;\n}\n```\n\n#### 归并排序\n\n- 先将数组进行拆分，一直拆到只有一个元素\n- 再将数组进行合并，合并的时候进行排序\n\n```java\n\n// 先用递归进行拆分 知道里面只有一个元素为止\npublic static void sort(int[] ints,int left,int right){\n    int mid = (right+left) / 2;\n    if(left<right){\n        sort( ints, left, mid);\n        sort( ints, mid+1, right);\n        merge(ints ,left,mid,right);\n    }\n}\n\n// 开始进行合并\npublic static void merge(int[] ints,int left,int mid,int right){\n\n    // 构建一个临时数组 并记录左边的下标和右边的下标\n    int[] temp = new int[right-left+1];\n    int k = 0;\n    int i = left;\n    int j = mid+1;\n\n    // 左边和右边都有值的时候 直接比较 按顺序赋值\n    while (i<=mid && j<=right){\n        if(ints[i]<ints[j]){\n            temp[k] = ints[i];\n            i++;\n        }else {\n            temp[k] = ints[j];\n            j++;\n        }\n        k++;\n    }\n\n    // 只有左边有值 直接将左边的赋值过去\n    while (i<=mid){\n        temp[k] = ints[i];\n        i++;\n        k++;\n    }\n    // 只有右边有值 直接将右边的赋值过去\n    while (j<=right){\n        temp[k] = ints[j];\n        j++;\n        k++;\n    }\n\n    // 临时数组重新赋值回去\n    for (int i1 = 0; i1 < temp.length; i1++) {\n        ints[left+i1] = temp[i1];\n    }\n}\n```\n\n","slug":"排序","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bs003l9gj7qq1tglwv","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"总结常见的10中排序模型\"><a href=\"#总结常见的10中排序模型\" class=\"headerlink\" title=\"总结常见的10中排序模型\"></a>总结常见的10中排序模型</h3><p>本文主要汇总下常见的10中排序模型，用一张图概括如下：</p>\n<p><img src=\"https://image.tupelo.top/sort.png\" alt=\"时间复杂度与空间复杂度\"></p>\n<ul>\n<li>排序稳定性：相同元素的排序后顺序是否是固定的</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><ul>\n<li>两次循环，每个都和后面的数进行比较，如果当前数大于后面的数则交换位置。</li>\n<li>每循环一次，当前的最后的一个数为当次循环的最大数。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; ints.length-i-<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ints[j]&gt;ints[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    swap(ints,j,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><ul>\n<li>找到数组（0 - n）中的最大值，放到数组最后。</li>\n<li>在循环找到数组（0 - n-1）中的最大值，放到n-1的位置，如此循环知道最后完成。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minNum = ints[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ints[j] &lt; minNum)&#123;</span><br><span class=\"line\">                minNum = ints[j];</span><br><span class=\"line\">                index = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=index)&#123;</span><br><span class=\"line\">            swap(ints,i,index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><ul>\n<li>两层遍历，二层遍历遍历当前index前面的值，如果当前值小于前面的值，则交换位置</li>\n<li>知道前面的值小于等于当前值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span> ; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ints[index] &lt; ints[j])&#123;</span><br><span class=\"line\">                swap(ints,index,j);</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><ul>\n<li>将当前数组中的值转化为一个新数组的下标。</li>\n<li>新数组的值为当前下标在目标数组中的个数，新数组的大小为<code>最大值 - 最小值 + 1</code>。</li>\n<li>最后将新数组中的值按顺序重新复制到老数组中。</li>\n<li>如果最大值和最小值相差太多的，会存在空间浪费的情况。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找最大最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&gt;max)&#123;</span><br><span class=\"line\">            max = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&lt;min)&#123;</span><br><span class=\"line\">            min = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建新数组 大小为 max - min + 1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[max - min + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 将当前数组中的值存入到新数组中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : ints) &#123;</span><br><span class=\"line\">        temp[i-min]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新数组的值又重新赋值回去</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i1 = temp[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i1&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i2 = <span class=\"number\">0</span>; i2 &lt; i1; i2++) &#123;</span><br><span class=\"line\">                ints[index] = i+min;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4><ul>\n<li>将数组中的值按照大小分到固定几个桶中。</li>\n<li>将每个桶中的数据都分别进行排序(使用其它的排序算法，如插入排序)。</li>\n<li>最后将每个桶中的数据重新复制到原数组中。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// num 为桶的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查找数组中的最大最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&gt;max)&#123;</span><br><span class=\"line\">            max = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&lt;min)&#123;</span><br><span class=\"line\">            min = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不是根据个数，是根据数组中值的大小 计算桶的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count =  (max - min) / num + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] bucket = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[num][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 根据值的大小放到不同的桶中去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> anInt : ints) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (anInt - min) / count;</span><br><span class=\"line\">        bucket[index] = appendBucket(bucket[index],anInt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mainIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将每个桶进行排序 并赋值到原来的数组中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] ints1 : bucket) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints1.length&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 排序 此处使用插入排序 也可以用其它的排序方式</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints1.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i-<span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ints1[j]&gt;ints1[index])&#123;</span><br><span class=\"line\">                    swap(ints1,index,j);</span><br><span class=\"line\">                    index--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : ints1) &#123;</span><br><span class=\"line\">            ints[mainIndex] = i;</span><br><span class=\"line\">            mainIndex++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向数组中添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] appendBucket(<span class=\"keyword\">int</span>[] bucket , <span class=\"keyword\">int</span> anInt)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = Arrays.copyOf(bucket, bucket.length + <span class=\"number\">1</span>);</span><br><span class=\"line\">    ints[ints.length-<span class=\"number\">1</span>] = anInt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ints;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><ul>\n<li>按照数据的位数来排序，方式类型桶排序，只是桶中的数据不用再排序了。</li>\n<li>固定10个桶，编号0-9。</li>\n<li>从个、十、百…位开始遍历，位数比较小的补0。</li>\n<li>每次遍历将值放到对应位数的数字对应桶中，然后合并。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取最大的数的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLength = getMaxLength(ints);</span><br><span class=\"line\">    <span class=\"comment\">// 从个位开始遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maxLength-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        baseSort(ints,i,maxLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">baseSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> index,<span class=\"keyword\">int</span> maxLength)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 固定10个桶</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] base = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前值在第几位上的数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> intIndex = getIntIndex(ints[i], index, maxLength);</span><br><span class=\"line\">        <span class=\"comment\">// 放到对应的桶里去</span></span><br><span class=\"line\">        base[intIndex] = appendBucket(base[intIndex],ints[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 再合并起来 此时不用再排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mainIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] ints1 : base) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints1.length&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : ints1) &#123;</span><br><span class=\"line\">            ints[mainIndex] = i;</span><br><span class=\"line\">            mainIndex++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取第几位的数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getIntIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> index,<span class=\"keyword\">int</span> maxLength)</span></span>&#123;</span><br><span class=\"line\">    String s = String.valueOf(i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = s.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length + index &lt; maxLength)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = s.charAt(index - maxLength + length);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.parseInt(String.valueOf(c));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取最大数的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaxLength</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> anInt : ints) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(anInt&gt;max)&#123;</span><br><span class=\"line\">            max = anInt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> String.valueOf(max).length();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向数组中添加一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] appendBucket(<span class=\"keyword\">int</span>[] bucket , <span class=\"keyword\">int</span> anInt)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = Arrays.copyOf(bucket, bucket.length + <span class=\"number\">1</span>);</span><br><span class=\"line\">    ints[ints.length-<span class=\"number\">1</span>] = anInt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ints;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><ul>\n<li>拆分 -&gt; 每组插入排序 -&gt; 拆分 -&gt; 每组插入排序 …</li>\n<li>只到最终拆分成每组的间隔只有1</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先要进行分组 然后进行插入排序 间隔为长度 / 2 ... 一直到长度为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> step = ints.length/<span class=\"number\">2</span>; step &gt; <span class=\"number\">0</span> ; step /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次都进行一次插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = step; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i-step; j &gt;= <span class=\"number\">0</span> ; j-=step) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ints[j]&gt;ints[index])&#123;</span><br><span class=\"line\">                    swap(ints,index,j);</span><br><span class=\"line\">                    index = j;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><ul>\n<li>找到一个基准值 然后设置左右两个指针，当左边的大于基准值、右边的小于基准值，则交换位置</li>\n<li>当左指针&gt;=右指针时与基准值交换位置</li>\n<li>再分别重复基准值左边的部分和右边的部分，知道里面的拆分里面的元素只有一个</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] param,<span class=\"keyword\">int</span> left ,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 里面元素只有一个的时候结束递归</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left&gt;=right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 找到基准值的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> partition = partition(param, left, right);</span><br><span class=\"line\">    <span class=\"comment\">// 继续递归左边的数据</span></span><br><span class=\"line\">    sort(param,left,partition-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 继续递归右边的数据</span></span><br><span class=\"line\">    sort(param,partition+<span class=\"number\">1</span>,right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找基准值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] param,<span class=\"keyword\">int</span> left ,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接以第一个为基准值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot = param[left];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = left;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left&lt;right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right&gt;left)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果右边有值小于基准值 则交换位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(param[right] &lt; pivot)&#123;</span><br><span class=\"line\">                swap(right,index,param);</span><br><span class=\"line\">                index = right;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果左边有值大于基准值 则与基准值交换位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right&gt;left)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(param[left] &gt; pivot)&#123;</span><br><span class=\"line\">                swap(left,index,param);</span><br><span class=\"line\">                index = left;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回基准值的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><ul>\n<li>先将数组进行拆分，一直拆到只有一个元素</li>\n<li>再将数组进行合并，合并的时候进行排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 先用递归进行拆分 知道里面只有一个元素为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (right+left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left&lt;right)&#123;</span><br><span class=\"line\">        sort( ints, left, mid);</span><br><span class=\"line\">        sort( ints, mid+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">        merge(ints ,left,mid,right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始进行合并</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建一个临时数组 并记录左边的下标和右边的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[right-left+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = left;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 左边和右边都有值的时候 直接比较 按顺序赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&lt;ints[j])&#123;</span><br><span class=\"line\">            temp[k] = ints[i];</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            temp[k] = ints[j];</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 只有左边有值 直接将左边的赋值过去</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i&lt;=mid)&#123;</span><br><span class=\"line\">        temp[k] = ints[i];</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 只有右边有值 直接将右边的赋值过去</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j&lt;=right)&#123;</span><br><span class=\"line\">        temp[k] = ints[j];</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 临时数组重新赋值回去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i1 = <span class=\"number\">0</span>; i1 &lt; temp.length; i1++) &#123;</span><br><span class=\"line\">        ints[left+i1] = temp[i1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"总结常见的10中排序模型\"><a href=\"#总结常见的10中排序模型\" class=\"headerlink\" title=\"总结常见的10中排序模型\"></a>总结常见的10中排序模型</h3><p>本文主要汇总下常见的10中排序模型，用一张图概括如下：</p>\n<p><img src=\"https://image.tupelo.top/sort.png\" alt=\"时间复杂度与空间复杂度\"></p>\n<ul>\n<li>排序稳定性：相同元素的排序后顺序是否是固定的</li>\n</ul>","more":"<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><ul>\n<li>两次循环，每个都和后面的数进行比较，如果当前数大于后面的数则交换位置。</li>\n<li>每循环一次，当前的最后的一个数为当次循环的最大数。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; ints.length-i-<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ints[j]&gt;ints[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    swap(ints,j,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><ul>\n<li>找到数组（0 - n）中的最大值，放到数组最后。</li>\n<li>在循环找到数组（0 - n-1）中的最大值，放到n-1的位置，如此循环知道最后完成。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minNum = ints[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ints[j] &lt; minNum)&#123;</span><br><span class=\"line\">                minNum = ints[j];</span><br><span class=\"line\">                index = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=index)&#123;</span><br><span class=\"line\">            swap(ints,i,index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><ul>\n<li>两层遍历，二层遍历遍历当前index前面的值，如果当前值小于前面的值，则交换位置</li>\n<li>知道前面的值小于等于当前值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span> ; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ints[index] &lt; ints[j])&#123;</span><br><span class=\"line\">                swap(ints,index,j);</span><br><span class=\"line\">                index--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h4><ul>\n<li>将当前数组中的值转化为一个新数组的下标。</li>\n<li>新数组的值为当前下标在目标数组中的个数，新数组的大小为<code>最大值 - 最小值 + 1</code>。</li>\n<li>最后将新数组中的值按顺序重新复制到老数组中。</li>\n<li>如果最大值和最小值相差太多的，会存在空间浪费的情况。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找最大最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&gt;max)&#123;</span><br><span class=\"line\">            max = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&lt;min)&#123;</span><br><span class=\"line\">            min = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建新数组 大小为 max - min + 1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[max - min + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 将当前数组中的值存入到新数组中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : ints) &#123;</span><br><span class=\"line\">        temp[i-min]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新数组的值又重新赋值回去</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i1 = temp[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i1&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i2 = <span class=\"number\">0</span>; i2 &lt; i1; i2++) &#123;</span><br><span class=\"line\">                ints[index] = i+min;</span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h4><ul>\n<li>将数组中的值按照大小分到固定几个桶中。</li>\n<li>将每个桶中的数据都分别进行排序(使用其它的排序算法，如插入排序)。</li>\n<li>最后将每个桶中的数据重新复制到原数组中。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// num 为桶的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查找数组中的最大最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&gt;max)&#123;</span><br><span class=\"line\">            max = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&lt;min)&#123;</span><br><span class=\"line\">            min = ints[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不是根据个数，是根据数组中值的大小 计算桶的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count =  (max - min) / num + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] bucket = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[num][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 根据值的大小放到不同的桶中去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> anInt : ints) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (anInt - min) / count;</span><br><span class=\"line\">        bucket[index] = appendBucket(bucket[index],anInt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mainIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将每个桶进行排序 并赋值到原来的数组中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] ints1 : bucket) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints1.length&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 排序 此处使用插入排序 也可以用其它的排序方式</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints1.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i-<span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ints1[j]&gt;ints1[index])&#123;</span><br><span class=\"line\">                    swap(ints1,index,j);</span><br><span class=\"line\">                    index--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : ints1) &#123;</span><br><span class=\"line\">            ints[mainIndex] = i;</span><br><span class=\"line\">            mainIndex++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向数组中添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] appendBucket(<span class=\"keyword\">int</span>[] bucket , <span class=\"keyword\">int</span> anInt)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = Arrays.copyOf(bucket, bucket.length + <span class=\"number\">1</span>);</span><br><span class=\"line\">    ints[ints.length-<span class=\"number\">1</span>] = anInt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ints;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><ul>\n<li>按照数据的位数来排序，方式类型桶排序，只是桶中的数据不用再排序了。</li>\n<li>固定10个桶，编号0-9。</li>\n<li>从个、十、百…位开始遍历，位数比较小的补0。</li>\n<li>每次遍历将值放到对应位数的数字对应桶中，然后合并。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取最大的数的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxLength = getMaxLength(ints);</span><br><span class=\"line\">    <span class=\"comment\">// 从个位开始遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maxLength-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        baseSort(ints,i,maxLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">baseSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> index,<span class=\"keyword\">int</span> maxLength)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 固定10个桶</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] base = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前值在第几位上的数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> intIndex = getIntIndex(ints[i], index, maxLength);</span><br><span class=\"line\">        <span class=\"comment\">// 放到对应的桶里去</span></span><br><span class=\"line\">        base[intIndex] = appendBucket(base[intIndex],ints[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 再合并起来 此时不用再排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mainIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] ints1 : base) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints1.length&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : ints1) &#123;</span><br><span class=\"line\">            ints[mainIndex] = i;</span><br><span class=\"line\">            mainIndex++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取第几位的数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getIntIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> index,<span class=\"keyword\">int</span> maxLength)</span></span>&#123;</span><br><span class=\"line\">    String s = String.valueOf(i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = s.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length + index &lt; maxLength)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = s.charAt(index - maxLength + length);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.parseInt(String.valueOf(c));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取最大数的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaxLength</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> anInt : ints) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(anInt&gt;max)&#123;</span><br><span class=\"line\">            max = anInt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> String.valueOf(max).length();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向数组中添加一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] appendBucket(<span class=\"keyword\">int</span>[] bucket , <span class=\"keyword\">int</span> anInt)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = Arrays.copyOf(bucket, bucket.length + <span class=\"number\">1</span>);</span><br><span class=\"line\">    ints[ints.length-<span class=\"number\">1</span>] = anInt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ints;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><ul>\n<li>拆分 -&gt; 每组插入排序 -&gt; 拆分 -&gt; 每组插入排序 …</li>\n<li>只到最终拆分成每组的间隔只有1</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先要进行分组 然后进行插入排序 间隔为长度 / 2 ... 一直到长度为1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> step = ints.length/<span class=\"number\">2</span>; step &gt; <span class=\"number\">0</span> ; step /= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次都进行一次插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = step; i &lt; ints.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前值</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i-step; j &gt;= <span class=\"number\">0</span> ; j-=step) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ints[j]&gt;ints[index])&#123;</span><br><span class=\"line\">                    swap(ints,index,j);</span><br><span class=\"line\">                    index = j;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><ul>\n<li>找到一个基准值 然后设置左右两个指针，当左边的大于基准值、右边的小于基准值，则交换位置</li>\n<li>当左指针&gt;=右指针时与基准值交换位置</li>\n<li>再分别重复基准值左边的部分和右边的部分，知道里面的拆分里面的元素只有一个</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] param,<span class=\"keyword\">int</span> left ,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 里面元素只有一个的时候结束递归</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left&gt;=right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 找到基准值的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> partition = partition(param, left, right);</span><br><span class=\"line\">    <span class=\"comment\">// 继续递归左边的数据</span></span><br><span class=\"line\">    sort(param,left,partition-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 继续递归右边的数据</span></span><br><span class=\"line\">    sort(param,partition+<span class=\"number\">1</span>,right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找基准值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] param,<span class=\"keyword\">int</span> left ,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接以第一个为基准值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pivot = param[left];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = left;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left&lt;right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right&gt;left)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果右边有值小于基准值 则交换位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(param[right] &lt; pivot)&#123;</span><br><span class=\"line\">                swap(right,index,param);</span><br><span class=\"line\">                index = right;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果左边有值大于基准值 则与基准值交换位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right&gt;left)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(param[left] &gt; pivot)&#123;</span><br><span class=\"line\">                swap(left,index,param);</span><br><span class=\"line\">                index = left;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回基准值的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><ul>\n<li>先将数组进行拆分，一直拆到只有一个元素</li>\n<li>再将数组进行合并，合并的时候进行排序</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 先用递归进行拆分 知道里面只有一个元素为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (right+left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left&lt;right)&#123;</span><br><span class=\"line\">        sort( ints, left, mid);</span><br><span class=\"line\">        sort( ints, mid+<span class=\"number\">1</span>, right);</span><br><span class=\"line\">        merge(ints ,left,mid,right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始进行合并</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ints,<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> right)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建一个临时数组 并记录左边的下标和右边的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[right-left+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = left;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 左边和右边都有值的时候 直接比较 按顺序赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ints[i]&lt;ints[j])&#123;</span><br><span class=\"line\">            temp[k] = ints[i];</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            temp[k] = ints[j];</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 只有左边有值 直接将左边的赋值过去</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i&lt;=mid)&#123;</span><br><span class=\"line\">        temp[k] = ints[i];</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 只有右边有值 直接将右边的赋值过去</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j&lt;=right)&#123;</span><br><span class=\"line\">        temp[k] = ints[j];</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 临时数组重新赋值回去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i1 = <span class=\"number\">0</span>; i1 &lt; temp.length; i1++) &#123;</span><br><span class=\"line\">        ints[left+i1] = temp[i1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"正则表达式","_content":"\n正则表达式\n\n### 什么是正则表达式？\n\n> 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n\n<!-- more -->\n\n### 基本匹配\n\n大小写区分\n\n```python\nimport re\n# 从hello world 中匹配hello\nresult = re.match('hello','hello world').group()\nprint(result)\n```\n\n### 元字符\n\n|元字符|描述|\n|:----:|----|\n|.|句号匹配任意单个字符除了换行符.|\n|[ ]|字符种类. 匹配方括号内的任意字符.|\n|[^ ]|否定的字符种类. 匹配除了方括号里的任意字符|\n|*|匹配>=0个重复的在*号之前的字符.|\n|+|匹配>1个重复的+号前的字符.\n|?|标记?之前的字符为可选.|\n|{ n,m }|匹配num个中括号之前的字符 (n <= num <= m).|\n|(xyz)|字符集, 匹配与 xyz 完全相等的字符串.|\n|&#124;|或运算符,匹配符号前或后的字符.|\n|&#92;|转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \\ &#124;</code>|\n|^|从开始行开始匹配.|\n|$|从末端开始匹配.|\n\n\n#### 2.1 点运算符 `.`\n\n`.`是元字符中最简单的例子. `.`匹配任意单个字符, 但不匹配换行符.\n\n```python\nimport re\nresult = re.findall(r'.l','hello world')\nprint(result)\n```\n\n#### 2.2 字符集\n\n字符集也叫做字符类.\n方括号用来指定一个字符集.\n在方括号中使用连字符来指定字符集的范围.\n在方括号中的字符集不关心顺序.\n\n```python\nimport re\nresult = re.findall(r'[Th]','The')\nprint(result)\n```\n\n方括号的句号就表示句号. 表达式 `ar[.]` 匹配 `ar.`字符串\n\n\n##### 2.2.1 否定字符集\n\n一般来说 `^` 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.\n例如, 表达式`[^c]ar` 匹配一个后面跟着`ar`的除了`c`的任意字符.\n\n```python\ns = 'carparmar'\nprint(re.findall(r'[^p]ar',s))\n```\n\n#### 2.3 重复次数\n\n后面跟着元字符 `+`, `*` or `?` 的, 用来指定匹配子模式的次数. \n这些元字符在不同的情况下有着不同的意思.\n\n##### 2.3.1 `*` 号\n\n`*`号匹配 在`*`之前的字符出现`大于等于0`次.\n例如, 表达式 `a*` 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式`[a-z]*` 匹配一个行中所有以小写字母开头的字符串.\n\n```python\ns = 'carparmar'\nprint(re.search(r'.*ar',s).group())\n```\n\n`*`字符和`.`字符搭配可以匹配所有的字符`.*`.\n`*`和表示匹配空格的符号`\\s`连起来用, 如表达式`\\s*cat\\s*`匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.\n\n\n##### 2.3.2 `+` 号\n\n`+`号匹配`+`号之前的字符出现 >=1 次个字符.\n例如表达式`c.+t` 匹配以首字母`c`开头以`t`结尾,中间跟着任意个字符的字符串.\n\n```python\ns = 'carparmar'\nprint(re.search(r'.+ar',s).group())\n```\n\n##### 2.3.3 `?` 号\n\n在正则表达式中元字符 `?` 标记在符号前面的字符为可选, 即出现 0 或 1 次.\n\n```python\ns = 'carparmar'\nprint(re.search(r'.*?ar',s).group())\n```\n\n#### 2.4 `{}` 号\n\n在正则表达式中 `{}` 是一个量词, 常用来一个或一组字符可以重复出现的次数.\n\n我们可以省略第二个参数.\n例如, `[0-9]{2,}` 匹配至少两位 0~9 的数字.\n\n如果逗号也省略掉则表示重复固定的次数. \n例如, `[0-9]{3}` 匹配3位数字\n\n```python\ns = 'carparmar'\nprint(re.search(r'([cpm]ar){1,2}',s).group())\n```\n\n#### 2.5 `(...)` 特征标群\n\n特征标群是一组写在 `(...)` 中的子模式. 例如之前说的 `{}` 是用来表示前面一个字符出现指定次数. 但如果在 `{}` 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 `(ab)*` 匹配连续出现 0 或更多个 `ab`.\n\n我们还可以在 `()` 中用或字符 `|` 表示或. 例如, `(c|g|p)ar` 匹配 `car` 或 `gar` 或 `par`.\n\n```python\ns = 'carparmar'\nprint(re.search(r'((c|p|m)ar){1,2}',s).group())\n```\n\n#### 2.6 `|` 或运算符\n\n或运算符就表示或, 用作判断条件.\n\n例如 `(T|t)he|car` 匹配 `(T|t)he` 或 `car`.\n\n```python\ns = 'carparmar'\nprint(re.search(r'((c|p|m)ar){1,3}$',s).group())\n```\n\n#### 2.7 转码特殊字符\n\n反斜线 `\\` 在表达式中用于转码紧跟其后的字符. 用于指定 `{ } [ ] / \\ + * . $ ^ | ?` 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 `\\`.\n\n例如 `.` 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 `.` 则要写成 `\\.`.\n\n<pre>\n\"(f|c|m)at\\.?\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> sat on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n#### 2.8 锚点\n\n在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. `^` 指定开头, `$` 指定结尾.\n\n##### 2.8.1 `^` 号\n\n`^` 用来检查匹配的字符串是否在所匹配字符串的开头.\n\n例如, 在 `abc` 中使用表达式 `^a` 会得到结果 `a`. 但如果使用 `^b` 将匹配不到任何结果. 应为在字符串 `abc` 中并不是以 `b` 开头.\n\n例如, `^(T|t)he` 匹配以 `The` 或 `the` 开头的字符串.\n\n<pre>\n\"(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<pre>\n\"^(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n##### 2.8.2 `$` 号\n\n同理于 `^` 号, `$` 号用来匹配字符是否是最后一个.\n\n例如, `(at\\.)$` 匹配以 `at.` 结尾的字符串.\n\n<pre>\n\"(at\\.)\" => The fat c<a href=\"#learn-regex\"><strong>at.</strong></a> s<a href=\"#learn-regex\"><strong>at.</strong></a> on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<pre>\n\"(at\\.)$\" => The fat cat. sat. on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n###  3. 简写字符集\n\n正则表达式提供一些常用的字符集简写. 如下:\n\n|简写|描述|\n|:----:|----|\n|.|除换行符外的所有字符|\n|\\w|匹配所有字母数字, 等同于 `[a-zA-Z0-9_]`|\n|\\W|匹配所有非字母数字, 即符号, 等同于: `[^\\w]`|\n|\\d|匹配数字: `[0-9]`|\n|\\D|匹配非数字: `[^\\d]`|\n|\\s|匹配所有空格字符, 等同于: `[\\t\\n\\f\\r\\p{Z}]`|\n|\\S|匹配所有非空格字符: `[^\\s]`|\n\n### 4. 前后关联约束(前后预查)\n\n前置约束和后置约束都属于**非捕获簇**(用于匹配不在匹配列表中的格式).\n前置约束用于判断所匹配的格式是否在另一个确定的格式之后.\n\n例如, 我们想要获得所有跟在 `$` 符号后的数字, 我们可以使用正向向后约束 `(?<=\\$)[0-9\\.]*`.\n这个表达式匹配 `$` 开头, 之后跟着 `0,1,2,3,4,5,6,7,8,9,.` 这些字符可以出现大于等于 0 次.\n\n前后关联约束如下:\n\n|符号|描述|\n|:----:|----|\n|?=|前置约束-存在|\n|?!|前置约束-排除|\n|?<=|后置约束-存在|\n|?<!|后置约束-排除|\n\n#### 4.1 `?=...` 前置约束(存在)\n\n`?=...` 前置约束(存在), 表示第一部分表达式必须跟在 `?=...`定义的表达式之后.\n\n返回结果只瞒住第一部分表达式.\n定义一个前置约束(存在)要使用 `()`. 在括号内部使用一个问号和等号: `(?=...)`. \n\n前置约束的内容写在括号中的等号后面.\n例如, 表达式 `[T|t]he(?=\\sfat)` 匹配 `The` 和 `the`, 在括号中我们又定义了前置约束(存在) `(?=\\sfat)` ,即 `The` 和 `the` 后面紧跟着 `(空格)fat`.\n\n```python\ns = 'the fat the mat'\nprint(re.findall(r'the(?=\\sfat)',s))\n```\n\n\n#### 4.2 `?!...` 前置约束-排除\n\n前置约束-排除 `?!` 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式\n`前置约束-排除`  定义和 `前置约束(存在)` 一样, 区别就是 `=` 替换成 `!` 也就是 `(?!...)`. \n\n表达式 `[T|t]he(?!\\sfat)` 匹配 `The` 和 `the`, 且其后不跟着 `(空格)fat`.\n\n```python\ns = 'the fat the mat'\nprint(re.findall(r'the(?!\\sfat)',s))\n```\n\n\n#### 4.3 `?<= ...` 后置约束-存在\n\n后置约束-存在 记作`(?<=...)` 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.\n例如, 表达式 `(?<=[T|t]he\\s)(fat|mat)` 匹配 `fat` 和 `mat`, 且其前跟着 `The` 或 `the`.\n\n```python\ns = 'the fat hasd fat asd mat the mat'\nprint(re.findall(r'(?<=the\\s)(fat|mat)',s))\n```\n\n\n#### 4.4 `?<!...` 后置约束-排除\n\n后置约束-排除 记作 `(?<!...)` 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.\n例如, 表达式 `(?<!(T|t)he\\s)(cat)` 匹配 `cat`, 且其前不跟着 `The` 或 `the`.\n\n```python\ns = 'the fat hasd fat the mat'\nprint(re.findall(r'(?<!the\\s)(fat|mat)',s))\n```\n\n\n### 5. 标志\n\n标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.\n这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.\n\n|标志|描述|\n|:----:|----|\n|i|忽略大小写.|\n|g|全局搜索.|\n|m|多行的: 锚点元字符 `^` `$` 工作范围在每行的起始.|\n\n#### 5.1 忽略大小写 (Case Insensitive)\n\n修饰语 `i` 用于忽略大小写.\n例如, 表达式 `/The/gi` 表示在全局搜索 `The`, 在后面的 `i` 将其条件修改为忽略大小写, 则变成搜索 `the` 和 `The`, `g` 表示全局搜索.\n\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/The/gi\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n\n#### 5.2 全局搜索 (Global search)\n\n修饰符 `g` 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). \n例如, 表达式 `/.(at)/g` 表示搜索 任意字符(除了换行) + `at`, 并返回全部结果.\n\n<pre>\n\"/.(at)/\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/.(at)/g\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> <a href=\"#learn-regex\"><strong>sat</strong></a> on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n\n#### 5.3 多行修饰符 (Multiline)\n\n多行修饰符 `m` 常用于执行一个多行匹配.\n\n像之前介绍的 `(^,$)` 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 `m`.\n\n例如, 表达式 `/at(.)?$/gm` 表示在待检测字符串每行的末尾搜索 `at`后跟一个或多个 `.` 的字符串, 并返回全部结果.\n\n<pre>\n\"/.at(.)?$/\" => The fat\n                cat sat\n                on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n<pre>\n\"/.at(.)?$/gm\" => The <a href=\"#learn-regex\"><strong>fat</strong></a>\n                  cat <a href=\"#learn-regex\"><strong>sat</strong></a>\n                  on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n#### 额外补充\n\n* *正整数*: `^\\d+$`\n* *负整数*: `^-\\d+$`\n* *手机国家号*: `^+?[\\d\\s]{3,}$`\n* *手机号*: `^+?[\\d\\s]+(?[\\d\\s]{10,}$`\n* *整数*: `^-?\\d+$`\n* *用户名*: `^[\\w\\d_.]{4,16}$`\n* *数字和英文字母*: `^[a-zA-Z0-9]*$`\n* *数字和应为字母和空格*: `^[a-zA-Z0-9 ]*$`\n* *密码*: `^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$`\n* *邮箱*: `^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4})*$`\n* *IP4 地址*: `^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$`\n* *纯小写字母*: `^([a-z])*$`\n* *纯大写字母*: `^([A-Z])*$`\n* *URL*: `^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\\/+=%&_\\.~?\\-]*))*$`\n* *VISA 信用卡号*: `^(4[0-9]{12}(?:[0-9]{3})?)*$`\n* *日期 (MM/DD/YYYY)*: `^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$`\n* *日期 (YYYY/MM/DD)*: `^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$`\n* *MasterCard 信用卡号*: `^(5[1-5][0-9]{14})*$`\n\n","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ntags:\n  - 正则表达式\n---\n\n正则表达式\n\n### 什么是正则表达式？\n\n> 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n\n<!-- more -->\n\n### 基本匹配\n\n大小写区分\n\n```python\nimport re\n# 从hello world 中匹配hello\nresult = re.match('hello','hello world').group()\nprint(result)\n```\n\n### 元字符\n\n|元字符|描述|\n|:----:|----|\n|.|句号匹配任意单个字符除了换行符.|\n|[ ]|字符种类. 匹配方括号内的任意字符.|\n|[^ ]|否定的字符种类. 匹配除了方括号里的任意字符|\n|*|匹配>=0个重复的在*号之前的字符.|\n|+|匹配>1个重复的+号前的字符.\n|?|标记?之前的字符为可选.|\n|{ n,m }|匹配num个中括号之前的字符 (n <= num <= m).|\n|(xyz)|字符集, 匹配与 xyz 完全相等的字符串.|\n|&#124;|或运算符,匹配符号前或后的字符.|\n|&#92;|转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \\ &#124;</code>|\n|^|从开始行开始匹配.|\n|$|从末端开始匹配.|\n\n\n#### 2.1 点运算符 `.`\n\n`.`是元字符中最简单的例子. `.`匹配任意单个字符, 但不匹配换行符.\n\n```python\nimport re\nresult = re.findall(r'.l','hello world')\nprint(result)\n```\n\n#### 2.2 字符集\n\n字符集也叫做字符类.\n方括号用来指定一个字符集.\n在方括号中使用连字符来指定字符集的范围.\n在方括号中的字符集不关心顺序.\n\n```python\nimport re\nresult = re.findall(r'[Th]','The')\nprint(result)\n```\n\n方括号的句号就表示句号. 表达式 `ar[.]` 匹配 `ar.`字符串\n\n\n##### 2.2.1 否定字符集\n\n一般来说 `^` 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.\n例如, 表达式`[^c]ar` 匹配一个后面跟着`ar`的除了`c`的任意字符.\n\n```python\ns = 'carparmar'\nprint(re.findall(r'[^p]ar',s))\n```\n\n#### 2.3 重复次数\n\n后面跟着元字符 `+`, `*` or `?` 的, 用来指定匹配子模式的次数. \n这些元字符在不同的情况下有着不同的意思.\n\n##### 2.3.1 `*` 号\n\n`*`号匹配 在`*`之前的字符出现`大于等于0`次.\n例如, 表达式 `a*` 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式`[a-z]*` 匹配一个行中所有以小写字母开头的字符串.\n\n```python\ns = 'carparmar'\nprint(re.search(r'.*ar',s).group())\n```\n\n`*`字符和`.`字符搭配可以匹配所有的字符`.*`.\n`*`和表示匹配空格的符号`\\s`连起来用, 如表达式`\\s*cat\\s*`匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.\n\n\n##### 2.3.2 `+` 号\n\n`+`号匹配`+`号之前的字符出现 >=1 次个字符.\n例如表达式`c.+t` 匹配以首字母`c`开头以`t`结尾,中间跟着任意个字符的字符串.\n\n```python\ns = 'carparmar'\nprint(re.search(r'.+ar',s).group())\n```\n\n##### 2.3.3 `?` 号\n\n在正则表达式中元字符 `?` 标记在符号前面的字符为可选, 即出现 0 或 1 次.\n\n```python\ns = 'carparmar'\nprint(re.search(r'.*?ar',s).group())\n```\n\n#### 2.4 `{}` 号\n\n在正则表达式中 `{}` 是一个量词, 常用来一个或一组字符可以重复出现的次数.\n\n我们可以省略第二个参数.\n例如, `[0-9]{2,}` 匹配至少两位 0~9 的数字.\n\n如果逗号也省略掉则表示重复固定的次数. \n例如, `[0-9]{3}` 匹配3位数字\n\n```python\ns = 'carparmar'\nprint(re.search(r'([cpm]ar){1,2}',s).group())\n```\n\n#### 2.5 `(...)` 特征标群\n\n特征标群是一组写在 `(...)` 中的子模式. 例如之前说的 `{}` 是用来表示前面一个字符出现指定次数. 但如果在 `{}` 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 `(ab)*` 匹配连续出现 0 或更多个 `ab`.\n\n我们还可以在 `()` 中用或字符 `|` 表示或. 例如, `(c|g|p)ar` 匹配 `car` 或 `gar` 或 `par`.\n\n```python\ns = 'carparmar'\nprint(re.search(r'((c|p|m)ar){1,2}',s).group())\n```\n\n#### 2.6 `|` 或运算符\n\n或运算符就表示或, 用作判断条件.\n\n例如 `(T|t)he|car` 匹配 `(T|t)he` 或 `car`.\n\n```python\ns = 'carparmar'\nprint(re.search(r'((c|p|m)ar){1,3}$',s).group())\n```\n\n#### 2.7 转码特殊字符\n\n反斜线 `\\` 在表达式中用于转码紧跟其后的字符. 用于指定 `{ } [ ] / \\ + * . $ ^ | ?` 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 `\\`.\n\n例如 `.` 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 `.` 则要写成 `\\.`.\n\n<pre>\n\"(f|c|m)at\\.?\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> sat on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n#### 2.8 锚点\n\n在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. `^` 指定开头, `$` 指定结尾.\n\n##### 2.8.1 `^` 号\n\n`^` 用来检查匹配的字符串是否在所匹配字符串的开头.\n\n例如, 在 `abc` 中使用表达式 `^a` 会得到结果 `a`. 但如果使用 `^b` 将匹配不到任何结果. 应为在字符串 `abc` 中并不是以 `b` 开头.\n\n例如, `^(T|t)he` 匹配以 `The` 或 `the` 开头的字符串.\n\n<pre>\n\"(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<pre>\n\"^(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n##### 2.8.2 `$` 号\n\n同理于 `^` 号, `$` 号用来匹配字符是否是最后一个.\n\n例如, `(at\\.)$` 匹配以 `at.` 结尾的字符串.\n\n<pre>\n\"(at\\.)\" => The fat c<a href=\"#learn-regex\"><strong>at.</strong></a> s<a href=\"#learn-regex\"><strong>at.</strong></a> on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<pre>\n\"(at\\.)$\" => The fat cat. sat. on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n###  3. 简写字符集\n\n正则表达式提供一些常用的字符集简写. 如下:\n\n|简写|描述|\n|:----:|----|\n|.|除换行符外的所有字符|\n|\\w|匹配所有字母数字, 等同于 `[a-zA-Z0-9_]`|\n|\\W|匹配所有非字母数字, 即符号, 等同于: `[^\\w]`|\n|\\d|匹配数字: `[0-9]`|\n|\\D|匹配非数字: `[^\\d]`|\n|\\s|匹配所有空格字符, 等同于: `[\\t\\n\\f\\r\\p{Z}]`|\n|\\S|匹配所有非空格字符: `[^\\s]`|\n\n### 4. 前后关联约束(前后预查)\n\n前置约束和后置约束都属于**非捕获簇**(用于匹配不在匹配列表中的格式).\n前置约束用于判断所匹配的格式是否在另一个确定的格式之后.\n\n例如, 我们想要获得所有跟在 `$` 符号后的数字, 我们可以使用正向向后约束 `(?<=\\$)[0-9\\.]*`.\n这个表达式匹配 `$` 开头, 之后跟着 `0,1,2,3,4,5,6,7,8,9,.` 这些字符可以出现大于等于 0 次.\n\n前后关联约束如下:\n\n|符号|描述|\n|:----:|----|\n|?=|前置约束-存在|\n|?!|前置约束-排除|\n|?<=|后置约束-存在|\n|?<!|后置约束-排除|\n\n#### 4.1 `?=...` 前置约束(存在)\n\n`?=...` 前置约束(存在), 表示第一部分表达式必须跟在 `?=...`定义的表达式之后.\n\n返回结果只瞒住第一部分表达式.\n定义一个前置约束(存在)要使用 `()`. 在括号内部使用一个问号和等号: `(?=...)`. \n\n前置约束的内容写在括号中的等号后面.\n例如, 表达式 `[T|t]he(?=\\sfat)` 匹配 `The` 和 `the`, 在括号中我们又定义了前置约束(存在) `(?=\\sfat)` ,即 `The` 和 `the` 后面紧跟着 `(空格)fat`.\n\n```python\ns = 'the fat the mat'\nprint(re.findall(r'the(?=\\sfat)',s))\n```\n\n\n#### 4.2 `?!...` 前置约束-排除\n\n前置约束-排除 `?!` 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式\n`前置约束-排除`  定义和 `前置约束(存在)` 一样, 区别就是 `=` 替换成 `!` 也就是 `(?!...)`. \n\n表达式 `[T|t]he(?!\\sfat)` 匹配 `The` 和 `the`, 且其后不跟着 `(空格)fat`.\n\n```python\ns = 'the fat the mat'\nprint(re.findall(r'the(?!\\sfat)',s))\n```\n\n\n#### 4.3 `?<= ...` 后置约束-存在\n\n后置约束-存在 记作`(?<=...)` 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.\n例如, 表达式 `(?<=[T|t]he\\s)(fat|mat)` 匹配 `fat` 和 `mat`, 且其前跟着 `The` 或 `the`.\n\n```python\ns = 'the fat hasd fat asd mat the mat'\nprint(re.findall(r'(?<=the\\s)(fat|mat)',s))\n```\n\n\n#### 4.4 `?<!...` 后置约束-排除\n\n后置约束-排除 记作 `(?<!...)` 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.\n例如, 表达式 `(?<!(T|t)he\\s)(cat)` 匹配 `cat`, 且其前不跟着 `The` 或 `the`.\n\n```python\ns = 'the fat hasd fat the mat'\nprint(re.findall(r'(?<!the\\s)(fat|mat)',s))\n```\n\n\n### 5. 标志\n\n标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.\n这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.\n\n|标志|描述|\n|:----:|----|\n|i|忽略大小写.|\n|g|全局搜索.|\n|m|多行的: 锚点元字符 `^` `$` 工作范围在每行的起始.|\n\n#### 5.1 忽略大小写 (Case Insensitive)\n\n修饰语 `i` 用于忽略大小写.\n例如, 表达式 `/The/gi` 表示在全局搜索 `The`, 在后面的 `i` 将其条件修改为忽略大小写, 则变成搜索 `the` 和 `The`, `g` 表示全局搜索.\n\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/The/gi\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n\n#### 5.2 全局搜索 (Global search)\n\n修饰符 `g` 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部). \n例如, 表达式 `/.(at)/g` 表示搜索 任意字符(除了换行) + `at`, 并返回全部结果.\n\n<pre>\n\"/.(at)/\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/.(at)/g\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> <a href=\"#learn-regex\"><strong>sat</strong></a> on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n\n#### 5.3 多行修饰符 (Multiline)\n\n多行修饰符 `m` 常用于执行一个多行匹配.\n\n像之前介绍的 `(^,$)` 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 `m`.\n\n例如, 表达式 `/at(.)?$/gm` 表示在待检测字符串每行的末尾搜索 `at`后跟一个或多个 `.` 的字符串, 并返回全部结果.\n\n<pre>\n\"/.at(.)?$/\" => The fat\n                cat sat\n                on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n<pre>\n\"/.at(.)?$/gm\" => The <a href=\"#learn-regex\"><strong>fat</strong></a>\n                  cat <a href=\"#learn-regex\"><strong>sat</strong></a>\n                  on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n#### 额外补充\n\n* *正整数*: `^\\d+$`\n* *负整数*: `^-\\d+$`\n* *手机国家号*: `^+?[\\d\\s]{3,}$`\n* *手机号*: `^+?[\\d\\s]+(?[\\d\\s]{10,}$`\n* *整数*: `^-?\\d+$`\n* *用户名*: `^[\\w\\d_.]{4,16}$`\n* *数字和英文字母*: `^[a-zA-Z0-9]*$`\n* *数字和应为字母和空格*: `^[a-zA-Z0-9 ]*$`\n* *密码*: `^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$`\n* *邮箱*: `^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4})*$`\n* *IP4 地址*: `^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$`\n* *纯小写字母*: `^([a-z])*$`\n* *纯大写字母*: `^([A-Z])*$`\n* *URL*: `^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\\/+=%&_\\.~?\\-]*))*$`\n* *VISA 信用卡号*: `^(4[0-9]{12}(?:[0-9]{3})?)*$`\n* *日期 (MM/DD/YYYY)*: `^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$`\n* *日期 (YYYY/MM/DD)*: `^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$`\n* *MasterCard 信用卡号*: `^(5[1-5][0-9]{14})*$`\n\n","slug":"正则表达式","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bt003m9gj788gz8sol","comments":1,"layout":"post","photos":[],"link":"","content":"<p>正则表达式</p>\n<h3 id=\"什么是正则表达式？\"><a href=\"#什么是正则表达式？\" class=\"headerlink\" title=\"什么是正则表达式？\"></a>什么是正则表达式？</h3><blockquote>\n<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"基本匹配\"><a href=\"#基本匹配\" class=\"headerlink\" title=\"基本匹配\"></a>基本匹配</h3><p>大小写区分</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"comment\"># 从hello world 中匹配hello</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">'hello'</span>,<span class=\"string\">'hello world'</span>).group()</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td>句号匹配任意单个字符除了换行符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[ ]</td>\n<td>字符种类. 匹配方括号内的任意字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^ ]</td>\n<td>否定的字符种类. 匹配除了方括号里的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td>匹配&gt;=0个重复的在*号之前的字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td>匹配&gt;1个重复的+号前的字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td>标记?之前的字符为可选.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{ n,m }</td>\n<td>匹配num个中括号之前的字符 (n &lt;= num &lt;= m).</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(xyz)</td>\n<td>字符集, 匹配与 xyz 完全相等的字符串.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&#124;</td>\n<td>或运算符,匹配符号前或后的字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&#92;</td>\n<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \\ &#124;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td>从开始行开始匹配.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td>从末端开始匹配.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-1-点运算符\"><a href=\"#2-1-点运算符\" class=\"headerlink\" title=\"2.1 点运算符 .\"></a>2.1 点运算符 <code>.</code></h4><p><code>.</code>是元字符中最简单的例子. <code>.</code>匹配任意单个字符, 但不匹配换行符.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">result = re.findall(<span class=\"string\">r'.l'</span>,<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-字符集\"><a href=\"#2-2-字符集\" class=\"headerlink\" title=\"2.2 字符集\"></a>2.2 字符集</h4><p>字符集也叫做字符类.<br>方括号用来指定一个字符集.<br>在方括号中使用连字符来指定字符集的范围.<br>在方括号中的字符集不关心顺序.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">result = re.findall(<span class=\"string\">r'[Th]'</span>,<span class=\"string\">'The'</span>)</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n<p>方括号的句号就表示句号. 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>\n<h5 id=\"2-2-1-否定字符集\"><a href=\"#2-2-1-否定字符集\" class=\"headerlink\" title=\"2.2.1 否定字符集\"></a>2.2.1 否定字符集</h5><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'[^p]ar'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-重复次数\"><a href=\"#2-3-重复次数\" class=\"headerlink\" title=\"2.3 重复次数\"></a>2.3 重复次数</h4><p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数.<br>这些元字符在不同的情况下有着不同的意思.</p>\n<h5 id=\"2-3-1-号\"><a href=\"#2-3-1-号\" class=\"headerlink\" title=\"2.3.1 * 号\"></a>2.3.1 <code>*</code> 号</h5><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br>例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'.*ar'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br><code>*</code>和表示匹配空格的符号<code>\\s</code>连起来用, 如表达式<code>\\s*cat\\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p>\n<h5 id=\"2-3-2-号\"><a href=\"#2-3-2-号\" class=\"headerlink\" title=\"2.3.2 + 号\"></a>2.3.2 <code>+</code> 号</h5><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次个字符.<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'.+ar'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-3-号\"><a href=\"#2-3-3-号\" class=\"headerlink\" title=\"2.3.3 ? 号\"></a>2.3.3 <code>?</code> 号</h5><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'.*?ar'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-号\"><a href=\"#2-4-号\" class=\"headerlink\" title=\"2.4 {} 号\"></a>2.4 <code>{}</code> 号</h4><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.</p>\n<p>我们可以省略第二个参数.<br>例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>\n<p>如果逗号也省略掉则表示重复固定的次数.<br>例如, <code>[0-9]{3}</code> 匹配3位数字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'([cpm]ar)&#123;1,2&#125;'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-特征标群\"><a href=\"#2-5-特征标群\" class=\"headerlink\" title=\"2.5 (...) 特征标群\"></a>2.5 <code>(...)</code> 特征标群</h4><p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p>\n<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'((c|p|m)ar)&#123;1,2&#125;'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-6-或运算符\"><a href=\"#2-6-或运算符\" class=\"headerlink\" title=\"2.6 | 或运算符\"></a>2.6 <code>|</code> 或运算符</h4><p>或运算符就表示或, 用作判断条件.</p>\n<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'((c|p|m)ar)&#123;1,3&#125;$'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-7-转码特殊字符\"><a href=\"#2-7-转码特殊字符\" class=\"headerlink\" title=\"2.7 转码特殊字符\"></a>2.7 转码特殊字符</h4><p>反斜线 <code>\\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\\</code>.</p>\n<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\\.</code>.</p>\n<pre>\n\"(f|c|m)at\\.?\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> sat on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n<h4 id=\"2-8-锚点\"><a href=\"#2-8-锚点\" class=\"headerlink\" title=\"2.8 锚点\"></a>2.8 锚点</h4><p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p>\n<h5 id=\"2-8-1-号\"><a href=\"#2-8-1-号\" class=\"headerlink\" title=\"2.8.1 ^ 号\"></a>2.8.1 <code>^</code> 号</h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>\n<p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 应为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p>\n<p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p>\n<pre>\n\"(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<pre>\n\"^(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n<h5 id=\"2-8-2-号\"><a href=\"#2-8-2-号\" class=\"headerlink\" title=\"2.8.2 $ 号\"></a>2.8.2 <code>$</code> 号</h5><p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p>\n<p>例如, <code>(at\\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p>\n<pre>\n\"(at\\.)\" => The fat c<a href=\"#learn-regex\"><strong>at.</strong></a> s<a href=\"#learn-regex\"><strong>at.</strong></a> on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<pre>\n\"(at\\.)$\" => The fat cat. sat. on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<h3 id=\"3-简写字符集\"><a href=\"#3-简写字符集\" class=\"headerlink\" title=\"3. 简写字符集\"></a>3. 简写字符集</h3><p>正则表达式提供一些常用的字符集简写. 如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">简写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td>除换行符外的所有字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\w</td>\n<td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\W</td>\n<td>匹配所有非字母数字, 即符号, 等同于: <code>[^\\w]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\d</td>\n<td>匹配数字: <code>[0-9]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\D</td>\n<td>匹配非数字: <code>[^\\d]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td>匹配所有空格字符, 等同于: <code>[\\t\\n\\f\\r\\p{Z}]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td>匹配所有非空格字符: <code>[^\\s]</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-前后关联约束-前后预查\"><a href=\"#4-前后关联约束-前后预查\" class=\"headerlink\" title=\"4. 前后关联约束(前后预查)\"></a>4. 前后关联约束(前后预查)</h3><p>前置约束和后置约束都属于<strong>非捕获簇</strong>(用于匹配不在匹配列表中的格式).<br>前置约束用于判断所匹配的格式是否在另一个确定的格式之后.</p>\n<p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正向向后约束 <code>(?&lt;=\\$)[0-9\\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>\n<p>前后关联约束如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">?=</td>\n<td>前置约束-存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?!</td>\n<td>前置约束-排除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?&lt;=</td>\n<td>后置约束-存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?&lt;!</td>\n<td>后置约束-排除</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"4-1-前置约束-存在\"><a href=\"#4-1-前置约束-存在\" class=\"headerlink\" title=\"4.1 ?=... 前置约束(存在)\"></a>4.1 <code>?=...</code> 前置约束(存在)</h4><p><code>?=...</code> 前置约束(存在), 表示第一部分表达式必须跟在 <code>?=...</code>定义的表达式之后.</p>\n<p>返回结果只瞒住第一部分表达式.<br>定义一个前置约束(存在)要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p>\n<p>前置约束的内容写在括号中的等号后面.<br>例如, 表达式 <code>[T|t]he(?=\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了前置约束(存在) <code>(?=\\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'the(?=\\sfat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-前置约束-排除\"><a href=\"#4-2-前置约束-排除\" class=\"headerlink\" title=\"4.2 ?!... 前置约束-排除\"></a>4.2 <code>?!...</code> 前置约束-排除</h4><p>前置约束-排除 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式<br><code>前置约束-排除</code>  定义和 <code>前置约束(存在)</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>. </p>\n<p>表达式 <code>[T|t]he(?!\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'the(?!\\sfat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-lt-后置约束-存在\"><a href=\"#4-3-lt-后置约束-存在\" class=\"headerlink\" title=\"4.3 ?&lt;= ... 后置约束-存在\"></a>4.3 <code>?&lt;= ...</code> 后置约束-存在</h4><p>后置约束-存在 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.<br>例如, 表达式 <code>(?&lt;=[T|t]he\\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat hasd fat asd mat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'(?&lt;=the\\s)(fat|mat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-4-lt-后置约束-排除\"><a href=\"#4-4-lt-后置约束-排除\" class=\"headerlink\" title=\"4.4 ?&lt;!... 后置约束-排除\"></a>4.4 <code>?&lt;!...</code> 后置约束-排除</h4><p>后置约束-排除 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat hasd fat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'(?&lt;!the\\s)(fat|mat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-标志\"><a href=\"#5-标志\" class=\"headerlink\" title=\"5. 标志\"></a>5. 标志</h3><p>标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">i</td>\n<td>忽略大小写.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">g</td>\n<td>全局搜索.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-1-忽略大小写-Case-Insensitive\"><a href=\"#5-1-忽略大小写-Case-Insensitive\" class=\"headerlink\" title=\"5.1 忽略大小写 (Case Insensitive)\"></a>5.1 忽略大小写 (Case Insensitive)</h4><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p>\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/The/gi\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n\n<h4 id=\"5-2-全局搜索-Global-search\"><a href=\"#5-2-全局搜索-Global-search\" class=\"headerlink\" title=\"5.2 全局搜索 (Global search)\"></a>5.2 全局搜索 (Global search)</h4><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p>\n<pre>\n\"/.(at)/\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/.(at)/g\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> <a href=\"#learn-regex\"><strong>sat</strong></a> on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n\n<h4 id=\"5-3-多行修饰符-Multiline\"><a href=\"#5-3-多行修饰符-Multiline\" class=\"headerlink\" title=\"5.3 多行修饰符 (Multiline)\"></a>5.3 多行修饰符 (Multiline)</h4><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配.</p>\n<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p>\n<p>例如, 表达式 <code>/at(.)?$/gm</code> 表示在待检测字符串每行的末尾搜索 <code>at</code>后跟一个或多个 <code>.</code> 的字符串, 并返回全部结果.</p>\n<pre>\n\"/.at(.)?$/\" => The fat\n                cat sat\n                on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n<pre>\n\"/.at(.)?$/gm\" => The <a href=\"#learn-regex\"><strong>fat</strong></a>\n                  cat <a href=\"#learn-regex\"><strong>sat</strong></a>\n                  on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n<h4 id=\"额外补充\"><a href=\"#额外补充\" class=\"headerlink\" title=\"额外补充\"></a>额外补充</h4><ul>\n<li><em>正整数</em>: <code>^\\d+$</code></li>\n<li><em>负整数</em>: <code>^-\\d+$</code></li>\n<li><em>手机国家号</em>: <code>^+?[\\d\\s]{3,}$</code></li>\n<li><em>手机号</em>: <code>^+?[\\d\\s]+(?[\\d\\s]{10,}$</code></li>\n<li><em>整数</em>: <code>^-?\\d+$</code></li>\n<li><em>用户名</em>: <code>^[\\w\\d_.]{4,16}$</code></li>\n<li><em>数字和英文字母</em>: <code>^[a-zA-Z0-9]*$</code></li>\n<li><em>数字和应为字母和空格</em>: <code>^[a-zA-Z0-9 ]*$</code></li>\n<li><em>密码</em>: <code>^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li>\n<li><em>邮箱</em>: <code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4})*$</code></li>\n<li><em>IP4 地址</em>: <code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li>\n<li><em>纯小写字母</em>: <code>^([a-z])*$</code></li>\n<li><em>纯大写字母</em>: <code>^([A-Z])*$</code></li>\n<li><em>URL</em>: <code>^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\\/+=%&amp;_\\.~?\\-]*))*$</code></li>\n<li><em>VISA 信用卡号</em>: <code>^(4[0-9]{12}(?:[0-9]{3})?)*$</code></li>\n<li><em>日期 (MM/DD/YYYY)</em>: <code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$</code></li>\n<li><em>日期 (YYYY/MM/DD)</em>: <code>^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li>\n<li><em>MasterCard 信用卡号</em>: <code>^(5[1-5][0-9]{14})*$</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>正则表达式</p>\n<h3 id=\"什么是正则表达式？\"><a href=\"#什么是正则表达式？\" class=\"headerlink\" title=\"什么是正则表达式？\"></a>什么是正则表达式？</h3><blockquote>\n<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>\n</blockquote>","more":"<h3 id=\"基本匹配\"><a href=\"#基本匹配\" class=\"headerlink\" title=\"基本匹配\"></a>基本匹配</h3><p>大小写区分</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"comment\"># 从hello world 中匹配hello</span></span><br><span class=\"line\">result = re.match(<span class=\"string\">'hello'</span>,<span class=\"string\">'hello world'</span>).group()</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td>句号匹配任意单个字符除了换行符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[ ]</td>\n<td>字符种类. 匹配方括号内的任意字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">[^ ]</td>\n<td>否定的字符种类. 匹配除了方括号里的任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td>匹配&gt;=0个重复的在*号之前的字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td>匹配&gt;1个重复的+号前的字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?</td>\n<td>标记?之前的字符为可选.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">{ n,m }</td>\n<td>匹配num个中括号之前的字符 (n &lt;= num &lt;= m).</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(xyz)</td>\n<td>字符集, 匹配与 xyz 完全相等的字符串.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&#124;</td>\n<td>或运算符,匹配符号前或后的字符.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&#92;</td>\n<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \\ &#124;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">^</td>\n<td>从开始行开始匹配.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$</td>\n<td>从末端开始匹配.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-1-点运算符\"><a href=\"#2-1-点运算符\" class=\"headerlink\" title=\"2.1 点运算符 .\"></a>2.1 点运算符 <code>.</code></h4><p><code>.</code>是元字符中最简单的例子. <code>.</code>匹配任意单个字符, 但不匹配换行符.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">result = re.findall(<span class=\"string\">r'.l'</span>,<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-字符集\"><a href=\"#2-2-字符集\" class=\"headerlink\" title=\"2.2 字符集\"></a>2.2 字符集</h4><p>字符集也叫做字符类.<br>方括号用来指定一个字符集.<br>在方括号中使用连字符来指定字符集的范围.<br>在方括号中的字符集不关心顺序.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">result = re.findall(<span class=\"string\">r'[Th]'</span>,<span class=\"string\">'The'</span>)</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n<p>方括号的句号就表示句号. 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>\n<h5 id=\"2-2-1-否定字符集\"><a href=\"#2-2-1-否定字符集\" class=\"headerlink\" title=\"2.2.1 否定字符集\"></a>2.2.1 否定字符集</h5><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'[^p]ar'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-重复次数\"><a href=\"#2-3-重复次数\" class=\"headerlink\" title=\"2.3 重复次数\"></a>2.3 重复次数</h4><p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数.<br>这些元字符在不同的情况下有着不同的意思.</p>\n<h5 id=\"2-3-1-号\"><a href=\"#2-3-1-号\" class=\"headerlink\" title=\"2.3.1 * 号\"></a>2.3.1 <code>*</code> 号</h5><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br>例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'.*ar'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br><code>*</code>和表示匹配空格的符号<code>\\s</code>连起来用, 如表达式<code>\\s*cat\\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p>\n<h5 id=\"2-3-2-号\"><a href=\"#2-3-2-号\" class=\"headerlink\" title=\"2.3.2 + 号\"></a>2.3.2 <code>+</code> 号</h5><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次个字符.<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'.+ar'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-3-号\"><a href=\"#2-3-3-号\" class=\"headerlink\" title=\"2.3.3 ? 号\"></a>2.3.3 <code>?</code> 号</h5><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'.*?ar'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-号\"><a href=\"#2-4-号\" class=\"headerlink\" title=\"2.4 {} 号\"></a>2.4 <code>{}</code> 号</h4><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.</p>\n<p>我们可以省略第二个参数.<br>例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p>\n<p>如果逗号也省略掉则表示重复固定的次数.<br>例如, <code>[0-9]{3}</code> 匹配3位数字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'([cpm]ar)&#123;1,2&#125;'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-特征标群\"><a href=\"#2-5-特征标群\" class=\"headerlink\" title=\"2.5 (...) 特征标群\"></a>2.5 <code>(...)</code> 特征标群</h4><p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p>\n<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'((c|p|m)ar)&#123;1,2&#125;'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-6-或运算符\"><a href=\"#2-6-或运算符\" class=\"headerlink\" title=\"2.6 | 或运算符\"></a>2.6 <code>|</code> 或运算符</h4><p>或运算符就表示或, 用作判断条件.</p>\n<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'carparmar'</span></span><br><span class=\"line\">print(re.search(<span class=\"string\">r'((c|p|m)ar)&#123;1,3&#125;$'</span>,s).group())</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-7-转码特殊字符\"><a href=\"#2-7-转码特殊字符\" class=\"headerlink\" title=\"2.7 转码特殊字符\"></a>2.7 转码特殊字符</h4><p>反斜线 <code>\\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\\</code>.</p>\n<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\\.</code>.</p>\n<pre>\n\"(f|c|m)at\\.?\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> sat on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n<h4 id=\"2-8-锚点\"><a href=\"#2-8-锚点\" class=\"headerlink\" title=\"2.8 锚点\"></a>2.8 锚点</h4><p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p>\n<h5 id=\"2-8-1-号\"><a href=\"#2-8-1-号\" class=\"headerlink\" title=\"2.8.1 ^ 号\"></a>2.8.1 <code>^</code> 号</h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>\n<p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 应为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p>\n<p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p>\n<pre>\n\"(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in <a href=\"#learn-regex\"><strong>the</strong></a> garage.\n</pre>\n\n<pre>\n\"^(T|t)he\" => <a href=\"#learn-regex\"><strong>The</strong></a> car is parked in the garage.\n</pre>\n\n<h5 id=\"2-8-2-号\"><a href=\"#2-8-2-号\" class=\"headerlink\" title=\"2.8.2 $ 号\"></a>2.8.2 <code>$</code> 号</h5><p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p>\n<p>例如, <code>(at\\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p>\n<pre>\n\"(at\\.)\" => The fat c<a href=\"#learn-regex\"><strong>at.</strong></a> s<a href=\"#learn-regex\"><strong>at.</strong></a> on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<pre>\n\"(at\\.)$\" => The fat cat. sat. on the m<a href=\"#learn-regex\"><strong>at.</strong></a>\n</pre>\n\n<h3 id=\"3-简写字符集\"><a href=\"#3-简写字符集\" class=\"headerlink\" title=\"3. 简写字符集\"></a>3. 简写字符集</h3><p>正则表达式提供一些常用的字符集简写. 如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">简写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">.</td>\n<td>除换行符外的所有字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\w</td>\n<td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\W</td>\n<td>匹配所有非字母数字, 即符号, 等同于: <code>[^\\w]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\d</td>\n<td>匹配数字: <code>[0-9]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\D</td>\n<td>匹配非数字: <code>[^\\d]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\s</td>\n<td>匹配所有空格字符, 等同于: <code>[\\t\\n\\f\\r\\p{Z}]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\S</td>\n<td>匹配所有非空格字符: <code>[^\\s]</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-前后关联约束-前后预查\"><a href=\"#4-前后关联约束-前后预查\" class=\"headerlink\" title=\"4. 前后关联约束(前后预查)\"></a>4. 前后关联约束(前后预查)</h3><p>前置约束和后置约束都属于<strong>非捕获簇</strong>(用于匹配不在匹配列表中的格式).<br>前置约束用于判断所匹配的格式是否在另一个确定的格式之后.</p>\n<p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正向向后约束 <code>(?&lt;=\\$)[0-9\\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p>\n<p>前后关联约束如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">?=</td>\n<td>前置约束-存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?!</td>\n<td>前置约束-排除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?&lt;=</td>\n<td>后置约束-存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">?&lt;!</td>\n<td>后置约束-排除</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"4-1-前置约束-存在\"><a href=\"#4-1-前置约束-存在\" class=\"headerlink\" title=\"4.1 ?=... 前置约束(存在)\"></a>4.1 <code>?=...</code> 前置约束(存在)</h4><p><code>?=...</code> 前置约束(存在), 表示第一部分表达式必须跟在 <code>?=...</code>定义的表达式之后.</p>\n<p>返回结果只瞒住第一部分表达式.<br>定义一个前置约束(存在)要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p>\n<p>前置约束的内容写在括号中的等号后面.<br>例如, 表达式 <code>[T|t]he(?=\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了前置约束(存在) <code>(?=\\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'the(?=\\sfat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-前置约束-排除\"><a href=\"#4-2-前置约束-排除\" class=\"headerlink\" title=\"4.2 ?!... 前置约束-排除\"></a>4.2 <code>?!...</code> 前置约束-排除</h4><p>前置约束-排除 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式<br><code>前置约束-排除</code>  定义和 <code>前置约束(存在)</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>. </p>\n<p>表达式 <code>[T|t]he(?!\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'the(?!\\sfat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-lt-后置约束-存在\"><a href=\"#4-3-lt-后置约束-存在\" class=\"headerlink\" title=\"4.3 ?&lt;= ... 后置约束-存在\"></a>4.3 <code>?&lt;= ...</code> 后置约束-存在</h4><p>后置约束-存在 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.<br>例如, 表达式 <code>(?&lt;=[T|t]he\\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat hasd fat asd mat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'(?&lt;=the\\s)(fat|mat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-4-lt-后置约束-排除\"><a href=\"#4-4-lt-后置约束-排除\" class=\"headerlink\" title=\"4.4 ?&lt;!... 后置约束-排除\"></a>4.4 <code>?&lt;!...</code> 后置约束-排除</h4><p>后置约束-排除 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'the fat hasd fat the mat'</span></span><br><span class=\"line\">print(re.findall(<span class=\"string\">r'(?&lt;!the\\s)(fat|mat)'</span>,s))</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-标志\"><a href=\"#5-标志\" class=\"headerlink\" title=\"5. 标志\"></a>5. 标志</h3><p>标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标志</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">i</td>\n<td>忽略大小写.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">g</td>\n<td>全局搜索.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">m</td>\n<td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-1-忽略大小写-Case-Insensitive\"><a href=\"#5-1-忽略大小写-Case-Insensitive\" class=\"headerlink\" title=\"5.1 忽略大小写 (Case Insensitive)\"></a>5.1 忽略大小写 (Case Insensitive)</h4><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p>\n<pre>\n\"The\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/The/gi\" => <a href=\"#learn-regex\"><strong>The</strong></a> fat cat sat on <a href=\"#learn-regex\"><strong>the</strong></a> mat.\n</pre>\n\n\n<h4 id=\"5-2-全局搜索-Global-search\"><a href=\"#5-2-全局搜索-Global-search\" class=\"headerlink\" title=\"5.2 全局搜索 (Global search)\"></a>5.2 全局搜索 (Global search)</h4><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p>\n<pre>\n\"/.(at)/\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> cat sat on the mat.\n</pre>\n\n\n<pre>\n\"/.(at)/g\" => The <a href=\"#learn-regex\"><strong>fat</strong></a> <a href=\"#learn-regex\"><strong>cat</strong></a> <a href=\"#learn-regex\"><strong>sat</strong></a> on the <a href=\"#learn-regex\"><strong>mat</strong></a>.\n</pre>\n\n\n<h4 id=\"5-3-多行修饰符-Multiline\"><a href=\"#5-3-多行修饰符-Multiline\" class=\"headerlink\" title=\"5.3 多行修饰符 (Multiline)\"></a>5.3 多行修饰符 (Multiline)</h4><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配.</p>\n<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p>\n<p>例如, 表达式 <code>/at(.)?$/gm</code> 表示在待检测字符串每行的末尾搜索 <code>at</code>后跟一个或多个 <code>.</code> 的字符串, 并返回全部结果.</p>\n<pre>\n\"/.at(.)?$/\" => The fat\n                cat sat\n                on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n<pre>\n\"/.at(.)?$/gm\" => The <a href=\"#learn-regex\"><strong>fat</strong></a>\n                  cat <a href=\"#learn-regex\"><strong>sat</strong></a>\n                  on the <a href=\"#learn-regex\"><strong>mat.</strong></a>\n</pre>\n\n\n<h4 id=\"额外补充\"><a href=\"#额外补充\" class=\"headerlink\" title=\"额外补充\"></a>额外补充</h4><ul>\n<li><em>正整数</em>: <code>^\\d+$</code></li>\n<li><em>负整数</em>: <code>^-\\d+$</code></li>\n<li><em>手机国家号</em>: <code>^+?[\\d\\s]{3,}$</code></li>\n<li><em>手机号</em>: <code>^+?[\\d\\s]+(?[\\d\\s]{10,}$</code></li>\n<li><em>整数</em>: <code>^-?\\d+$</code></li>\n<li><em>用户名</em>: <code>^[\\w\\d_.]{4,16}$</code></li>\n<li><em>数字和英文字母</em>: <code>^[a-zA-Z0-9]*$</code></li>\n<li><em>数字和应为字母和空格</em>: <code>^[a-zA-Z0-9 ]*$</code></li>\n<li><em>密码</em>: <code>^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li>\n<li><em>邮箱</em>: <code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4})*$</code></li>\n<li><em>IP4 地址</em>: <code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li>\n<li><em>纯小写字母</em>: <code>^([a-z])*$</code></li>\n<li><em>纯大写字母</em>: <code>^([A-Z])*$</code></li>\n<li><em>URL</em>: <code>^(((http|https|ftp):\\/\\/)?([[a-zA-Z0-9]\\-\\.])+(\\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\\/+=%&amp;_\\.~?\\-]*))*$</code></li>\n<li><em>VISA 信用卡号</em>: <code>^(4[0-9]{12}(?:[0-9]{3})?)*$</code></li>\n<li><em>日期 (MM/DD/YYYY)</em>: <code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$</code></li>\n<li><em>日期 (YYYY/MM/DD)</em>: <code>^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li>\n<li><em>MasterCard 信用卡号</em>: <code>^(5[1-5][0-9]{14})*$</code></li>\n</ul>"},{"title":"模板方法模式","_content":"\n模板方法模式\n\n### 模板方法模式\n\n通过把不变行为搬迁到超类，去除字类中的重复代码来体现优势，\n\n\n先定义一个抽象类，通用的行为均可在此类中实现： \n\n```java\n\npublic abstract class AbstractClass {\n\n\t/**\n\t * 操作A\n\t */\n\tpublic abstract void operationA();\n\n\t/**\n\t * 操作B\n\t */\n\tpublic abstract void operationB();\n\n\tpublic void templateMethod(){\n\t\tSystem.out.println(\"公共业务 something ...\");\n\t\toperationA();\n\t\toperationB();\n\t}\n\n}\n```\n\n根据不同的业务实现不同的字类：\n\n\n```java\npublic class ConcreteAClass extends AbstractClass{\n\t@Override\n\tpublic void operationA() {\n\t\tSystem.out.println(\"第一个操作A\");\n\t}\n\n\t@Override\n\tpublic void operationB() {\n\t\tSystem.out.println(\"第一个操作B\");\n\t}\n}\n\npublic class ConcreteBClass extends AbstractClass{\n\t@Override\n\tpublic void operationA() {\n\t\tSystem.out.println(\"第二个操作A\");\n\t}\n\n\t@Override\n\tpublic void operationB() {\n\t\tSystem.out.println(\"第二个操作B\");\n\t}\n}\n\n```\n\n\n客户端使用：\n\n```java\n\tpublic static void main(String[] args) {\n\t\tAbstractClass abstractClass = new ConcreteAClass();\n\t\tabstractClass.templateMethod();\n\n\t\tAbstractClass abstractBClass = new ConcreteBClass();\n\t\tabstractBClass.templateMethod();\n\t}\n```\n\n模板方法模式提供了一个很好的代码复用的平台。","source":"_posts/设计模式-模板方法模式.md","raw":"---\ntitle: 模板方法模式\ntags:\n  - 设计模式\n  - 模板方法模式\n---\n\n模板方法模式\n\n### 模板方法模式\n\n通过把不变行为搬迁到超类，去除字类中的重复代码来体现优势，\n\n\n先定义一个抽象类，通用的行为均可在此类中实现： \n\n```java\n\npublic abstract class AbstractClass {\n\n\t/**\n\t * 操作A\n\t */\n\tpublic abstract void operationA();\n\n\t/**\n\t * 操作B\n\t */\n\tpublic abstract void operationB();\n\n\tpublic void templateMethod(){\n\t\tSystem.out.println(\"公共业务 something ...\");\n\t\toperationA();\n\t\toperationB();\n\t}\n\n}\n```\n\n根据不同的业务实现不同的字类：\n\n\n```java\npublic class ConcreteAClass extends AbstractClass{\n\t@Override\n\tpublic void operationA() {\n\t\tSystem.out.println(\"第一个操作A\");\n\t}\n\n\t@Override\n\tpublic void operationB() {\n\t\tSystem.out.println(\"第一个操作B\");\n\t}\n}\n\npublic class ConcreteBClass extends AbstractClass{\n\t@Override\n\tpublic void operationA() {\n\t\tSystem.out.println(\"第二个操作A\");\n\t}\n\n\t@Override\n\tpublic void operationB() {\n\t\tSystem.out.println(\"第二个操作B\");\n\t}\n}\n\n```\n\n\n客户端使用：\n\n```java\n\tpublic static void main(String[] args) {\n\t\tAbstractClass abstractClass = new ConcreteAClass();\n\t\tabstractClass.templateMethod();\n\n\t\tAbstractClass abstractBClass = new ConcreteBClass();\n\t\tabstractBClass.templateMethod();\n\t}\n```\n\n模板方法模式提供了一个很好的代码复用的平台。","slug":"设计模式-模板方法模式","published":1,"date":"2023-05-19T02:16:10.359Z","updated":"2023-05-19T02:16:10.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15bt003n9gj7rgbzqrnp","content":"<p>模板方法模式</p>\n<h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><p>通过把不变行为搬迁到超类，去除字类中的重复代码来体现优势，</p>\n<p>先定义一个抽象类，通用的行为均可在此类中实现： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 操作A</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">operationA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 操作B</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">operationB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">templateMethod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"公共业务 something ...\"</span>);</span><br><span class=\"line\">\t\toperationA();</span><br><span class=\"line\">\t\toperationB();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据不同的业务实现不同的字类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteAClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第一个操作A\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第一个操作B\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteBClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第二个操作A\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第二个操作B\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tAbstractClass abstractClass = <span class=\"keyword\">new</span> ConcreteAClass();</span><br><span class=\"line\">\tabstractClass.templateMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">\tAbstractClass abstractBClass = <span class=\"keyword\">new</span> ConcreteBClass();</span><br><span class=\"line\">\tabstractBClass.templateMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模板方法模式提供了一个很好的代码复用的平台。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>模板方法模式</p>\n<h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><p>通过把不变行为搬迁到超类，去除字类中的重复代码来体现优势，</p>\n<p>先定义一个抽象类，通用的行为均可在此类中实现： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 操作A</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">operationA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 操作B</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">operationB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">templateMethod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"公共业务 something ...\"</span>);</span><br><span class=\"line\">\t\toperationA();</span><br><span class=\"line\">\t\toperationB();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据不同的业务实现不同的字类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteAClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第一个操作A\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第一个操作B\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteBClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第二个操作A\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"第二个操作B\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tAbstractClass abstractClass = <span class=\"keyword\">new</span> ConcreteAClass();</span><br><span class=\"line\">\tabstractClass.templateMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">\tAbstractClass abstractBClass = <span class=\"keyword\">new</span> ConcreteBClass();</span><br><span class=\"line\">\tabstractBClass.templateMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模板方法模式提供了一个很好的代码复用的平台。</p>\n"},{"title":"接口幂等性解决方案","_content":"\n接口幂等性解决方案\n\n### 接口幂等性解决方案\n\n幂等操作:其任意多次执行所产生的影响均与一次执行的影响相同\n\n\n\n解决方案：\n\n1、数据库层面加上唯一索引,防止新增脏数据.\n2、业务表内添加状态,更新时添加状态更新. update xxxx where status = 1\n4、token校验机制,防止页面重复提交,由服务端生成token,客户端每次请求携带对应的toekn,服务端判断token是否存在,不存在则表示已经处理过,存在则删除。\n\n可使用AOP统一进行token检验。\n\n5、数据库悲观锁 select X from table where id = xx for update;\n6、基于版本号的更新,更新条件中带上版本号.数据库乐观锁\n7、最简单 select + insert方法,适合并发不高的系统.","source":"_posts/接口幂等性解决方案.md","raw":"---\ntitle: 接口幂等性解决方案\ntags:\n  - 接口幂等性\n  - 解决方案\n---\n\n接口幂等性解决方案\n\n### 接口幂等性解决方案\n\n幂等操作:其任意多次执行所产生的影响均与一次执行的影响相同\n\n\n\n解决方案：\n\n1、数据库层面加上唯一索引,防止新增脏数据.\n2、业务表内添加状态,更新时添加状态更新. update xxxx where status = 1\n4、token校验机制,防止页面重复提交,由服务端生成token,客户端每次请求携带对应的toekn,服务端判断token是否存在,不存在则表示已经处理过,存在则删除。\n\n可使用AOP统一进行token检验。\n\n5、数据库悲观锁 select X from table where id = xx for update;\n6、基于版本号的更新,更新条件中带上版本号.数据库乐观锁\n7、最简单 select + insert方法,适合并发不高的系统.","slug":"接口幂等性解决方案","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bu003q9gj7wtrqbjkq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>接口幂等性解决方案</p>\n<h3 id=\"接口幂等性解决方案\"><a href=\"#接口幂等性解决方案\" class=\"headerlink\" title=\"接口幂等性解决方案\"></a>接口幂等性解决方案</h3><p>幂等操作:其任意多次执行所产生的影响均与一次执行的影响相同</p>\n<p>解决方案：</p>\n<p>1、数据库层面加上唯一索引,防止新增脏数据.<br>2、业务表内添加状态,更新时添加状态更新. update xxxx where status = 1<br>4、token校验机制,防止页面重复提交,由服务端生成token,客户端每次请求携带对应的toekn,服务端判断token是否存在,不存在则表示已经处理过,存在则删除。</p>\n<p>可使用AOP统一进行token检验。</p>\n<p>5、数据库悲观锁 select X from table where id = xx for update;<br>6、基于版本号的更新,更新条件中带上版本号.数据库乐观锁<br>7、最简单 select + insert方法,适合并发不高的系统.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>接口幂等性解决方案</p>\n<h3 id=\"接口幂等性解决方案\"><a href=\"#接口幂等性解决方案\" class=\"headerlink\" title=\"接口幂等性解决方案\"></a>接口幂等性解决方案</h3><p>幂等操作:其任意多次执行所产生的影响均与一次执行的影响相同</p>\n<p>解决方案：</p>\n<p>1、数据库层面加上唯一索引,防止新增脏数据.<br>2、业务表内添加状态,更新时添加状态更新. update xxxx where status = 1<br>4、token校验机制,防止页面重复提交,由服务端生成token,客户端每次请求携带对应的toekn,服务端判断token是否存在,不存在则表示已经处理过,存在则删除。</p>\n<p>可使用AOP统一进行token检验。</p>\n<p>5、数据库悲观锁 select X from table where id = xx for update;<br>6、基于版本号的更新,更新条件中带上版本号.数据库乐观锁<br>7、最简单 select + insert方法,适合并发不高的系统.</p>\n"},{"title":"设计模式-简单工厂模式","_content":"\n### 简单工厂模式\n\n>   当类没有管理的时候，使用者每次都需要自己去new一个对象，简单工厂模式就是用一个集中的类来负责产品对象的创建。不属于23种设计模式，但是是工厂模式的基础。\n\n![简单工厂模式](http://image.tupelo.top/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg)\n\n","source":"_posts/简单工厂模式.md","raw":"---\ntitle: 设计模式-简单工厂模式\ntags:\n  - 设计模式\n---\n\n### 简单工厂模式\n\n>   当类没有管理的时候，使用者每次都需要自己去new一个对象，简单工厂模式就是用一个集中的类来负责产品对象的创建。不属于23种设计模式，但是是工厂模式的基础。\n\n![简单工厂模式](http://image.tupelo.top/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg)\n\n","slug":"简单工厂模式","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bv003s9gj71xxqde6g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><blockquote>\n<p>  当类没有管理的时候，使用者每次都需要自己去new一个对象，简单工厂模式就是用一个集中的类来负责产品对象的创建。不属于23种设计模式，但是是工厂模式的基础。</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg\" alt=\"简单工厂模式\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><blockquote>\n<p>  当类没有管理的时候，使用者每次都需要自己去new一个对象，简单工厂模式就是用一个集中的类来负责产品对象的创建。不属于23种设计模式，但是是工厂模式的基础。</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg\" alt=\"简单工厂模式\"></p>\n"},{"title":"设计模式-六大基本原则","_content":"\n### 六大基本原则\n\n>   重要的是思想 ！！！\n\n- 开闭原则\n    \n    >对扩展开发、对修改关闭\n\n- 单一职责原则\n    \n    >一个类只负责一个职责\n\n- 依赖倒置原则\n    \n    >面向接口编程\n\n- 里氏替换原则\n    \n    >子类可以扩展父类的功能、但不要改变父类原有的功能\n\n- 接口隔离原则\n    \n    >设计接口功能尽量细粒度、最小功能单元\n\n- 迪米特法则\n    \n    >降低耦合、局部变量中不要引入新的类\n\n\n","source":"_posts/设计模式原则.md","raw":"---\ntitle: 设计模式-六大基本原则\ntags:\n  - 设计模式\n---\n\n### 六大基本原则\n\n>   重要的是思想 ！！！\n\n- 开闭原则\n    \n    >对扩展开发、对修改关闭\n\n- 单一职责原则\n    \n    >一个类只负责一个职责\n\n- 依赖倒置原则\n    \n    >面向接口编程\n\n- 里氏替换原则\n    \n    >子类可以扩展父类的功能、但不要改变父类原有的功能\n\n- 接口隔离原则\n    \n    >设计接口功能尽量细粒度、最小功能单元\n\n- 迪米特法则\n    \n    >降低耦合、局部变量中不要引入新的类\n\n\n","slug":"设计模式原则","published":1,"date":"2025-02-12T08:28:16.473Z","updated":"2025-02-12T08:28:16.473Z","_id":"clhua15bx003u9gj77zjhb9tk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"六大基本原则\"><a href=\"#六大基本原则\" class=\"headerlink\" title=\"六大基本原则\"></a>六大基本原则</h3><blockquote>\n<p>  重要的是思想 ！！！</p>\n</blockquote>\n<ul>\n<li><p>开闭原则</p>\n<blockquote>\n<p>对扩展开发、对修改关闭</p>\n</blockquote>\n</li>\n<li><p>单一职责原则</p>\n<blockquote>\n<p>一个类只负责一个职责</p>\n</blockquote>\n</li>\n<li><p>依赖倒置原则</p>\n<blockquote>\n<p>面向接口编程</p>\n</blockquote>\n</li>\n<li><p>里氏替换原则</p>\n<blockquote>\n<p>子类可以扩展父类的功能、但不要改变父类原有的功能</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则</p>\n<blockquote>\n<p>设计接口功能尽量细粒度、最小功能单元</p>\n</blockquote>\n</li>\n<li><p>迪米特法则</p>\n<blockquote>\n<p>降低耦合、局部变量中不要引入新的类</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"六大基本原则\"><a href=\"#六大基本原则\" class=\"headerlink\" title=\"六大基本原则\"></a>六大基本原则</h3><blockquote>\n<p>  重要的是思想 ！！！</p>\n</blockquote>\n<ul>\n<li><p>开闭原则</p>\n<blockquote>\n<p>对扩展开发、对修改关闭</p>\n</blockquote>\n</li>\n<li><p>单一职责原则</p>\n<blockquote>\n<p>一个类只负责一个职责</p>\n</blockquote>\n</li>\n<li><p>依赖倒置原则</p>\n<blockquote>\n<p>面向接口编程</p>\n</blockquote>\n</li>\n<li><p>里氏替换原则</p>\n<blockquote>\n<p>子类可以扩展父类的功能、但不要改变父类原有的功能</p>\n</blockquote>\n</li>\n<li><p>接口隔离原则</p>\n<blockquote>\n<p>设计接口功能尽量细粒度、最小功能单元</p>\n</blockquote>\n</li>\n<li><p>迪米特法则</p>\n<blockquote>\n<p>降低耦合、局部变量中不要引入新的类</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"适配器模式","_content":"\n适配器模式\n\n### 适配器模式\n\n将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能使用一起工作的那些类可以一起工作。\n\n\n如 ： \n\n```java\n\n/**\n * 通用请求\n */\npublic abstract class Target {\n\tpublic abstract void request();\n}\n\n\n/**\n *  正常的请求\n */\npublic class NormalTarget extends Target {\n\t@Override\n\tpublic void request(){\n\t\tSystem.out.println(\"正常的请求\");\n\t};\n}\n\n/**\n * 特殊请求适配器\n */\npublic class AbnormalAdapter extends Target {\n\tprivate AbnormalAdaptee abnormalAdaptee = new AbnormalAdaptee();\n\t@Override\n\tpublic void request(){\n\t\tabnormalAdaptee.request();\n\t}\n}\n\n\n/**\n * 特殊的请求\n */\npublic class AbnormalAdaptee {\n\tpublic void request(){\n\t\tSystem.out.println(\"特殊请求\");\n\t}\n}\n\n/**\n * 使用方式一致\n */\npublic static void main(String[] args) {\n\tTarget normalTarget = new NormalTarget();\n\tnormalTarget.request();\n\tTarget abnormalAdapter = new AbnormalAdapter();\n\tabnormalAdapter.request();\n}\n\n```\n\n\n","source":"_posts/设计模式-适配器模式.md","raw":"---\ntitle: 适配器模式\ntags:\n  - 设计模式\n  - 适配器模式\n---\n\n适配器模式\n\n### 适配器模式\n\n将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能使用一起工作的那些类可以一起工作。\n\n\n如 ： \n\n```java\n\n/**\n * 通用请求\n */\npublic abstract class Target {\n\tpublic abstract void request();\n}\n\n\n/**\n *  正常的请求\n */\npublic class NormalTarget extends Target {\n\t@Override\n\tpublic void request(){\n\t\tSystem.out.println(\"正常的请求\");\n\t};\n}\n\n/**\n * 特殊请求适配器\n */\npublic class AbnormalAdapter extends Target {\n\tprivate AbnormalAdaptee abnormalAdaptee = new AbnormalAdaptee();\n\t@Override\n\tpublic void request(){\n\t\tabnormalAdaptee.request();\n\t}\n}\n\n\n/**\n * 特殊的请求\n */\npublic class AbnormalAdaptee {\n\tpublic void request(){\n\t\tSystem.out.println(\"特殊请求\");\n\t}\n}\n\n/**\n * 使用方式一致\n */\npublic static void main(String[] args) {\n\tTarget normalTarget = new NormalTarget();\n\tnormalTarget.request();\n\tTarget abnormalAdapter = new AbnormalAdapter();\n\tabnormalAdapter.request();\n}\n\n```\n\n\n","slug":"设计模式-适配器模式","published":1,"date":"2023-05-19T02:16:10.360Z","updated":"2023-05-19T02:16:10.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15by003w9gj7li54aldd","content":"<p>适配器模式</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能使用一起工作的那些类可以一起工作。</p>\n<p>如 ： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通用请求</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  正常的请求</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalTarget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"正常的请求\"</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 特殊请求适配器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbnormalAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> AbnormalAdaptee abnormalAdaptee = <span class=\"keyword\">new</span> AbnormalAdaptee();</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tabnormalAdaptee.request();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 特殊的请求</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbnormalAdaptee</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"特殊请求\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用方式一致</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tTarget normalTarget = <span class=\"keyword\">new</span> NormalTarget();</span><br><span class=\"line\">\tnormalTarget.request();</span><br><span class=\"line\">\tTarget abnormalAdapter = <span class=\"keyword\">new</span> AbnormalAdapter();</span><br><span class=\"line\">\tabnormalAdapter.request();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>适配器模式</p>\n<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能使用一起工作的那些类可以一起工作。</p>\n<p>如 ： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通用请求</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  正常的请求</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalTarget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"正常的请求\"</span>);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 特殊请求适配器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbnormalAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> AbnormalAdaptee abnormalAdaptee = <span class=\"keyword\">new</span> AbnormalAdaptee();</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tabnormalAdaptee.request();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 特殊的请求</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbnormalAdaptee</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"特殊请求\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用方式一致</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tTarget normalTarget = <span class=\"keyword\">new</span> NormalTarget();</span><br><span class=\"line\">\tnormalTarget.request();</span><br><span class=\"line\">\tTarget abnormalAdapter = <span class=\"keyword\">new</span> AbnormalAdapter();</span><br><span class=\"line\">\tabnormalAdapter.request();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"深拷贝浅拷贝及原型模式","_content":"\n深拷贝浅拷贝及原型模式\n\n### 浅拷贝\n\n浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。\n\n\n如 ： \n\n```java\n\n@Data\npublic class User implements Cloneable {\n\n\tprivate Integer age;\n\n\tprivate String name;\n\t\n\tprivate Child child;\n\t\n\t@Override\n\tpublic User clone() throws CloneNotSupportedException {\n\t\treturn (User) super.clone();\n\t}\n}\n\npublic static void main(String[] args) throws CloneNotSupportedException {\n\tUser user = new User();\n\tuser.setAge(18);\n\tuser.setName(\"张三\");\n\n\tChild child = new Child();\n\tchild.setAge(3);\n\tchild.setName(\"张三的儿子\");\n\tuser.setChild(child);\n\n\t// 浅拷贝\n\tUser clone = user.clone();\n\tSystem.out.println(JSON.toJSONString(clone));\n\t// 修改原来的对象 复制的对象也会被修改\n\tuser.setAge(19);\n\tchild.setAge(4);\n\tuser.setChild(child);\n\tSystem.out.println(JSON.toJSONString(clone));\n\n}\n\n\n```\n\n可以发现对于拷贝的对象，修改拷贝之前的属性，如属性是基本类型，则无影响，如属性是对象，则会影像拷贝之后的对象。所以浅拷贝会带来数据安全上的问题。\n\n\n\n### 深拷贝\n\n深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。\n\n- 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。\n- 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。\n- 对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法，进而实现了对象的串行层层拷贝。\n- 深拷贝相比于浅拷贝速度较慢并且花销较大。\n\n\n对上面的代码实现深拷贝\n\n```java\n\n@Data\npublic class Child implements Cloneable {\n\n\tprivate Integer age;\n\n\tprivate String name;\n\n\t@Override\n\tpublic Child clone() throws CloneNotSupportedException {\n\t\treturn (Child) super.clone();\n\t}\n}\n\n@Data\npublic class User implements Cloneable {\n\n\tprivate Integer age;\n\n\tprivate String name;\n\n\tprivate Child child;\n\n\t@Override\n\tpublic User clone() throws CloneNotSupportedException {\n\t\tUser user = (User) super.clone();\n\t\tuser.child = child.clone();\n\t\treturn user;\n\t}\n}\n\n```\n\n\n#### 问题\n\n问：Cloneable接口是一个空接口，为什么需要实现Cloneable接口？\n\n\n答：Cloneable是标示接口与java.io.Serializable类似，用于告知JVM该对象实现clone。并且super.clone()可以返回一个复制。如果实现Cloneable接口直接super.clone()，会抛出CloneNotSupportedException。\n\n\n\n### 原型模式\n\n用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，从一个对象创建另外一个可定制的对象，而且不需要知道任何创建的细节。\n\n基本代码\n\n```java\n@Slf4j\npublic class ConcretePrototype implements Cloneable{\n\t@Override\n\tpublic ConcretePrototype clone() {\n\t\tObject object = null;\n\t\ttry {\n\t\t\tobject = super.clone();\n\t\t} catch (CloneNotSupportedException exception) {\n\t\t\tlog.error(\"Not support cloneable\");\n\t\t}\n\t\treturn (ConcretePrototype )object;\n\t}\n}\n\n```\n","source":"_posts/设计模式-深拷贝浅拷贝及原型模式.md","raw":"---\ntitle: 深拷贝浅拷贝及原型模式\ntags:\n  - 设计模式\n  - java基础\n---\n\n深拷贝浅拷贝及原型模式\n\n### 浅拷贝\n\n浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。\n\n\n如 ： \n\n```java\n\n@Data\npublic class User implements Cloneable {\n\n\tprivate Integer age;\n\n\tprivate String name;\n\t\n\tprivate Child child;\n\t\n\t@Override\n\tpublic User clone() throws CloneNotSupportedException {\n\t\treturn (User) super.clone();\n\t}\n}\n\npublic static void main(String[] args) throws CloneNotSupportedException {\n\tUser user = new User();\n\tuser.setAge(18);\n\tuser.setName(\"张三\");\n\n\tChild child = new Child();\n\tchild.setAge(3);\n\tchild.setName(\"张三的儿子\");\n\tuser.setChild(child);\n\n\t// 浅拷贝\n\tUser clone = user.clone();\n\tSystem.out.println(JSON.toJSONString(clone));\n\t// 修改原来的对象 复制的对象也会被修改\n\tuser.setAge(19);\n\tchild.setAge(4);\n\tuser.setChild(child);\n\tSystem.out.println(JSON.toJSONString(clone));\n\n}\n\n\n```\n\n可以发现对于拷贝的对象，修改拷贝之前的属性，如属性是基本类型，则无影响，如属性是对象，则会影像拷贝之后的对象。所以浅拷贝会带来数据安全上的问题。\n\n\n\n### 深拷贝\n\n深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。\n\n- 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。\n- 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。\n- 对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法，进而实现了对象的串行层层拷贝。\n- 深拷贝相比于浅拷贝速度较慢并且花销较大。\n\n\n对上面的代码实现深拷贝\n\n```java\n\n@Data\npublic class Child implements Cloneable {\n\n\tprivate Integer age;\n\n\tprivate String name;\n\n\t@Override\n\tpublic Child clone() throws CloneNotSupportedException {\n\t\treturn (Child) super.clone();\n\t}\n}\n\n@Data\npublic class User implements Cloneable {\n\n\tprivate Integer age;\n\n\tprivate String name;\n\n\tprivate Child child;\n\n\t@Override\n\tpublic User clone() throws CloneNotSupportedException {\n\t\tUser user = (User) super.clone();\n\t\tuser.child = child.clone();\n\t\treturn user;\n\t}\n}\n\n```\n\n\n#### 问题\n\n问：Cloneable接口是一个空接口，为什么需要实现Cloneable接口？\n\n\n答：Cloneable是标示接口与java.io.Serializable类似，用于告知JVM该对象实现clone。并且super.clone()可以返回一个复制。如果实现Cloneable接口直接super.clone()，会抛出CloneNotSupportedException。\n\n\n\n### 原型模式\n\n用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，从一个对象创建另外一个可定制的对象，而且不需要知道任何创建的细节。\n\n基本代码\n\n```java\n@Slf4j\npublic class ConcretePrototype implements Cloneable{\n\t@Override\n\tpublic ConcretePrototype clone() {\n\t\tObject object = null;\n\t\ttry {\n\t\t\tobject = super.clone();\n\t\t} catch (CloneNotSupportedException exception) {\n\t\t\tlog.error(\"Not support cloneable\");\n\t\t}\n\t\treturn (ConcretePrototype )object;\n\t}\n}\n\n```\n","slug":"设计模式-深拷贝浅拷贝及原型模式","published":1,"date":"2023-05-19T02:16:10.359Z","updated":"2023-05-19T02:16:10.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhua15bz003y9gj7lmogyp1s","content":"<p>深拷贝浅拷贝及原型模式</p>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p>\n<p>如 ： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Child child;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (User) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\tUser user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">\tuser.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">\tuser.setName(<span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tChild child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">\tchild.setAge(<span class=\"number\">3</span>);</span><br><span class=\"line\">\tchild.setName(<span class=\"string\">\"张三的儿子\"</span>);</span><br><span class=\"line\">\tuser.setChild(child);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 浅拷贝</span></span><br><span class=\"line\">\tUser clone = user.clone();</span><br><span class=\"line\">\tSystem.out.println(JSON.toJSONString(clone));</span><br><span class=\"line\">\t<span class=\"comment\">// 修改原来的对象 复制的对象也会被修改</span></span><br><span class=\"line\">\tuser.setAge(<span class=\"number\">19</span>);</span><br><span class=\"line\">\tchild.setAge(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tuser.setChild(child);</span><br><span class=\"line\">\tSystem.out.println(JSON.toJSONString(clone));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现对于拷贝的对象，修改拷贝之前的属性，如属性是基本类型，则无影响，如属性是对象，则会影像拷贝之后的对象。所以浅拷贝会带来数据安全上的问题。</p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</p>\n<ul>\n<li>对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。</li>\n<li>对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。</li>\n<li>对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法，进而实现了对象的串行层层拷贝。</li>\n<li>深拷贝相比于浅拷贝速度较慢并且花销较大。</li>\n</ul>\n<p>对上面的代码实现深拷贝</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Child <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (Child) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Child child;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\tUser user = (User) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t\tuser.child = child.clone();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> user;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>问：Cloneable接口是一个空接口，为什么需要实现Cloneable接口？</p>\n<p>答：Cloneable是标示接口与java.io.Serializable类似，用于告知JVM该对象实现clone。并且super.clone()可以返回一个复制。如果实现Cloneable接口直接super.clone()，会抛出CloneNotSupportedException。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，从一个对象创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p>\n<p>基本代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ConcretePrototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tObject object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tobject = <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class=\"line\">\t\t\tlog.error(<span class=\"string\">\"Not support cloneable\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (ConcretePrototype )object;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>深拷贝浅拷贝及原型模式</p>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p>\n<p>如 ： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Child child;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (User) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\tUser user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">\tuser.setAge(<span class=\"number\">18</span>);</span><br><span class=\"line\">\tuser.setName(<span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tChild child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">\tchild.setAge(<span class=\"number\">3</span>);</span><br><span class=\"line\">\tchild.setName(<span class=\"string\">\"张三的儿子\"</span>);</span><br><span class=\"line\">\tuser.setChild(child);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 浅拷贝</span></span><br><span class=\"line\">\tUser clone = user.clone();</span><br><span class=\"line\">\tSystem.out.println(JSON.toJSONString(clone));</span><br><span class=\"line\">\t<span class=\"comment\">// 修改原来的对象 复制的对象也会被修改</span></span><br><span class=\"line\">\tuser.setAge(<span class=\"number\">19</span>);</span><br><span class=\"line\">\tchild.setAge(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tuser.setChild(child);</span><br><span class=\"line\">\tSystem.out.println(JSON.toJSONString(clone));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现对于拷贝的对象，修改拷贝之前的属性，如属性是基本类型，则无影响，如属性是对象，则会影像拷贝之后的对象。所以浅拷贝会带来数据安全上的问题。</p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</p>\n<ul>\n<li>对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。</li>\n<li>对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。</li>\n<li>对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法，进而实现了对象的串行层层拷贝。</li>\n<li>深拷贝相比于浅拷贝速度较慢并且花销较大。</li>\n</ul>\n<p>对上面的代码实现深拷贝</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Child <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (Child) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Child child;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\tUser user = (User) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t\tuser.child = child.clone();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> user;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>问：Cloneable接口是一个空接口，为什么需要实现Cloneable接口？</p>\n<p>答：Cloneable是标示接口与java.io.Serializable类似，用于告知JVM该对象实现clone。并且super.clone()可以返回一个复制。如果实现Cloneable接口直接super.clone()，会抛出CloneNotSupportedException。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，从一个对象创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p>\n<p>基本代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ConcretePrototype <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tObject object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tobject = <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class=\"line\">\t\t\tlog.error(<span class=\"string\">\"Not support cloneable\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (ConcretePrototype )object;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式-适配器模式","_content":"\n### 适配器模式\n\n>   将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。\n\n![适配器模式](http://image.tupelo.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png)\n\n","source":"_posts/适配器模式.md","raw":"---\ntitle: 设计模式-适配器模式\ntags:\n  - 设计模式\n---\n\n### 适配器模式\n\n>   将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。\n\n![适配器模式](http://image.tupelo.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png)\n\n","slug":"适配器模式","published":1,"date":"2025-02-12T08:28:16.474Z","updated":"2025-02-12T08:28:16.474Z","_id":"clhua15c0003z9gj7nt3sj5yo","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><blockquote>\n<p>  将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png\" alt=\"适配器模式\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><blockquote>\n<p>  将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p>\n</blockquote>\n<p><img src=\"http://image.tupelo.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png\" alt=\"适配器模式\"></p>\n"},{"title":"深入理解通讯协议","_content":"\n通讯协议\n\n### 网络模型\n\n七层模型\n\n- OSI模型\n    - 应用层  为应用程序提供服务\n    - 表示层  数据格式转换\n    - 会话层  建立 管理 维护会话\n    - 传输层  最重要 端对端的连接 数据可靠性传输\n    - 网络层  ip 路由\n    - 链路层  交换机\n    - 物理层  物理介质 网线等等\n\n<!-- more -->\n\n- TCP/IP模型\n    - 应用层 \n    - 传输层\n    - 网路层\n    - 链路层\n\n### TCP的3次握手\n\n- 客户端请求建立连接\n- 服务端应答 服务端建立连接\n- 客户端应答\n\n### SYN洪泛攻击\n\n>定义\n\n    通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。\n>原理\n\n    攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，\n    服务端在等待客户端的第三次握手(永远都不会有的)，\n    服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n\n>解决方案\n\n    无效连接监控释放\n    延缓TCB分配方法\n    防火墙\n\n\n\n### TCP的4次挥手\n\n- 客户端发送关闭请求\n- 服务端关闭请求\n- 服务端发送关闭请求\n- 客户端发送关闭\n\n\n#### TCP的通讯原理\n\n>Socket套接字\n\n    TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。\n\n>TCP缓冲区\n\n    每个TCP的Socket的内核中都有一个发送缓冲区和一个接收缓冲区。\n\n>阻塞模式\n\n    接收端缓冲区为空，接收端调用read方法的线程阻塞。\n    发送端缓冲区满了或者不够大，发送端调用write方法的线程阻塞。\n\n#### TCP中的滑动窗口协议——可靠和高效的结合\n\n- 滑动窗口\n    - 发送方和接收方都会维护一个数据帧的序列，这个序列被称作窗口。\n    - 发送方的窗口大小由接收方确认。\n\n- 目的\n    - 确保数据不丢失\n        - 如果发送的数据丢失了可以重新发。\n    - 控制发送速度\n        - 控制发送速度，以免接收方的缓存不够大导\n        - 致溢出，同时控制流量也可以避免网络拥塞。\n\n滑动演示:\n>https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html\n\n### HTTP协议\n\n```java\n//服务端\npublic static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8888);\n        System.out.println(\"服务端启动 端口8888\");\n        while (true){\n            Socket socket = serverSocket.accept();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String buffer = null;\n            while ((buffer=bufferedReader.readLine())!=null&&!buffer.equals(\"\")){\n                System.out.println(buffer);\n            }\n            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bufferedWriter.write(\"HTTP/1.1 200 OK \\r\\n Content-Type:text/json \\r\\n charset=UTF-8 \\r\\n \\r\\n\");\n            bufferedWriter.write(\"11\");\n            bufferedWriter.flush();\n            bufferedReader.close();\n            bufferedWriter.close();\n            socket.close();\n        }\n}\n\n//客户端\npublic static void main(String[] args) throws Exception {\n    String msg = \"hahahha\";\n    Socket socket = new Socket(\"127.0.0.1\",8888);\n    PrintWriter printWriter = new PrintWriter(socket.getOutputStream());\n    printWriter.println(msg);\n    printWriter.flush();\n    printWriter.close();\n    socket.close();\n}\n```\n\n#### UDP协议\n\n>UDP协议更快,但是容易丢包 只管发送,不管有没有送达 \n\n```java\n//服务端\npublic static void main(String[] args) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket(10005);\n        byte[] bytes = new byte[1024];\n        DatagramPacket datagramPacket = new DatagramPacket(bytes,bytes.length);\n        while (true){\n            datagramSocket.receive(datagramPacket);\n            byte[] data = datagramPacket.getData();\n            String str = new String(data,0,datagramPacket.getLength());\n            if(\"88\".equals(str)){\n                break;\n            }\n            System.out.println(\"接收到的数据为：\"+str);\n        }\n        datagramSocket.close();\n}\n\n//客户端\npublic static void main(String[] args) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        String line = null;\n        while ((line=bufferedReader.readLine())!=null){\n         byte[] bytes = line.getBytes();\n            DatagramPacket datagramPacket = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"127.0.0.1\"),10005);\n            datagramSocket.send(datagramPacket);\n            if(\"88\".equals(line)){\n                break;\n            }\n            System.out.println(\"发送的数据是：\"+line);\n        }\n        datagramSocket.close();\n}\n```\n\n\n","source":"_posts/通讯协议.md","raw":"---\ntitle: 深入理解通讯协议\ntags:\n  - 通讯协议\n---\n\n通讯协议\n\n### 网络模型\n\n七层模型\n\n- OSI模型\n    - 应用层  为应用程序提供服务\n    - 表示层  数据格式转换\n    - 会话层  建立 管理 维护会话\n    - 传输层  最重要 端对端的连接 数据可靠性传输\n    - 网络层  ip 路由\n    - 链路层  交换机\n    - 物理层  物理介质 网线等等\n\n<!-- more -->\n\n- TCP/IP模型\n    - 应用层 \n    - 传输层\n    - 网路层\n    - 链路层\n\n### TCP的3次握手\n\n- 客户端请求建立连接\n- 服务端应答 服务端建立连接\n- 客户端应答\n\n### SYN洪泛攻击\n\n>定义\n\n    通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。\n>原理\n\n    攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，\n    服务端在等待客户端的第三次握手(永远都不会有的)，\n    服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n\n>解决方案\n\n    无效连接监控释放\n    延缓TCB分配方法\n    防火墙\n\n\n\n### TCP的4次挥手\n\n- 客户端发送关闭请求\n- 服务端关闭请求\n- 服务端发送关闭请求\n- 客户端发送关闭\n\n\n#### TCP的通讯原理\n\n>Socket套接字\n\n    TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。\n\n>TCP缓冲区\n\n    每个TCP的Socket的内核中都有一个发送缓冲区和一个接收缓冲区。\n\n>阻塞模式\n\n    接收端缓冲区为空，接收端调用read方法的线程阻塞。\n    发送端缓冲区满了或者不够大，发送端调用write方法的线程阻塞。\n\n#### TCP中的滑动窗口协议——可靠和高效的结合\n\n- 滑动窗口\n    - 发送方和接收方都会维护一个数据帧的序列，这个序列被称作窗口。\n    - 发送方的窗口大小由接收方确认。\n\n- 目的\n    - 确保数据不丢失\n        - 如果发送的数据丢失了可以重新发。\n    - 控制发送速度\n        - 控制发送速度，以免接收方的缓存不够大导\n        - 致溢出，同时控制流量也可以避免网络拥塞。\n\n滑动演示:\n>https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html\n\n### HTTP协议\n\n```java\n//服务端\npublic static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8888);\n        System.out.println(\"服务端启动 端口8888\");\n        while (true){\n            Socket socket = serverSocket.accept();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String buffer = null;\n            while ((buffer=bufferedReader.readLine())!=null&&!buffer.equals(\"\")){\n                System.out.println(buffer);\n            }\n            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            bufferedWriter.write(\"HTTP/1.1 200 OK \\r\\n Content-Type:text/json \\r\\n charset=UTF-8 \\r\\n \\r\\n\");\n            bufferedWriter.write(\"11\");\n            bufferedWriter.flush();\n            bufferedReader.close();\n            bufferedWriter.close();\n            socket.close();\n        }\n}\n\n//客户端\npublic static void main(String[] args) throws Exception {\n    String msg = \"hahahha\";\n    Socket socket = new Socket(\"127.0.0.1\",8888);\n    PrintWriter printWriter = new PrintWriter(socket.getOutputStream());\n    printWriter.println(msg);\n    printWriter.flush();\n    printWriter.close();\n    socket.close();\n}\n```\n\n#### UDP协议\n\n>UDP协议更快,但是容易丢包 只管发送,不管有没有送达 \n\n```java\n//服务端\npublic static void main(String[] args) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket(10005);\n        byte[] bytes = new byte[1024];\n        DatagramPacket datagramPacket = new DatagramPacket(bytes,bytes.length);\n        while (true){\n            datagramSocket.receive(datagramPacket);\n            byte[] data = datagramPacket.getData();\n            String str = new String(data,0,datagramPacket.getLength());\n            if(\"88\".equals(str)){\n                break;\n            }\n            System.out.println(\"接收到的数据为：\"+str);\n        }\n        datagramSocket.close();\n}\n\n//客户端\npublic static void main(String[] args) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        String line = null;\n        while ((line=bufferedReader.readLine())!=null){\n         byte[] bytes = line.getBytes();\n            DatagramPacket datagramPacket = new DatagramPacket(bytes,bytes.length, InetAddress.getByName(\"127.0.0.1\"),10005);\n            datagramSocket.send(datagramPacket);\n            if(\"88\".equals(line)){\n                break;\n            }\n            System.out.println(\"发送的数据是：\"+line);\n        }\n        datagramSocket.close();\n}\n```\n\n\n","slug":"通讯协议","published":1,"date":"2025-02-12T08:28:16.474Z","updated":"2025-02-12T08:28:16.474Z","_id":"clhua15c100419gj763boxaw3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>通讯协议</p>\n<h3 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h3><p>七层模型</p>\n<ul>\n<li>OSI模型<ul>\n<li>应用层  为应用程序提供服务</li>\n<li>表示层  数据格式转换</li>\n<li>会话层  建立 管理 维护会话</li>\n<li>传输层  最重要 端对端的连接 数据可靠性传输</li>\n<li>网络层  ip 路由</li>\n<li>链路层  交换机</li>\n<li>物理层  物理介质 网线等等</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>TCP/IP模型<ul>\n<li>应用层 </li>\n<li>传输层</li>\n<li>网路层</li>\n<li>链路层</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP的3次握手\"><a href=\"#TCP的3次握手\" class=\"headerlink\" title=\"TCP的3次握手\"></a>TCP的3次握手</h3><ul>\n<li>客户端请求建立连接</li>\n<li>服务端应答 服务端建立连接</li>\n<li>客户端应答</li>\n</ul>\n<h3 id=\"SYN洪泛攻击\"><a href=\"#SYN洪泛攻击\" class=\"headerlink\" title=\"SYN洪泛攻击\"></a>SYN洪泛攻击</h3><blockquote>\n<p>定义</p>\n</blockquote>\n<pre><code>通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。\n</code></pre><blockquote>\n<p>原理</p>\n</blockquote>\n<pre><code>攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，\n服务端在等待客户端的第三次握手(永远都不会有的)，\n服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n</code></pre><blockquote>\n<p>解决方案</p>\n</blockquote>\n<pre><code>无效连接监控释放\n延缓TCB分配方法\n防火墙\n</code></pre><h3 id=\"TCP的4次挥手\"><a href=\"#TCP的4次挥手\" class=\"headerlink\" title=\"TCP的4次挥手\"></a>TCP的4次挥手</h3><ul>\n<li>客户端发送关闭请求</li>\n<li>服务端关闭请求</li>\n<li>服务端发送关闭请求</li>\n<li>客户端发送关闭</li>\n</ul>\n<h4 id=\"TCP的通讯原理\"><a href=\"#TCP的通讯原理\" class=\"headerlink\" title=\"TCP的通讯原理\"></a>TCP的通讯原理</h4><blockquote>\n<p>Socket套接字</p>\n</blockquote>\n<pre><code>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。\n</code></pre><blockquote>\n<p>TCP缓冲区</p>\n</blockquote>\n<pre><code>每个TCP的Socket的内核中都有一个发送缓冲区和一个接收缓冲区。\n</code></pre><blockquote>\n<p>阻塞模式</p>\n</blockquote>\n<pre><code>接收端缓冲区为空，接收端调用read方法的线程阻塞。\n发送端缓冲区满了或者不够大，发送端调用write方法的线程阻塞。\n</code></pre><h4 id=\"TCP中的滑动窗口协议——可靠和高效的结合\"><a href=\"#TCP中的滑动窗口协议——可靠和高效的结合\" class=\"headerlink\" title=\"TCP中的滑动窗口协议——可靠和高效的结合\"></a>TCP中的滑动窗口协议——可靠和高效的结合</h4><ul>\n<li><p>滑动窗口</p>\n<ul>\n<li>发送方和接收方都会维护一个数据帧的序列，这个序列被称作窗口。</li>\n<li>发送方的窗口大小由接收方确认。</li>\n</ul>\n</li>\n<li><p>目的</p>\n<ul>\n<li>确保数据不丢失<ul>\n<li>如果发送的数据丢失了可以重新发。</li>\n</ul>\n</li>\n<li>控制发送速度<ul>\n<li>控制发送速度，以免接收方的缓存不够大导</li>\n<li>致溢出，同时控制流量也可以避免网络拥塞。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>滑动演示:</p>\n<blockquote>\n<p><a href=\"https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html\" target=\"_blank\" rel=\"noopener\">https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html</a></p>\n</blockquote>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务端启动 端口8888\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            Socket socket = serverSocket.accept();</span><br><span class=\"line\">            BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class=\"line\">            String buffer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((buffer=bufferedReader.readLine())!=<span class=\"keyword\">null</span>&amp;&amp;!buffer.equals(<span class=\"string\">\"\"</span>))&#123;</span><br><span class=\"line\">                System.out.println(buffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            BufferedWriter bufferedWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">\"HTTP/1.1 200 OK \\r\\n Content-Type:text/json \\r\\n charset=UTF-8 \\r\\n \\r\\n\"</span>);</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">\"11\"</span>);</span><br><span class=\"line\">            bufferedWriter.flush();</span><br><span class=\"line\">            bufferedReader.close();</span><br><span class=\"line\">            bufferedWriter.close();</span><br><span class=\"line\">            socket.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//客户端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    String msg = <span class=\"string\">\"hahahha\"</span>;</span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"127.0.0.1\"</span>,<span class=\"number\">8888</span>);</span><br><span class=\"line\">    PrintWriter printWriter = <span class=\"keyword\">new</span> PrintWriter(socket.getOutputStream());</span><br><span class=\"line\">    printWriter.println(msg);</span><br><span class=\"line\">    printWriter.flush();</span><br><span class=\"line\">    printWriter.close();</span><br><span class=\"line\">    socket.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h4><blockquote>\n<p>UDP协议更快,但是容易丢包 只管发送,不管有没有送达 </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DatagramSocket datagramSocket = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">10005</span>);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        DatagramPacket datagramPacket = <span class=\"keyword\">new</span> DatagramPacket(bytes,bytes.length);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            datagramSocket.receive(datagramPacket);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] data = datagramPacket.getData();</span><br><span class=\"line\">            String str = <span class=\"keyword\">new</span> String(data,<span class=\"number\">0</span>,datagramPacket.getLength());</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">\"88\"</span>.equals(str))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"接收到的数据为：\"</span>+str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        datagramSocket.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//客户端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DatagramSocket datagramSocket = <span class=\"keyword\">new</span> DatagramSocket();</span><br><span class=\"line\">        BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((line=bufferedReader.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">byte</span>[] bytes = line.getBytes();</span><br><span class=\"line\">            DatagramPacket datagramPacket = <span class=\"keyword\">new</span> DatagramPacket(bytes,bytes.length, InetAddress.getByName(<span class=\"string\">\"127.0.0.1\"</span>),<span class=\"number\">10005</span>);</span><br><span class=\"line\">            datagramSocket.send(datagramPacket);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">\"88\"</span>.equals(line))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"发送的数据是：\"</span>+line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        datagramSocket.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>通讯协议</p>\n<h3 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h3><p>七层模型</p>\n<ul>\n<li>OSI模型<ul>\n<li>应用层  为应用程序提供服务</li>\n<li>表示层  数据格式转换</li>\n<li>会话层  建立 管理 维护会话</li>\n<li>传输层  最重要 端对端的连接 数据可靠性传输</li>\n<li>网络层  ip 路由</li>\n<li>链路层  交换机</li>\n<li>物理层  物理介质 网线等等</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li>TCP/IP模型<ul>\n<li>应用层 </li>\n<li>传输层</li>\n<li>网路层</li>\n<li>链路层</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP的3次握手\"><a href=\"#TCP的3次握手\" class=\"headerlink\" title=\"TCP的3次握手\"></a>TCP的3次握手</h3><ul>\n<li>客户端请求建立连接</li>\n<li>服务端应答 服务端建立连接</li>\n<li>客户端应答</li>\n</ul>\n<h3 id=\"SYN洪泛攻击\"><a href=\"#SYN洪泛攻击\" class=\"headerlink\" title=\"SYN洪泛攻击\"></a>SYN洪泛攻击</h3><blockquote>\n<p>定义</p>\n</blockquote>\n<pre><code>通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。\n</code></pre><blockquote>\n<p>原理</p>\n</blockquote>\n<pre><code>攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，\n服务端在等待客户端的第三次握手(永远都不会有的)，\n服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n</code></pre><blockquote>\n<p>解决方案</p>\n</blockquote>\n<pre><code>无效连接监控释放\n延缓TCB分配方法\n防火墙\n</code></pre><h3 id=\"TCP的4次挥手\"><a href=\"#TCP的4次挥手\" class=\"headerlink\" title=\"TCP的4次挥手\"></a>TCP的4次挥手</h3><ul>\n<li>客户端发送关闭请求</li>\n<li>服务端关闭请求</li>\n<li>服务端发送关闭请求</li>\n<li>客户端发送关闭</li>\n</ul>\n<h4 id=\"TCP的通讯原理\"><a href=\"#TCP的通讯原理\" class=\"headerlink\" title=\"TCP的通讯原理\"></a>TCP的通讯原理</h4><blockquote>\n<p>Socket套接字</p>\n</blockquote>\n<pre><code>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。\n</code></pre><blockquote>\n<p>TCP缓冲区</p>\n</blockquote>\n<pre><code>每个TCP的Socket的内核中都有一个发送缓冲区和一个接收缓冲区。\n</code></pre><blockquote>\n<p>阻塞模式</p>\n</blockquote>\n<pre><code>接收端缓冲区为空，接收端调用read方法的线程阻塞。\n发送端缓冲区满了或者不够大，发送端调用write方法的线程阻塞。\n</code></pre><h4 id=\"TCP中的滑动窗口协议——可靠和高效的结合\"><a href=\"#TCP中的滑动窗口协议——可靠和高效的结合\" class=\"headerlink\" title=\"TCP中的滑动窗口协议——可靠和高效的结合\"></a>TCP中的滑动窗口协议——可靠和高效的结合</h4><ul>\n<li><p>滑动窗口</p>\n<ul>\n<li>发送方和接收方都会维护一个数据帧的序列，这个序列被称作窗口。</li>\n<li>发送方的窗口大小由接收方确认。</li>\n</ul>\n</li>\n<li><p>目的</p>\n<ul>\n<li>确保数据不丢失<ul>\n<li>如果发送的数据丢失了可以重新发。</li>\n</ul>\n</li>\n<li>控制发送速度<ul>\n<li>控制发送速度，以免接收方的缓存不够大导</li>\n<li>致溢出，同时控制流量也可以避免网络拥塞。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>滑动演示:</p>\n<blockquote>\n<p><a href=\"https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html\" target=\"_blank\" rel=\"noopener\">https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html</a></p>\n</blockquote>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"服务端启动 端口8888\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            Socket socket = serverSocket.accept();</span><br><span class=\"line\">            BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class=\"line\">            String buffer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((buffer=bufferedReader.readLine())!=<span class=\"keyword\">null</span>&amp;&amp;!buffer.equals(<span class=\"string\">\"\"</span>))&#123;</span><br><span class=\"line\">                System.out.println(buffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            BufferedWriter bufferedWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">\"HTTP/1.1 200 OK \\r\\n Content-Type:text/json \\r\\n charset=UTF-8 \\r\\n \\r\\n\"</span>);</span><br><span class=\"line\">            bufferedWriter.write(<span class=\"string\">\"11\"</span>);</span><br><span class=\"line\">            bufferedWriter.flush();</span><br><span class=\"line\">            bufferedReader.close();</span><br><span class=\"line\">            bufferedWriter.close();</span><br><span class=\"line\">            socket.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//客户端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    String msg = <span class=\"string\">\"hahahha\"</span>;</span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"127.0.0.1\"</span>,<span class=\"number\">8888</span>);</span><br><span class=\"line\">    PrintWriter printWriter = <span class=\"keyword\">new</span> PrintWriter(socket.getOutputStream());</span><br><span class=\"line\">    printWriter.println(msg);</span><br><span class=\"line\">    printWriter.flush();</span><br><span class=\"line\">    printWriter.close();</span><br><span class=\"line\">    socket.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h4><blockquote>\n<p>UDP协议更快,但是容易丢包 只管发送,不管有没有送达 </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DatagramSocket datagramSocket = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">10005</span>);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        DatagramPacket datagramPacket = <span class=\"keyword\">new</span> DatagramPacket(bytes,bytes.length);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            datagramSocket.receive(datagramPacket);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] data = datagramPacket.getData();</span><br><span class=\"line\">            String str = <span class=\"keyword\">new</span> String(data,<span class=\"number\">0</span>,datagramPacket.getLength());</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">\"88\"</span>.equals(str))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"接收到的数据为：\"</span>+str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        datagramSocket.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//客户端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        DatagramSocket datagramSocket = <span class=\"keyword\">new</span> DatagramSocket();</span><br><span class=\"line\">        BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((line=bufferedReader.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">byte</span>[] bytes = line.getBytes();</span><br><span class=\"line\">            DatagramPacket datagramPacket = <span class=\"keyword\">new</span> DatagramPacket(bytes,bytes.length, InetAddress.getByName(<span class=\"string\">\"127.0.0.1\"</span>),<span class=\"number\">10005</span>);</span><br><span class=\"line\">            datagramSocket.send(datagramPacket);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">\"88\"</span>.equals(line))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"发送的数据是：\"</span>+line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        datagramSocket.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"手写RPC","_content":"\n### 手写RPC\n\n手动编写一个RPC框架，思路如下：\n\n- 主要角色：使用者、服务提供端、服务消费端、注册中心（zookeeper）\n- 实现目标：使用者引入我们的jar包，启动服务之后，需要作为生产者启动一个等待连接的server端口，同时也要作为一个消费者去获取其它的生产者的信息并调用\n- 服务提供端的流程:\n    - 获取所有需要暴露的接口。\n    - 将需要暴露的接口注册到注册中心。\n    - 启动sockerserver等待连接。\n    - 添加编码、解码的handler。\n- 服务消费端的流程:\n    - 从注册中心拉取所有提供者的信息，保存到缓存中（redis、本地..）\n    - 需要监听注册中心的变化，保证缓存中数据的有效性。\n    - 找到所有需要远程调用的接口，并且为其生成代理类（实现发送请求和接收返回数据）。\n\n\n<!-- more -->\n\n以下记录下实现的关键步骤：\n\n#### 服务端启动\n\n服务端启动只需要做两件事，注册和启动socket监听端口。\n\n```java\n// 服务注册\npublic void run() throws Exception {\n    zkRegistry.serviceRegistry();\n    // 启动netty服务\n    rpcServer.start();\n\n}\n```\n\n\n#### 获取所有需要暴露的接口\n\n自定义一个注解（RegistryAnno），使用者在接口实现上使用了该注解，则认为该接口需要暴露，并且将其注册到zk。\n\n```java\npublic void serviceRegistry() throws Exception {\n    // 获取服务中所有的 RegistryAnno 标注的类\n    Map<String, Object> beansByAnno = SpringBeanUtil.getBeansByAnno(RegistryAnno.class);\n    if(beansByAnno.isEmpty()){\n        log.info(\"无需要注册的服务\");\n        return;\n    }\n    // 创建根节点\n    serverZk.createRootIfNotExist();\n    String ip = \"127.0.0.1\";\n    for (Map.Entry<String, Object> entry : beansByAnno.entrySet()) {\n        Object bean = entry.getValue();\n        RegistryAnno annotation = bean.getClass().getAnnotation(RegistryAnno.class);\n        Class<?> aClass = annotation.interfaceClass();\n        // 创建接口节点\n        serverZk.createIfNotExistPre(aClass.getName());\n        // 创建提供者信息节点\n        String node = aClass.getName() + \"/\" + ip + \":\" + rpcProperty.getPort();\n        serverZk.createIfNotExist(node);\n        log.info(\"{}服务注册成功 提供者为 {}\",aClass.getName(),node);\n    }\n}\n```\n\n#### 启动RPC服务端\n\n- 采用Reactor 1+M+N 的线程模型。\n- 此处需要注意handler的顺序，head在出去方向，tail在进入方向，addList则是在head后面的handler链上继续添加。\n- handler一次解码和二次编码都是使用netty自带的编解码器，以消息开始的4个字节记录消息的长度，二次解码则是将bytebuf转换为java对象，一次编码则是将java对象转换为bytebuf。\n\n\n```java\npublic void start() {\n    EventLoopGroup boss = new NioEventLoopGroup(1,new DefaultThreadFactory(\"boss\"));\n    EventLoopGroup worker = new NioEventLoopGroup(0,new DefaultThreadFactory(\"worker\"));\n    EventExecutorGroup business = new NioEventLoopGroup(NettyRuntime.availableProcessors() * 2,new DefaultThreadFactory(\"business\"));\n    try {\n        ServerBootstrap bootstrap  = new ServerBootstrap();\n        bootstrap.group(boss,worker).channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG,1024)\n                .option(ChannelOption.TCP_NODELAY,true)\n                .option(ChannelOption.SO_KEEPALIVE,true)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        ChannelPipeline pipeline = socketChannel.pipeline();\n                        // 返回数据二次编码\n                        pipeline.addLast(\"SecondEnc\",new LengthFieldPrepender(4));\n                        pipeline.addLast(\"firstEnc\",new FirstEnc());\n\n                        // 接受到数据一次解码\n                        pipeline.addLast(\"firstDec\",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0, 4, 0, 4));\n                        pipeline.addLast(\"secondDec\",new SecondDec());\n\n                        // 处理请求\n                        pipeline.addLast(business,\"request\",new RequestChannelHandler());\n                    }\n                })\n        ;\n        ChannelFuture future = bootstrap.bind(rpcProperty.getPort()).syncUninterruptibly();\n        log.info(\"netty server 启动成功\");\n        future.channel().closeFuture().syncUninterruptibly();\n    } catch (InterruptedException e) {\n        log.error(\"\",e);\n    } catch (Exception exception) {\n        exception.printStackTrace();\n    } finally {\n        boss.shutdownGracefully();\n        worker.shutdownGracefully();\n        business.shutdownGracefully();\n    }\n}\n```\n\n#### 服务消费端启动\n\n服务消费端启动只需要拉取注册中心的服务列表。\n\n```java\npublic void discover() throws Exception {\n    List<String> serviceList = serverZk.getServiceList();\n    log.info(\"获取到的节点信息 {}\", JSON.toJSONString(serviceList));\n    if(CollectionUtils.isEmpty(serviceList)){\n        return;\n    }\n    for (String s : serviceList) {\n        serverZk.subscribeZKEvent(s);\n        List<ServiceProvider> serviceInfos = serverZk.getServiceInfos(s);\n        // 将信息保存在缓存（本地缓存、redis等，此处简单使用全局对象）中\n        RegistryInfo.registryMap.put(s,serviceInfos);\n    }\n}\n```\n\n#### 生成代理类\n\n- 使用者在外部接口时，此时容器中是没有接口对象的，需要在使用者在controller、service等添加容器时就生成代理对象并赋值。\n- 使用postprocessor后置处理器中实现。\n- 自定义一个注解（DiscoveryAnno），使用者在使用外部接口时标记该接口是外部的接口。\n- 此处使用cglib代理。\n\n\n```java\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    Field[] fields = bean.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(!field.isAccessible()){\n            field.setAccessible(true);\n        }\n        DiscoveryAnno annotation = field.getAnnotation(DiscoveryAnno.class);\n        if(null==annotation){\n            continue;\n        }\n        // 生成代理对象\n        Class<?> type = field.getType();\n        Object proxyInstance = requestProxy.createProxyObject(type);\n        if(null!=proxyInstance){\n            try {\n                field.set(bean,proxyInstance);\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return bean;\n}\n\n\npublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n    if(ReflectionUtils.isObjectMethod(method)){\n        return method.invoke(method.getDeclaringClass().newInstance(),objects);\n    }\n    RpcRequest rpcRequest = new RpcRequest();\n    rpcRequest.setRequestId(UUID.randomUUID().toString());\n    rpcRequest.setClassName(method.getDeclaringClass().getName());\n    rpcRequest.setMethodName(method.getName());\n    rpcRequest.setParameterTypes(method.getParameterTypes());\n    rpcRequest.setParameters(objects);\n    // 发送请求\n    RequestManage requestManage = SpringBeanUtil.getBean(RequestManage.class);\n    // 发送请求 获取响应\n    RpcResponse rpcResponse = requestManage.sendRequest(rpcRequest);\n    if(null==rpcResponse){\n        return null;\n    }\n    return rpcResponse.getResult();\n}\n```\n\n\n#### 发送请求\n\n- 发送请求时需要从本地缓存中获取到提供方的信息，IP，端口等，用netty进行连接，并发送消息。\n- 需要注意返回消息时，需要阻塞等待消息返回，并且需要区分返回的消息属于哪一个请求（此处使用promise + requestId实现）\n- 发送请求时handler的顺序需要注意，此处与提供者不一样，head在出去server方向，tail在自己方向。\n\n\n```java\npublic RpcResponse sendRequest(RpcRequest rpcRequest) throws Exception {\n        List<ServiceProvider> serviceProviders = RegistryInfo.registryMap.get(rpcRequest.getClassName());\n        if(CollectionUtils.isEmpty(serviceProviders)){\n            throw new Exception();\n        }\n        ServiceProvider serviceProvider = serviceProviders.get(0);\n        return nettySend(serviceProvider, rpcRequest);\n    }\n\n\n    private RpcResponse nettySend(ServiceProvider serviceProvider,RpcRequest rpcRequest) throws InterruptedException, ExecutionException {\n\n        EventLoopGroup eventLoopGroup = new NioEventLoopGroup(0,new DefaultThreadFactory(\"client\"));\n        Bootstrap bootstrap = new Bootstrap();\n        ResponselHandler responselHandler = new ResponselHandler();\n\n        bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>(){\n\n                    @Override\n                    protected void initChannel(SocketChannel channel) throws Exception {\n                        ChannelPipeline pipeline = channel.pipeline();\n\n\n                        pipeline.addLast(\"secondtEnc1\",new SecondEnc());\n                        pipeline.addLast(\"firstEnc1\",new SecondEncResp());\n\n                        pipeline.addLast(\"secondDec1\",new FirstDec());\n                        pipeline.addLast(\"firstDec1\",new FirstDecResp());\n\n                        pipeline.addLast(\"hannler1\",responselHandler);\n\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(serviceProvider.getServerIp(), serviceProvider.getRpcPort()).sync();\n        if(future.isSuccess()){\n\n            Channel channel = future.channel();\n\n            DefaultPromise defaultPromise = new DefaultPromise(channel.eventLoop());\n\n            RegistryInfo.promiseMap.put(rpcRequest.getRequestId(),defaultPromise);\n\n            channel.writeAndFlush(rpcRequest);\n\n            RpcResponse rpcResponse = (RpcResponse) defaultPromise.get();\n\n            return rpcResponse;\n\n        }\n\n        return new RpcResponse();\n\n    }\n```\n\n#### 使用者\n\n- 提供方需要标明需要暴露的接口\n\n```java\n@Service\n@RegistryAnno(interfaceClass = TService.class)\npublic class TServiceImpl implements TService {\n\n    @Override\n    public String doTest() {\n        return \"doTest\";\n    }\n}\n```\n\n- 消费方需要标明外部接口\n\n```java\n@RestController\npublic class MainController {\n\n    @DiscoveryAnno\n    private TService tService;\n\n\n    @RequestMapping(\"/first\")\n    public String rpcTest() {\n        return tService.doTest();\n    }\n}\n```","source":"_posts/RPC.md","raw":"---\ntitle: 手写RPC\ntags:\n  - rpc\n---\n\n### 手写RPC\n\n手动编写一个RPC框架，思路如下：\n\n- 主要角色：使用者、服务提供端、服务消费端、注册中心（zookeeper）\n- 实现目标：使用者引入我们的jar包，启动服务之后，需要作为生产者启动一个等待连接的server端口，同时也要作为一个消费者去获取其它的生产者的信息并调用\n- 服务提供端的流程:\n    - 获取所有需要暴露的接口。\n    - 将需要暴露的接口注册到注册中心。\n    - 启动sockerserver等待连接。\n    - 添加编码、解码的handler。\n- 服务消费端的流程:\n    - 从注册中心拉取所有提供者的信息，保存到缓存中（redis、本地..）\n    - 需要监听注册中心的变化，保证缓存中数据的有效性。\n    - 找到所有需要远程调用的接口，并且为其生成代理类（实现发送请求和接收返回数据）。\n\n\n<!-- more -->\n\n以下记录下实现的关键步骤：\n\n#### 服务端启动\n\n服务端启动只需要做两件事，注册和启动socket监听端口。\n\n```java\n// 服务注册\npublic void run() throws Exception {\n    zkRegistry.serviceRegistry();\n    // 启动netty服务\n    rpcServer.start();\n\n}\n```\n\n\n#### 获取所有需要暴露的接口\n\n自定义一个注解（RegistryAnno），使用者在接口实现上使用了该注解，则认为该接口需要暴露，并且将其注册到zk。\n\n```java\npublic void serviceRegistry() throws Exception {\n    // 获取服务中所有的 RegistryAnno 标注的类\n    Map<String, Object> beansByAnno = SpringBeanUtil.getBeansByAnno(RegistryAnno.class);\n    if(beansByAnno.isEmpty()){\n        log.info(\"无需要注册的服务\");\n        return;\n    }\n    // 创建根节点\n    serverZk.createRootIfNotExist();\n    String ip = \"127.0.0.1\";\n    for (Map.Entry<String, Object> entry : beansByAnno.entrySet()) {\n        Object bean = entry.getValue();\n        RegistryAnno annotation = bean.getClass().getAnnotation(RegistryAnno.class);\n        Class<?> aClass = annotation.interfaceClass();\n        // 创建接口节点\n        serverZk.createIfNotExistPre(aClass.getName());\n        // 创建提供者信息节点\n        String node = aClass.getName() + \"/\" + ip + \":\" + rpcProperty.getPort();\n        serverZk.createIfNotExist(node);\n        log.info(\"{}服务注册成功 提供者为 {}\",aClass.getName(),node);\n    }\n}\n```\n\n#### 启动RPC服务端\n\n- 采用Reactor 1+M+N 的线程模型。\n- 此处需要注意handler的顺序，head在出去方向，tail在进入方向，addList则是在head后面的handler链上继续添加。\n- handler一次解码和二次编码都是使用netty自带的编解码器，以消息开始的4个字节记录消息的长度，二次解码则是将bytebuf转换为java对象，一次编码则是将java对象转换为bytebuf。\n\n\n```java\npublic void start() {\n    EventLoopGroup boss = new NioEventLoopGroup(1,new DefaultThreadFactory(\"boss\"));\n    EventLoopGroup worker = new NioEventLoopGroup(0,new DefaultThreadFactory(\"worker\"));\n    EventExecutorGroup business = new NioEventLoopGroup(NettyRuntime.availableProcessors() * 2,new DefaultThreadFactory(\"business\"));\n    try {\n        ServerBootstrap bootstrap  = new ServerBootstrap();\n        bootstrap.group(boss,worker).channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG,1024)\n                .option(ChannelOption.TCP_NODELAY,true)\n                .option(ChannelOption.SO_KEEPALIVE,true)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        ChannelPipeline pipeline = socketChannel.pipeline();\n                        // 返回数据二次编码\n                        pipeline.addLast(\"SecondEnc\",new LengthFieldPrepender(4));\n                        pipeline.addLast(\"firstEnc\",new FirstEnc());\n\n                        // 接受到数据一次解码\n                        pipeline.addLast(\"firstDec\",new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0, 4, 0, 4));\n                        pipeline.addLast(\"secondDec\",new SecondDec());\n\n                        // 处理请求\n                        pipeline.addLast(business,\"request\",new RequestChannelHandler());\n                    }\n                })\n        ;\n        ChannelFuture future = bootstrap.bind(rpcProperty.getPort()).syncUninterruptibly();\n        log.info(\"netty server 启动成功\");\n        future.channel().closeFuture().syncUninterruptibly();\n    } catch (InterruptedException e) {\n        log.error(\"\",e);\n    } catch (Exception exception) {\n        exception.printStackTrace();\n    } finally {\n        boss.shutdownGracefully();\n        worker.shutdownGracefully();\n        business.shutdownGracefully();\n    }\n}\n```\n\n#### 服务消费端启动\n\n服务消费端启动只需要拉取注册中心的服务列表。\n\n```java\npublic void discover() throws Exception {\n    List<String> serviceList = serverZk.getServiceList();\n    log.info(\"获取到的节点信息 {}\", JSON.toJSONString(serviceList));\n    if(CollectionUtils.isEmpty(serviceList)){\n        return;\n    }\n    for (String s : serviceList) {\n        serverZk.subscribeZKEvent(s);\n        List<ServiceProvider> serviceInfos = serverZk.getServiceInfos(s);\n        // 将信息保存在缓存（本地缓存、redis等，此处简单使用全局对象）中\n        RegistryInfo.registryMap.put(s,serviceInfos);\n    }\n}\n```\n\n#### 生成代理类\n\n- 使用者在外部接口时，此时容器中是没有接口对象的，需要在使用者在controller、service等添加容器时就生成代理对象并赋值。\n- 使用postprocessor后置处理器中实现。\n- 自定义一个注解（DiscoveryAnno），使用者在使用外部接口时标记该接口是外部的接口。\n- 此处使用cglib代理。\n\n\n```java\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    Field[] fields = bean.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(!field.isAccessible()){\n            field.setAccessible(true);\n        }\n        DiscoveryAnno annotation = field.getAnnotation(DiscoveryAnno.class);\n        if(null==annotation){\n            continue;\n        }\n        // 生成代理对象\n        Class<?> type = field.getType();\n        Object proxyInstance = requestProxy.createProxyObject(type);\n        if(null!=proxyInstance){\n            try {\n                field.set(bean,proxyInstance);\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return bean;\n}\n\n\npublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n    if(ReflectionUtils.isObjectMethod(method)){\n        return method.invoke(method.getDeclaringClass().newInstance(),objects);\n    }\n    RpcRequest rpcRequest = new RpcRequest();\n    rpcRequest.setRequestId(UUID.randomUUID().toString());\n    rpcRequest.setClassName(method.getDeclaringClass().getName());\n    rpcRequest.setMethodName(method.getName());\n    rpcRequest.setParameterTypes(method.getParameterTypes());\n    rpcRequest.setParameters(objects);\n    // 发送请求\n    RequestManage requestManage = SpringBeanUtil.getBean(RequestManage.class);\n    // 发送请求 获取响应\n    RpcResponse rpcResponse = requestManage.sendRequest(rpcRequest);\n    if(null==rpcResponse){\n        return null;\n    }\n    return rpcResponse.getResult();\n}\n```\n\n\n#### 发送请求\n\n- 发送请求时需要从本地缓存中获取到提供方的信息，IP，端口等，用netty进行连接，并发送消息。\n- 需要注意返回消息时，需要阻塞等待消息返回，并且需要区分返回的消息属于哪一个请求（此处使用promise + requestId实现）\n- 发送请求时handler的顺序需要注意，此处与提供者不一样，head在出去server方向，tail在自己方向。\n\n\n```java\npublic RpcResponse sendRequest(RpcRequest rpcRequest) throws Exception {\n        List<ServiceProvider> serviceProviders = RegistryInfo.registryMap.get(rpcRequest.getClassName());\n        if(CollectionUtils.isEmpty(serviceProviders)){\n            throw new Exception();\n        }\n        ServiceProvider serviceProvider = serviceProviders.get(0);\n        return nettySend(serviceProvider, rpcRequest);\n    }\n\n\n    private RpcResponse nettySend(ServiceProvider serviceProvider,RpcRequest rpcRequest) throws InterruptedException, ExecutionException {\n\n        EventLoopGroup eventLoopGroup = new NioEventLoopGroup(0,new DefaultThreadFactory(\"client\"));\n        Bootstrap bootstrap = new Bootstrap();\n        ResponselHandler responselHandler = new ResponselHandler();\n\n        bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>(){\n\n                    @Override\n                    protected void initChannel(SocketChannel channel) throws Exception {\n                        ChannelPipeline pipeline = channel.pipeline();\n\n\n                        pipeline.addLast(\"secondtEnc1\",new SecondEnc());\n                        pipeline.addLast(\"firstEnc1\",new SecondEncResp());\n\n                        pipeline.addLast(\"secondDec1\",new FirstDec());\n                        pipeline.addLast(\"firstDec1\",new FirstDecResp());\n\n                        pipeline.addLast(\"hannler1\",responselHandler);\n\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(serviceProvider.getServerIp(), serviceProvider.getRpcPort()).sync();\n        if(future.isSuccess()){\n\n            Channel channel = future.channel();\n\n            DefaultPromise defaultPromise = new DefaultPromise(channel.eventLoop());\n\n            RegistryInfo.promiseMap.put(rpcRequest.getRequestId(),defaultPromise);\n\n            channel.writeAndFlush(rpcRequest);\n\n            RpcResponse rpcResponse = (RpcResponse) defaultPromise.get();\n\n            return rpcResponse;\n\n        }\n\n        return new RpcResponse();\n\n    }\n```\n\n#### 使用者\n\n- 提供方需要标明需要暴露的接口\n\n```java\n@Service\n@RegistryAnno(interfaceClass = TService.class)\npublic class TServiceImpl implements TService {\n\n    @Override\n    public String doTest() {\n        return \"doTest\";\n    }\n}\n```\n\n- 消费方需要标明外部接口\n\n```java\n@RestController\npublic class MainController {\n\n    @DiscoveryAnno\n    private TService tService;\n\n\n    @RequestMapping(\"/first\")\n    public String rpcTest() {\n        return tService.doTest();\n    }\n}\n```","slug":"RPC","published":1,"date":"2025-02-12T08:28:16.463Z","updated":"2025-02-12T08:28:16.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm71nfvo50000nnxf3r3i3msw","content":"<h3 id=\"手写RPC\"><a href=\"#手写RPC\" class=\"headerlink\" title=\"手写RPC\"></a>手写RPC</h3><p>手动编写一个RPC框架，思路如下：</p>\n<ul>\n<li>主要角色：使用者、服务提供端、服务消费端、注册中心（zookeeper）</li>\n<li>实现目标：使用者引入我们的jar包，启动服务之后，需要作为生产者启动一个等待连接的server端口，同时也要作为一个消费者去获取其它的生产者的信息并调用</li>\n<li>服务提供端的流程:<ul>\n<li>获取所有需要暴露的接口。</li>\n<li>将需要暴露的接口注册到注册中心。</li>\n<li>启动sockerserver等待连接。</li>\n<li>添加编码、解码的handler。</li>\n</ul>\n</li>\n<li>服务消费端的流程:<ul>\n<li>从注册中心拉取所有提供者的信息，保存到缓存中（redis、本地..）</li>\n<li>需要监听注册中心的变化，保证缓存中数据的有效性。</li>\n<li>找到所有需要远程调用的接口，并且为其生成代理类（实现发送请求和接收返回数据）。</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>以下记录下实现的关键步骤：</p>\n<h4 id=\"服务端启动\"><a href=\"#服务端启动\" class=\"headerlink\" title=\"服务端启动\"></a>服务端启动</h4><p>服务端启动只需要做两件事，注册和启动socket监听端口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 服务注册</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    zkRegistry.serviceRegistry();</span><br><span class=\"line\">    <span class=\"comment\">// 启动netty服务</span></span><br><span class=\"line\">    rpcServer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"获取所有需要暴露的接口\"><a href=\"#获取所有需要暴露的接口\" class=\"headerlink\" title=\"获取所有需要暴露的接口\"></a>获取所有需要暴露的接口</h4><p>自定义一个注解（RegistryAnno），使用者在接口实现上使用了该注解，则认为该接口需要暴露，并且将其注册到zk。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">serviceRegistry</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取服务中所有的 RegistryAnno 标注的类</span></span><br><span class=\"line\">    Map&lt;String, Object&gt; beansByAnno = SpringBeanUtil.getBeansByAnno(RegistryAnno.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(beansByAnno.isEmpty())&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"无需要注册的服务\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建根节点</span></span><br><span class=\"line\">    serverZk.createRootIfNotExist();</span><br><span class=\"line\">    String ip = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;String, Object&gt; entry : beansByAnno.entrySet()) &#123;</span><br><span class=\"line\">        Object bean = entry.getValue();</span><br><span class=\"line\">        RegistryAnno annotation = bean.getClass().getAnnotation(RegistryAnno.class);</span><br><span class=\"line\">        Class&lt;?&gt; aClass = annotation.interfaceClass();</span><br><span class=\"line\">        <span class=\"comment\">// 创建接口节点</span></span><br><span class=\"line\">        serverZk.createIfNotExistPre(aClass.getName());</span><br><span class=\"line\">        <span class=\"comment\">// 创建提供者信息节点</span></span><br><span class=\"line\">        String node = aClass.getName() + <span class=\"string\">\"/\"</span> + ip + <span class=\"string\">\":\"</span> + rpcProperty.getPort();</span><br><span class=\"line\">        serverZk.createIfNotExist(node);</span><br><span class=\"line\">        log.info(<span class=\"string\">\"&#123;&#125;服务注册成功 提供者为 &#123;&#125;\"</span>,aClass.getName(),node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动RPC服务端\"><a href=\"#启动RPC服务端\" class=\"headerlink\" title=\"启动RPC服务端\"></a>启动RPC服务端</h4><ul>\n<li>采用Reactor 1+M+N 的线程模型。</li>\n<li>此处需要注意handler的顺序，head在出去方向，tail在进入方向，addList则是在head后面的handler链上继续添加。</li>\n<li>handler一次解码和二次编码都是使用netty自带的编解码器，以消息开始的4个字节记录消息的长度，二次解码则是将bytebuf转换为java对象，一次编码则是将java对象转换为bytebuf。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    EventLoopGroup boss = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"boss\"</span>));</span><br><span class=\"line\">    EventLoopGroup worker = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">0</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"worker\"</span>));</span><br><span class=\"line\">    EventExecutorGroup business = <span class=\"keyword\">new</span> NioEventLoopGroup(NettyRuntime.availableProcessors() * <span class=\"number\">2</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"business\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ServerBootstrap bootstrap  = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">        bootstrap.group(boss,worker).channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .option(ChannelOption.SO_BACKLOG,<span class=\"number\">1024</span>)</span><br><span class=\"line\">                .option(ChannelOption.TCP_NODELAY,<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .option(ChannelOption.SO_KEEPALIVE,<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class=\"line\">                        <span class=\"comment\">// 返回数据二次编码</span></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"SecondEnc\"</span>,<span class=\"keyword\">new</span> LengthFieldPrepender(<span class=\"number\">4</span>));</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstEnc\"</span>,<span class=\"keyword\">new</span> FirstEnc());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 接受到数据一次解码</span></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstDec\"</span>,<span class=\"keyword\">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"secondDec\"</span>,<span class=\"keyword\">new</span> SecondDec());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 处理请求</span></span><br><span class=\"line\">                        pipeline.addLast(business,<span class=\"string\">\"request\"</span>,<span class=\"keyword\">new</span> RequestChannelHandler());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">        ChannelFuture future = bootstrap.bind(rpcProperty.getPort()).syncUninterruptibly();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"netty server 启动成功\"</span>);</span><br><span class=\"line\">        future.channel().closeFuture().syncUninterruptibly();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">\"\"</span>,e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">        exception.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        boss.shutdownGracefully();</span><br><span class=\"line\">        worker.shutdownGracefully();</span><br><span class=\"line\">        business.shutdownGracefully();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务消费端启动\"><a href=\"#服务消费端启动\" class=\"headerlink\" title=\"服务消费端启动\"></a>服务消费端启动</h4><p>服务消费端启动只需要拉取注册中心的服务列表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">discover</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; serviceList = serverZk.getServiceList();</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到的节点信息 &#123;&#125;\"</span>, JSON.toJSONString(serviceList));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(CollectionUtils.isEmpty(serviceList))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : serviceList) &#123;</span><br><span class=\"line\">        serverZk.subscribeZKEvent(s);</span><br><span class=\"line\">        List&lt;ServiceProvider&gt; serviceInfos = serverZk.getServiceInfos(s);</span><br><span class=\"line\">        <span class=\"comment\">// 将信息保存在缓存（本地缓存、redis等，此处简单使用全局对象）中</span></span><br><span class=\"line\">        RegistryInfo.registryMap.put(s,serviceInfos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成代理类\"><a href=\"#生成代理类\" class=\"headerlink\" title=\"生成代理类\"></a>生成代理类</h4><ul>\n<li>使用者在外部接口时，此时容器中是没有接口对象的，需要在使用者在controller、service等添加容器时就生成代理对象并赋值。</li>\n<li>使用postprocessor后置处理器中实现。</li>\n<li>自定义一个注解（DiscoveryAnno），使用者在使用外部接口时标记该接口是外部的接口。</li>\n<li>此处使用cglib代理。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!field.isAccessible())&#123;</span><br><span class=\"line\">            field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        DiscoveryAnno annotation = field.getAnnotation(DiscoveryAnno.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span>==annotation)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 生成代理对象</span></span><br><span class=\"line\">        Class&lt;?&gt; type = field.getType();</span><br><span class=\"line\">        Object proxyInstance = requestProxy.createProxyObject(type);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span>!=proxyInstance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                field.set(bean,proxyInstance);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ReflectionUtils.isObjectMethod(method))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(method.getDeclaringClass().newInstance(),objects);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcRequest rpcRequest = <span class=\"keyword\">new</span> RpcRequest();</span><br><span class=\"line\">    rpcRequest.setRequestId(UUID.randomUUID().toString());</span><br><span class=\"line\">    rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class=\"line\">    rpcRequest.setMethodName(method.getName());</span><br><span class=\"line\">    rpcRequest.setParameterTypes(method.getParameterTypes());</span><br><span class=\"line\">    rpcRequest.setParameters(objects);</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求</span></span><br><span class=\"line\">    RequestManage requestManage = SpringBeanUtil.getBean(RequestManage.class);</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求 获取响应</span></span><br><span class=\"line\">    RpcResponse rpcResponse = requestManage.sendRequest(rpcRequest);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span>==rpcResponse)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rpcResponse.getResult();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送请求\"><a href=\"#发送请求\" class=\"headerlink\" title=\"发送请求\"></a>发送请求</h4><ul>\n<li>发送请求时需要从本地缓存中获取到提供方的信息，IP，端口等，用netty进行连接，并发送消息。</li>\n<li>需要注意返回消息时，需要阻塞等待消息返回，并且需要区分返回的消息属于哪一个请求（此处使用promise + requestId实现）</li>\n<li>发送请求时handler的顺序需要注意，此处与提供者不一样，head在出去server方向，tail在自己方向。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RpcResponse <span class=\"title\">sendRequest</span><span class=\"params\">(RpcRequest rpcRequest)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;ServiceProvider&gt; serviceProviders = RegistryInfo.registryMap.get(rpcRequest.getClassName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CollectionUtils.isEmpty(serviceProviders))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ServiceProvider serviceProvider = serviceProviders.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nettySend(serviceProvider, rpcRequest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> RpcResponse <span class=\"title\">nettySend</span><span class=\"params\">(ServiceProvider serviceProvider,RpcRequest rpcRequest)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        EventLoopGroup eventLoopGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">0</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"client\"</span>));</span><br><span class=\"line\">        Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">        ResponselHandler responselHandler = <span class=\"keyword\">new</span> ResponselHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">        bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)</span><br><span class=\"line\">                .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        ChannelPipeline pipeline = channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"secondtEnc1\"</span>,<span class=\"keyword\">new</span> SecondEnc());</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstEnc1\"</span>,<span class=\"keyword\">new</span> SecondEncResp());</span><br><span class=\"line\"></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"secondDec1\"</span>,<span class=\"keyword\">new</span> FirstDec());</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstDec1\"</span>,<span class=\"keyword\">new</span> FirstDecResp());</span><br><span class=\"line\"></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"hannler1\"</span>,responselHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        ChannelFuture future = bootstrap.connect(serviceProvider.getServerIp(), serviceProvider.getRpcPort()).sync();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(future.isSuccess())&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Channel channel = future.channel();</span><br><span class=\"line\"></span><br><span class=\"line\">            DefaultPromise defaultPromise = <span class=\"keyword\">new</span> DefaultPromise(channel.eventLoop());</span><br><span class=\"line\"></span><br><span class=\"line\">            RegistryInfo.promiseMap.put(rpcRequest.getRequestId(),defaultPromise);</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.writeAndFlush(rpcRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">            RpcResponse rpcResponse = (RpcResponse) defaultPromise.get();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> rpcResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResponse();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用者\"><a href=\"#使用者\" class=\"headerlink\" title=\"使用者\"></a>使用者</h4><ul>\n<li>提供方需要标明需要暴露的接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@RegistryAnno</span>(interfaceClass = TService.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">doTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"doTest\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>消费方需要标明外部接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DiscoveryAnno</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TService tService;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/first\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">rpcTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tService.doTest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"手写RPC\"><a href=\"#手写RPC\" class=\"headerlink\" title=\"手写RPC\"></a>手写RPC</h3><p>手动编写一个RPC框架，思路如下：</p>\n<ul>\n<li>主要角色：使用者、服务提供端、服务消费端、注册中心（zookeeper）</li>\n<li>实现目标：使用者引入我们的jar包，启动服务之后，需要作为生产者启动一个等待连接的server端口，同时也要作为一个消费者去获取其它的生产者的信息并调用</li>\n<li>服务提供端的流程:<ul>\n<li>获取所有需要暴露的接口。</li>\n<li>将需要暴露的接口注册到注册中心。</li>\n<li>启动sockerserver等待连接。</li>\n<li>添加编码、解码的handler。</li>\n</ul>\n</li>\n<li>服务消费端的流程:<ul>\n<li>从注册中心拉取所有提供者的信息，保存到缓存中（redis、本地..）</li>\n<li>需要监听注册中心的变化，保证缓存中数据的有效性。</li>\n<li>找到所有需要远程调用的接口，并且为其生成代理类（实现发送请求和接收返回数据）。</li>\n</ul>\n</li>\n</ul>","more":"<p>以下记录下实现的关键步骤：</p>\n<h4 id=\"服务端启动\"><a href=\"#服务端启动\" class=\"headerlink\" title=\"服务端启动\"></a>服务端启动</h4><p>服务端启动只需要做两件事，注册和启动socket监听端口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 服务注册</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    zkRegistry.serviceRegistry();</span><br><span class=\"line\">    <span class=\"comment\">// 启动netty服务</span></span><br><span class=\"line\">    rpcServer.start();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"获取所有需要暴露的接口\"><a href=\"#获取所有需要暴露的接口\" class=\"headerlink\" title=\"获取所有需要暴露的接口\"></a>获取所有需要暴露的接口</h4><p>自定义一个注解（RegistryAnno），使用者在接口实现上使用了该注解，则认为该接口需要暴露，并且将其注册到zk。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">serviceRegistry</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取服务中所有的 RegistryAnno 标注的类</span></span><br><span class=\"line\">    Map&lt;String, Object&gt; beansByAnno = SpringBeanUtil.getBeansByAnno(RegistryAnno.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(beansByAnno.isEmpty())&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"无需要注册的服务\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建根节点</span></span><br><span class=\"line\">    serverZk.createRootIfNotExist();</span><br><span class=\"line\">    String ip = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;String, Object&gt; entry : beansByAnno.entrySet()) &#123;</span><br><span class=\"line\">        Object bean = entry.getValue();</span><br><span class=\"line\">        RegistryAnno annotation = bean.getClass().getAnnotation(RegistryAnno.class);</span><br><span class=\"line\">        Class&lt;?&gt; aClass = annotation.interfaceClass();</span><br><span class=\"line\">        <span class=\"comment\">// 创建接口节点</span></span><br><span class=\"line\">        serverZk.createIfNotExistPre(aClass.getName());</span><br><span class=\"line\">        <span class=\"comment\">// 创建提供者信息节点</span></span><br><span class=\"line\">        String node = aClass.getName() + <span class=\"string\">\"/\"</span> + ip + <span class=\"string\">\":\"</span> + rpcProperty.getPort();</span><br><span class=\"line\">        serverZk.createIfNotExist(node);</span><br><span class=\"line\">        log.info(<span class=\"string\">\"&#123;&#125;服务注册成功 提供者为 &#123;&#125;\"</span>,aClass.getName(),node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动RPC服务端\"><a href=\"#启动RPC服务端\" class=\"headerlink\" title=\"启动RPC服务端\"></a>启动RPC服务端</h4><ul>\n<li>采用Reactor 1+M+N 的线程模型。</li>\n<li>此处需要注意handler的顺序，head在出去方向，tail在进入方向，addList则是在head后面的handler链上继续添加。</li>\n<li>handler一次解码和二次编码都是使用netty自带的编解码器，以消息开始的4个字节记录消息的长度，二次解码则是将bytebuf转换为java对象，一次编码则是将java对象转换为bytebuf。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    EventLoopGroup boss = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"boss\"</span>));</span><br><span class=\"line\">    EventLoopGroup worker = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">0</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"worker\"</span>));</span><br><span class=\"line\">    EventExecutorGroup business = <span class=\"keyword\">new</span> NioEventLoopGroup(NettyRuntime.availableProcessors() * <span class=\"number\">2</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"business\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ServerBootstrap bootstrap  = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">        bootstrap.group(boss,worker).channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .option(ChannelOption.SO_BACKLOG,<span class=\"number\">1024</span>)</span><br><span class=\"line\">                .option(ChannelOption.TCP_NODELAY,<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .option(ChannelOption.SO_KEEPALIVE,<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class=\"line\">                        <span class=\"comment\">// 返回数据二次编码</span></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"SecondEnc\"</span>,<span class=\"keyword\">new</span> LengthFieldPrepender(<span class=\"number\">4</span>));</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstEnc\"</span>,<span class=\"keyword\">new</span> FirstEnc());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 接受到数据一次解码</span></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstDec\"</span>,<span class=\"keyword\">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"secondDec\"</span>,<span class=\"keyword\">new</span> SecondDec());</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 处理请求</span></span><br><span class=\"line\">                        pipeline.addLast(business,<span class=\"string\">\"request\"</span>,<span class=\"keyword\">new</span> RequestChannelHandler());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        ;</span><br><span class=\"line\">        ChannelFuture future = bootstrap.bind(rpcProperty.getPort()).syncUninterruptibly();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"netty server 启动成功\"</span>);</span><br><span class=\"line\">        future.channel().closeFuture().syncUninterruptibly();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">\"\"</span>,e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">        exception.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        boss.shutdownGracefully();</span><br><span class=\"line\">        worker.shutdownGracefully();</span><br><span class=\"line\">        business.shutdownGracefully();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"服务消费端启动\"><a href=\"#服务消费端启动\" class=\"headerlink\" title=\"服务消费端启动\"></a>服务消费端启动</h4><p>服务消费端启动只需要拉取注册中心的服务列表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">discover</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; serviceList = serverZk.getServiceList();</span><br><span class=\"line\">    log.info(<span class=\"string\">\"获取到的节点信息 &#123;&#125;\"</span>, JSON.toJSONString(serviceList));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(CollectionUtils.isEmpty(serviceList))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : serviceList) &#123;</span><br><span class=\"line\">        serverZk.subscribeZKEvent(s);</span><br><span class=\"line\">        List&lt;ServiceProvider&gt; serviceInfos = serverZk.getServiceInfos(s);</span><br><span class=\"line\">        <span class=\"comment\">// 将信息保存在缓存（本地缓存、redis等，此处简单使用全局对象）中</span></span><br><span class=\"line\">        RegistryInfo.registryMap.put(s,serviceInfos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成代理类\"><a href=\"#生成代理类\" class=\"headerlink\" title=\"生成代理类\"></a>生成代理类</h4><ul>\n<li>使用者在外部接口时，此时容器中是没有接口对象的，需要在使用者在controller、service等添加容器时就生成代理对象并赋值。</li>\n<li>使用postprocessor后置处理器中实现。</li>\n<li>自定义一个注解（DiscoveryAnno），使用者在使用外部接口时标记该接口是外部的接口。</li>\n<li>此处使用cglib代理。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!field.isAccessible())&#123;</span><br><span class=\"line\">            field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        DiscoveryAnno annotation = field.getAnnotation(DiscoveryAnno.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span>==annotation)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 生成代理对象</span></span><br><span class=\"line\">        Class&lt;?&gt; type = field.getType();</span><br><span class=\"line\">        Object proxyInstance = requestProxy.createProxyObject(type);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span>!=proxyInstance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                field.set(bean,proxyInstance);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ReflectionUtils.isObjectMethod(method))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.invoke(method.getDeclaringClass().newInstance(),objects);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcRequest rpcRequest = <span class=\"keyword\">new</span> RpcRequest();</span><br><span class=\"line\">    rpcRequest.setRequestId(UUID.randomUUID().toString());</span><br><span class=\"line\">    rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class=\"line\">    rpcRequest.setMethodName(method.getName());</span><br><span class=\"line\">    rpcRequest.setParameterTypes(method.getParameterTypes());</span><br><span class=\"line\">    rpcRequest.setParameters(objects);</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求</span></span><br><span class=\"line\">    RequestManage requestManage = SpringBeanUtil.getBean(RequestManage.class);</span><br><span class=\"line\">    <span class=\"comment\">// 发送请求 获取响应</span></span><br><span class=\"line\">    RpcResponse rpcResponse = requestManage.sendRequest(rpcRequest);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span>==rpcResponse)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rpcResponse.getResult();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送请求\"><a href=\"#发送请求\" class=\"headerlink\" title=\"发送请求\"></a>发送请求</h4><ul>\n<li>发送请求时需要从本地缓存中获取到提供方的信息，IP，端口等，用netty进行连接，并发送消息。</li>\n<li>需要注意返回消息时，需要阻塞等待消息返回，并且需要区分返回的消息属于哪一个请求（此处使用promise + requestId实现）</li>\n<li>发送请求时handler的顺序需要注意，此处与提供者不一样，head在出去server方向，tail在自己方向。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RpcResponse <span class=\"title\">sendRequest</span><span class=\"params\">(RpcRequest rpcRequest)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;ServiceProvider&gt; serviceProviders = RegistryInfo.registryMap.get(rpcRequest.getClassName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(CollectionUtils.isEmpty(serviceProviders))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ServiceProvider serviceProvider = serviceProviders.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nettySend(serviceProvider, rpcRequest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> RpcResponse <span class=\"title\">nettySend</span><span class=\"params\">(ServiceProvider serviceProvider,RpcRequest rpcRequest)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        EventLoopGroup eventLoopGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">0</span>,<span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"client\"</span>));</span><br><span class=\"line\">        Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">        ResponselHandler responselHandler = <span class=\"keyword\">new</span> ResponselHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">        bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)</span><br><span class=\"line\">                .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel channel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        ChannelPipeline pipeline = channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"secondtEnc1\"</span>,<span class=\"keyword\">new</span> SecondEnc());</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstEnc1\"</span>,<span class=\"keyword\">new</span> SecondEncResp());</span><br><span class=\"line\"></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"secondDec1\"</span>,<span class=\"keyword\">new</span> FirstDec());</span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"firstDec1\"</span>,<span class=\"keyword\">new</span> FirstDecResp());</span><br><span class=\"line\"></span><br><span class=\"line\">                        pipeline.addLast(<span class=\"string\">\"hannler1\"</span>,responselHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        ChannelFuture future = bootstrap.connect(serviceProvider.getServerIp(), serviceProvider.getRpcPort()).sync();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(future.isSuccess())&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Channel channel = future.channel();</span><br><span class=\"line\"></span><br><span class=\"line\">            DefaultPromise defaultPromise = <span class=\"keyword\">new</span> DefaultPromise(channel.eventLoop());</span><br><span class=\"line\"></span><br><span class=\"line\">            RegistryInfo.promiseMap.put(rpcRequest.getRequestId(),defaultPromise);</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.writeAndFlush(rpcRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">            RpcResponse rpcResponse = (RpcResponse) defaultPromise.get();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> rpcResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResponse();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用者\"><a href=\"#使用者\" class=\"headerlink\" title=\"使用者\"></a>使用者</h4><ul>\n<li>提供方需要标明需要暴露的接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@RegistryAnno</span>(interfaceClass = TService.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">doTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"doTest\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>消费方需要标明外部接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DiscoveryAnno</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TService tService;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/first\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">rpcTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tService.doTest();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"clhua15al00159gj76ig3w433","category_id":"clhua15an00199gj75zgroyn3","_id":"clhua15as001j9gj78reyv8rg"}],"PostTag":[{"post_id":"clhua15a100099gj7e3r214qi","tag_id":"clhua159x00059gj7jj192i14","_id":"clhua15a6000d9gj7tjcmpokw"},{"post_id":"clhua159t00029gj7k1b2egzd","tag_id":"clhua159x00059gj7jj192i14","_id":"clhua15a7000g9gj7kza46zug"},{"post_id":"clhua15a7000f9gj7kcahn1nb","tag_id":"clhua159x00059gj7jj192i14","_id":"clhua15a9000j9gj7g881xj3n"},{"post_id":"clhua159w00049gj7n85qonmv","tag_id":"clhua159x00059gj7jj192i14","_id":"clhua15aa000l9gj7l93ib430"},{"post_id":"clhua159z00079gj74817ite0","tag_id":"clhua159x00059gj7jj192i14","_id":"clhua15ac000o9gj757k8zsyc"},{"post_id":"clhua15ac000p9gj70wqei9h0","tag_id":"clhua15ab000n9gj7v8t0t465","_id":"clhua15ae000s9gj7z85p7xk6"},{"post_id":"clhua15a4000b9gj7flwk208t","tag_id":"clhua15ab000n9gj7v8t0t465","_id":"clhua15af000u9gj7bpgym1dk"},{"post_id":"clhua15a8000h9gj7oognj8oq","tag_id":"clhua15ab000n9gj7v8t0t465","_id":"clhua15ah000y9gj7ok2zsway"},{"post_id":"clhua15a9000k9gj7z4fbhhab","tag_id":"clhua15ab000n9gj7v8t0t465","_id":"clhua15aj00129gj7d4wuo0i9"},{"post_id":"clhua15ab000m9gj7xud3s0ed","tag_id":"clhua15ab000n9gj7v8t0t465","_id":"clhua15al00169gj706y7f97n"},{"post_id":"clhua15ad000q9gj7vmhsobfp","tag_id":"clhua15ak00149gj75mou1i84","_id":"clhua15ao001b9gj7csk0waqa"},{"post_id":"clhua15af000t9gj7vfcwpqa2","tag_id":"clhua15am00189gj7l3nkzdrm","_id":"clhua15aq001f9gj7uw133f36"},{"post_id":"clhua15af000v9gj7pb3di8sn","tag_id":"clhua15am00189gj7l3nkzdrm","_id":"clhua15as001k9gj7yrmsfi04"},{"post_id":"clhua15ah000x9gj70i70ogpw","tag_id":"clhua15am00189gj7l3nkzdrm","_id":"clhua15au001o9gj73x9ejdxn"},{"post_id":"clhua15ah000z9gj79uh4l5sa","tag_id":"clhua15am00189gj7l3nkzdrm","_id":"clhua15aw001s9gj7532f5v2u"},{"post_id":"clhua15aj00119gj7alwyzc8o","tag_id":"clhua15av001q9gj7kiomaiqw","_id":"clhua15ay001w9gj7sw3rt6ox"},{"post_id":"clhua15aj00139gj7vw55hkey","tag_id":"clhua15am00189gj7l3nkzdrm","_id":"clhua15b000209gj7uw8ec605"},{"post_id":"clhua15al00159gj76ig3w433","tag_id":"clhua15az001z9gj7j81o709o","_id":"clhua15b200259gj7lhx3r1bl"},{"post_id":"clhua15al00179gj7gjx646i5","tag_id":"clhua15b100239gj7pe3ghfad","_id":"clhua15b400299gj7j5lpfi98"},{"post_id":"clhua15an001a9gj736rvzzzz","tag_id":"clhua15b100239gj7pe3ghfad","_id":"clhua15b5002d9gj77tkkix3k"},{"post_id":"clhua15ao001c9gj7oxhvr7hr","tag_id":"clhua15b5002b9gj7ohbiqpgv","_id":"clhua15bc002k9gj77jjgpr4v"},{"post_id":"clhua15ao001c9gj7oxhvr7hr","tag_id":"clhua15b6002f9gj7zd2y5j99","_id":"clhua15bd002m9gj7ekjsqfga"},{"post_id":"clhua15ap001e9gj7kaxem7y9","tag_id":"clhua15b100239gj7pe3ghfad","_id":"clhua15be002p9gj73amk5pt2"},{"post_id":"clhua15aq001g9gj77wbjvx31","tag_id":"clhua15bd002o9gj78ew60tj2","_id":"clhua15bg002u9gj7ssgroogr"},{"post_id":"clhua15ar001i9gj71512di82","tag_id":"clhua15bf002s9gj77xinbjnx","_id":"clhua15bi002y9gj7nzosx8vx"},{"post_id":"clhua15as001l9gj7zbvq8fmm","tag_id":"clhua15bd002o9gj78ew60tj2","_id":"clhua15bk00329gj7d1oppse5"},{"post_id":"clhua15at001n9gj7ru7fde3u","tag_id":"clhua15bd002o9gj78ew60tj2","_id":"clhua15bl00369gj7y5ed4ne0"},{"post_id":"clhua15au001p9gj70qoxuarv","tag_id":"clhua15bd002o9gj78ew60tj2","_id":"clhua15bn003a9gj77qavt7il"},{"post_id":"clhua15av001r9gj7zcyzi49u","tag_id":"clhua15bd002o9gj78ew60tj2","_id":"clhua15bp003e9gj7v8k4t7xe"},{"post_id":"clhua15aw001t9gj7u9vzubs1","tag_id":"clhua15bd002o9gj78ew60tj2","_id":"clhua15br003i9gj7glnuaxsl"},{"post_id":"clhua15ax001u9gj79b1zlxpj","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15bu003p9gj7ji0kayzq"},{"post_id":"clhua15ax001u9gj79b1zlxpj","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15bv003r9gj7hxye0iaf"},{"post_id":"clhua15ay001x9gj7fe4q4uvq","tag_id":"clhua15bu003o9gj7rk9p569z","_id":"clhua15by003v9gj72na000cr"},{"post_id":"clhua15az001y9gj7ij5zbbcn","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15c100429gj70v8t89im"},{"post_id":"clhua15az001y9gj7ij5zbbcn","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15c200439gj7vxvmifyd"},{"post_id":"clhua15b000219gj7damf1c7w","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15c300469gj7bgqoo101"},{"post_id":"clhua15b000219gj7damf1c7w","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15c300479gj73j5dkg8i"},{"post_id":"clhua15b000229gj7vtdk6wnf","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15c4004a9gj74i411whg"},{"post_id":"clhua15b000229gj7vtdk6wnf","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15c4004b9gj794zzyqjw"},{"post_id":"clhua15b100249gj7t98ywvlh","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15c5004e9gj7j03h7qvo"},{"post_id":"clhua15b100249gj7t98ywvlh","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15c6004f9gj7ks1msomk"},{"post_id":"clhua15b200269gj7zi340dtx","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15c7004j9gj744aleo7b"},{"post_id":"clhua15b200269gj7zi340dtx","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15c7004k9gj7nhz9y9gn"},{"post_id":"clhua15b200269gj7zi340dtx","tag_id":"clhua15c6004h9gj7skykqo6d","_id":"clhua15c7004m9gj7fmqfkvmu"},{"post_id":"clhua15b300289gj7jtd1gg0j","tag_id":"clhua15c6004i9gj7qqh7gkyv","_id":"clhua15c8004n9gj7k4zocasx"},{"post_id":"clhua15b4002a9gj7sz7sx4vv","tag_id":"clhua15c6004i9gj7qqh7gkyv","_id":"clhua15c8004p9gj7go4vn8xu"},{"post_id":"clhua15b5002c9gj7r2w0mdmf","tag_id":"clhua15bq003g9gj7nc9pjz0h","_id":"clhua15c9004s9gj7vn85a06d"},{"post_id":"clhua15b5002c9gj7r2w0mdmf","tag_id":"clhua15bs003k9gj73mdi81fn","_id":"clhua15c9004t9gj76c2in15p"},{"post_id":"clhua15b6002e9gj7dmojv78o","tag_id":"clhua15c6004i9gj7qqh7gkyv","_id":"clhua15ca004v9gj74gul13el"},{"post_id":"clhua15b7002g9gj7nfo592hl","tag_id":"clhua15c6004i9gj7qqh7gkyv","_id":"clhua15cb004x9gj754j7leez"},{"post_id":"clhua15b9002h9gj7s9khd4uk","tag_id":"clhua15cb004w9gj7e92a6cpm","_id":"clhua15cc00509gj7wtvxszna"},{"post_id":"clhua15b9002h9gj7s9khd4uk","tag_id":"clhua15cb004y9gj7uvm8wb34","_id":"clhua15cc00519gj72b1rehn0"},{"post_id":"clhua15ba002i9gj7w4wi037x","tag_id":"clhua15cc004z9gj7grohgwm2","_id":"clhua15cd00539gj7umv2fud8"},{"post_id":"clhua15bc002l9gj7bin3y6ed","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cd00559gj74tvtxv4k"},{"post_id":"clhua15bd002n9gj7lv42qus2","tag_id":"clhua15cd00549gj77kfsoj3k","_id":"clhua15ce00589gj78jll6et4"},{"post_id":"clhua15bd002n9gj7lv42qus2","tag_id":"clhua15cb004y9gj7uvm8wb34","_id":"clhua15ce00599gj7bs0zbhzp"},{"post_id":"clhua15be002q9gj7tojfl96t","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15cf005b9gj7lhiy4mr5"},{"post_id":"clhua15bf002r9gj7143prg4a","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15cf005d9gj7lrhkn9dz"},{"post_id":"clhua15bf002t9gj7g4jh7oda","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15cg005f9gj7sehax6nm"},{"post_id":"clhua15bg002v9gj718xrm6mb","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15ci005h9gj7czi8aon3"},{"post_id":"clhua15bh002x9gj7o9cs1omg","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15ci005j9gj7h87djajc"},{"post_id":"clhua15bi002z9gj72n3ewgy9","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15cj005l9gj7usfj2uof"},{"post_id":"clhua15bj00319gj72676u4du","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cl005n9gj78mr6qn9g"},{"post_id":"clhua15bk00339gj7zkk1jkon","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cm005p9gj7snjvm80i"},{"post_id":"clhua15bl00359gj7btmgnq2y","tag_id":"clhua15ce00579gj7mu70vg6b","_id":"clhua15cn005r9gj75mwuuasl"},{"post_id":"clhua15bm00379gj736jjzoqg","tag_id":"clhua15cm005q9gj7dw3vc9vr","_id":"clhua15cn005t9gj75m4u59nz"},{"post_id":"clhua15bn00399gj7oyh1m68w","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15co005v9gj7uhys0lzi"},{"post_id":"clhua15bo003b9gj7blfsakdl","tag_id":"clhua15cm005q9gj7dw3vc9vr","_id":"clhua15cp005x9gj7dnsin3v3"},{"post_id":"clhua15bp003d9gj7sufkpta4","tag_id":"clhua15cm005q9gj7dw3vc9vr","_id":"clhua15cp005z9gj7ms2g1obn"},{"post_id":"clhua15bp003f9gj70pswxkh3","tag_id":"clhua15cm005q9gj7dw3vc9vr","_id":"clhua15cq00619gj7jqsrt5ee"},{"post_id":"clhua15br003j9gj7w4g8h5jd","tag_id":"clhua15cm005q9gj7dw3vc9vr","_id":"clhua15cq00639gj7088d50w0"},{"post_id":"clhua15bs003l9gj7qq1tglwv","tag_id":"clhua15cq00629gj7jq4eduoz","_id":"clhua15cr00669gj70ryf0uyb"},{"post_id":"clhua15bs003l9gj7qq1tglwv","tag_id":"clhua15cr00649gj7j96g2mox","_id":"clhua15cr00679gj76b7kt4tw"},{"post_id":"clhua15bt003m9gj788gz8sol","tag_id":"clhua15cr00659gj7yfijzufr","_id":"clhua15cs00699gj7xnfb9vyr"},{"post_id":"clhua15bt003n9gj7rgbzqrnp","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15ct006c9gj7046uf0ei"},{"post_id":"clhua15bt003n9gj7rgbzqrnp","tag_id":"clhua15cs006a9gj79l7o49er","_id":"clhua15ct006d9gj7eq7zk2rr"},{"post_id":"clhua15bu003q9gj7wtrqbjkq","tag_id":"clhua15ct006b9gj7t58wr7v1","_id":"clhua15cu006g9gj7uw9ixaq8"},{"post_id":"clhua15bu003q9gj7wtrqbjkq","tag_id":"clhua15cb004y9gj7uvm8wb34","_id":"clhua15cu006h9gj7pstt4nr4"},{"post_id":"clhua15bv003s9gj71xxqde6g","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cv006j9gj7z561v17n"},{"post_id":"clhua15bx003u9gj77zjhb9tk","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cv006l9gj7gjwy9dth"},{"post_id":"clhua15by003w9gj7li54aldd","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cw006o9gj7fs4wwfak"},{"post_id":"clhua15by003w9gj7li54aldd","tag_id":"clhua15cv006m9gj7utn1hx6q","_id":"clhua15cw006p9gj70hgq49xw"},{"post_id":"clhua15bz003y9gj7lmogyp1s","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cx006s9gj7lt3hxpt4"},{"post_id":"clhua15bz003y9gj7lmogyp1s","tag_id":"clhua15cw006q9gj7o1qb6tw2","_id":"clhua15cx006t9gj7oimg36pr"},{"post_id":"clhua15c0003z9gj7nt3sj5yo","tag_id":"clhua15cc00529gj7a1c3dowb","_id":"clhua15cy006v9gj7jiajkum3"},{"post_id":"clhua15c100419gj763boxaw3","tag_id":"clhua15cx006u9gj71c7jbnks","_id":"clhua15cy006w9gj7in8mj596"},{"post_id":"cm71nfvo50000nnxf3r3i3msw","tag_id":"cm71nfvo90001nnxf2xfjuwed","_id":"cm71nfvsc0002nnxfca5b185h"}],"Tag":[{"name":"Mysql","_id":"clhua159x00059gj7jj192i14"},{"name":"Nginx","_id":"clhua15ab000n9gj7v8t0t465"},{"name":"docker","_id":"clhua15ak00149gj75mou1i84"},{"name":"Dubbo","_id":"clhua15am00189gj7l3nkzdrm"},{"name":"Git","_id":"clhua15av001q9gj7kiomaiqw"},{"name":"hexo","_id":"clhua15az001z9gj7j81o709o"},{"name":"JVM","_id":"clhua15b100239gj7pe3ghfad"},{"name":"Kafka","_id":"clhua15b5002b9gj7ohbiqpgv"},{"name":"Zookeeper","_id":"clhua15b6002f9gj7zd2y5j99"},{"name":"RabbitMq","_id":"clhua15bd002o9gj78ew60tj2"},{"name":"Maven","_id":"clhua15bf002s9gj77xinbjnx"},{"name":"Java","_id":"clhua15bq003g9gj7nc9pjz0h"},{"name":"Spring","_id":"clhua15bs003k9gj73mdi81fn"},{"name":"redis","_id":"clhua15bu003o9gj7rk9p569z"},{"name":"SpringBoot","_id":"clhua15c6004h9gj7skykqo6d"},{"name":"zookeeper","_id":"clhua15c6004i9gj7qqh7gkyv"},{"name":"分布式事务","_id":"clhua15cb004w9gj7e92a6cpm"},{"name":"解决方案","_id":"clhua15cb004y9gj7uvm8wb34"},{"name":"分布式","_id":"clhua15cc004z9gj7grohgwm2"},{"name":"设计模式","_id":"clhua15cc00529gj7a1c3dowb"},{"name":"分布式锁","_id":"clhua15cd00549gj77kfsoj3k"},{"name":"并发编程","_id":"clhua15ce00579gj7mu70vg6b"},{"name":"总结","_id":"clhua15cm005q9gj7dw3vc9vr"},{"name":"算法","_id":"clhua15cq00629gj7jq4eduoz"},{"name":"排序","_id":"clhua15cr00649gj7j96g2mox"},{"name":"正则表达式","_id":"clhua15cr00659gj7yfijzufr"},{"name":"模板方法模式","_id":"clhua15cs006a9gj79l7o49er"},{"name":"接口幂等性","_id":"clhua15ct006b9gj7t58wr7v1"},{"name":"适配器模式","_id":"clhua15cv006m9gj7utn1hx6q"},{"name":"java基础","_id":"clhua15cw006q9gj7o1qb6tw2"},{"name":"通讯协议","_id":"clhua15cx006u9gj71c7jbnks"},{"name":"rpc","_id":"cm71nfvo90001nnxf2xfjuwed"}]}}