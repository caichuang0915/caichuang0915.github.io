---
title: 总结-多线程
tags:
  - 总结
---



### 线程池

创建线程的方式，继承Thread类，实现Runable接口，但是Java是单继承多实现，所有推荐使用Runable的方式。

线程的状态

- 新建状态，new 一个线程的时候就是新建状态。
- 就绪状态，调用start方法之后，等待CPU调度。
- 运行状态，线程获取得了CPU，开始执行run方法.
- 阻塞状态，执行wait/sleep、等待锁 等方法。
- 死亡 run执行完成之后或者执行了stop方法。调用stop方法不会释放锁，可能会造成死锁。

---

seelp和wait的区别  

seelp是Thrad类中的一个方法，执行时不会释放锁，到了指定的时候继续执行，wait是Object中的方法，会释放锁，进入等待，需要notify/notigyall唤醒后才能继续执行。

---

为什么使用线程池

降低频繁创建线程的消耗，方便管理线程。

线程池的关键参数：

- 核心线程数
- 最大线程数
- 等待队列
- 线程存活时间
- 拒绝策略

线程的执行流程：

1. 提交一个任务判断线程池中的线程数量是否大于核心线程数，没有的话就创建一个线程执行
2. 大于等于最大核心线程数，则加入到等待队列中等待执行
3. 如果队列中已经满了，还有任务来，则继续创建线程只到达到最大线程数
4. 达到最大线程数之后的任务则按照拒绝策略执行
5. 任务执行完成后如果当前的线程数量大于核心线程数，则超过存活时间则会销毁掉多余的线程

---

为什么不推荐Executors创建线程池

- fix和single的使用的是无界队列
- scheduleh和delay最大线程数是intmax

两种情况都会导致创建大量的线程，可能会OOM

---

线程池合理配置

1. CPU密集型，主要是计算，压力在CPU,分配小的线程数，NCPU+1
2. IO密集型，压力不在CPU,可多分配线程，2 * NCPU

---

如何停止一个线程的方法

使用interrupt方法打上中断的标志，然后自己决定是否需要停止线程。

---

如何保证线程安全

- 栈封闭
- 无状态的类 没有任何成员变量的类
- 没有返回值


### Synchronized



#### 锁的对象

- 使用在方法上 或者锁的对象是this，则锁的对象是调用方
- 使用在静态方法，则锁的对象是当前类
- 指定具体的对象，则锁的是指定的对象

#### 实现原理

使用monitorenter和monitorexit指令实现同步，本质是对一个对象的监视器进行获取，同一个时刻只有一个线程可以获取到一个对象的监视器。


#### 锁升级过程

- 在Synchronize加锁时，如果偏向锁已经启动的情况，则此时是锁对象是偏向锁状态，否则是无锁状态。
- 偏向的锁的对象执行hashcode方法的时候会撤销到无锁的状态。原因是对象头中保存了对象的hashcode值。偏向锁对象头中存在的是线程ID
- 如果有少量线程竞争时，升级为轻量级锁，
- 大量线程竞争时，升级为重量级锁，对象头中存的是指向montior的指针。


#### Synchronized和Lock的区别

Lock是java中的一个接口，是java层面的锁，需要手动的释放，可以定制为不同情况的锁，多样化
Synchronized是属于JVM层面的锁，不能中断，不是公平的，不支持条件唤醒。


### TheadLocal

每个线程里面都维护着一个TheadLocalMap

TheadLocalMap里面又维护着一个entry数组，entry对象是ThreadLocal的弱引用，entry里面维护具体的值

TheadLocal.set() 会先回去当前线程的TheadLocalMap，然后保存当前threadLocl为key 值为value到TheadLocalMap里面，获取的时候先获取当前线程的threadlocalMap,然后以当前的threadlocal为key获取值。


问题：

1、存在线程池的时候可能会互相影像，每次使用完成之后需要remove()一下
2、存在内存泄漏问题 TheadLocalMap 的生命周期和线程的生命周期是一样的，所以如果没有手动删除key，就会导致内存泄漏。


### volatile

保证线程的可见性和有序性，不能保证原子性。引入了内存屏障，防止重排序。


### CAS

比较并交换，操作系统保证原子性。

### AQS

是一个构建锁和同步器的框架。

