---
title: JVM - java内存区域
tags:
  - JVM
---

java内存区域

#### java内存区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域： 

![java内存区域](http://image.tupelo.top/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png?imageMogr2/auto-orient/thumbnail/700x700)

<!-- more -->

- 程序计数器

    当前线程执行的字节码的行号指示器，占用空间小，也无法干涉

- 虚拟机栈

    每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，
    存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。
    每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。
    栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k

- 本地方法栈

    地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，
    JVM只是简单地动态链接并直接调用native方法。

- Java堆

    几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：
    -Xms：堆的最小值；
    -Xmx：堆的最大值；
    -Xmn：新生代的大小；
    -XX:NewSize；新生代最小值；
    -XX:MaxNewSize：新生代最大值；
    例如- Xmx256m



- 方法区(运行时常量池)

    用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，可用以下参数调整：
    jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；
    jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize
    jdk1.8以后大小就只受本机总内存的限制
    如：-XX:MaxMetaspaceSize=3M


- 直接内存

    不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；
    如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；
    这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），
    所以也会出现OOM异常。


栈、本地方法栈、程序计数器为线程私有内存区，随线程产生和消亡，不需要过多考虑内存回收的问题。堆和方法区为线程间共享。

#### java内存区域各个版本之间的变化

- jdk1.6 运行时常量池和方法区在一起
- jdk1.7 运行时常量池改为和堆在一起
- jdk1.8 方法区移出了运行时数据区，并改为了元空间metaspace

#### 栈上分配和逃逸分析

虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，<font color="red">任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</font>

- 启用栈上分配

```
-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client
-Xmx10m和-Xms10m：堆的大小
-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)
-XX:+PrintGC：打印GC日志
-XX:+EliminateAllocations：标量替换(默认打开)
-XX:-UseTLAB 关闭本地线程分配缓冲TLABThreadLocalAllocBuffer
```

对栈上分配发生影响的参数就是三个，```-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations```，任何一个发生变化都不会发生栈上分配，其中启用逃逸分析和标量替换默认是打开的。

#### 虚拟机中对象的分配

虚拟机遇到一条new指令时：      

1. 先执行相应的类加载过程。
2. 接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
如果Java堆中<font color="red">内存是绝对规整的</font>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<font color="red">指针碰撞</font>”。
如果Java堆中的<font color="red">内存并不是规整的</font>，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<font color="red">空闲列表</font>”。
<font color="red">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</font>
除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理,实际上虚拟机采用<font color="red">CAS配上失败重试的方式保证更新操作的原子性</font>；
另一种是<font color="red">把内存分配的动作按照线程划分在不同的空间之中进行</font>，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数<font color="red">``` -XX:UseTLAB```</font>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。
TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。
TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。
3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中
5. 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。


#### 对象的内存布局

- 对象头（Header）
- 实例数据（Instance Data）
- 对齐填充（Padding）

#### 对象的访问定位

- 句柄访问
- 直接指针访问

#### 堆参数设置和内存溢出实战

- 堆溢出

```java.lang.OutOfMemoryError: GC overhead limit exceeded``` 一般是（某个循环里可能性最大）在不停的分配对象，但是分配的太多，把堆撑爆了。     
```java.lang.OutOfMemoryError: Java heap space``` 一般是分配了巨型对象。     

- 栈溢出

```java.lang.StackOverflowError``` 一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。